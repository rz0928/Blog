{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cat1.jpg","path":"images/cat1.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cat2.jpg","path":"images/cat2.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/addtoany.js","path":"js/third-party/addtoany.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","path":"js/third-party/analytics/matomo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/wavedrom.js","path":"js/third-party/tags/wavedrom.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_drafts/java两锁之一的ReetrantLock.md","hash":"fdc64634bd890c6d037818cf5ab0c0b1d0123e7c","modified":1725957877428},{"_id":"source/_posts/AOP.md","hash":"a8a080492a5e7187e76a2aaa44de6a88775e7494","modified":1730030057202},{"_id":"source/_drafts/什么是HTTPS.md","hash":"96b3a6f705a0dcb9102920d2ab2c552fa919aa94","modified":1725352709313},{"_id":"source/_posts/SpringBoot日志基础.md","hash":"825cef15f065e7f99114ab566bc623e217169774","modified":1730298466928},{"_id":"source/_posts/ThreadLocal小结.md","hash":"236420dca5f7a2746a3c36fc14c1a6b1e7391538","modified":1715238535048},{"_id":"source/categories/index.md","hash":"e29008df0a77a03d8bc3fe7d8f8e22a6fc48567b","modified":1715688702191},{"_id":"source/_posts/SpringBoot参数校验.md","hash":"34bf3f1da25fc55be50c0218caabbf089404d81f","modified":1725331215063},{"_id":"source/_posts/id生成.md","hash":"b38f45bca9d3d5661ced62663fb99b70c9701902","modified":1729771796670},{"_id":"source/_posts/java_IO.md","hash":"333d32ae05d33f87698737298b1a2f21f1d0d79f","modified":1730030121305},{"_id":"source/_posts/Spring自动装配原理.md","hash":"884eed2fadf1061eb527384e5a97e734c0369382","modified":1725331607966},{"_id":"source/_posts/java两锁之一的synchronized.md","hash":"951eb2a32acca04a2ebdd3c0b6855c9707bc8759","modified":1730030260581},{"_id":"source/_posts/java两锁之一的ReentrantLock.md","hash":"720612a46f21111f299359b85a594329c66d595d","modified":1730125493074},{"_id":"source/_posts/什么是伪共享.md","hash":"592101119afe0434a6e655b87988a9532cae3775","modified":1730277754829},{"_id":"source/about/index.md","hash":"20dbc2e1dc5e27127dc371cd16c03151f50d0130","modified":1715688717905},{"_id":"source/_posts/jvm.md","hash":"9fdff597b0cd5187ca214e5f79d63be5d1290f9c","modified":1730277926271},{"_id":"source/tags/index.md","hash":"d7d6c9d80fa5f52f3f96ab364de5f17352e008b3","modified":1715688796357},{"_id":"source/_posts/算法合集.md","hash":"22b64e8edb452bbf767eea6ae9ef2816e106a7f1","modified":1730081708495},{"_id":"source/_posts/Spring自动装配原理/模块装配二.png","hash":"2cf88ddbf269d9fdb41df66ff1c8d9df7805b5e6","modified":1714720472707},{"_id":"source/_posts/id生成/雪花算法.webp","hash":"9681912670a32ab25e0ef7495173627a3ac344b9","modified":1725260540923},{"_id":"source/_posts/Spring自动装配原理/模块装配方式一.png","hash":"b7d05a1fbead943ab6c17fc8cee78335085cf869","modified":1714719641133},{"_id":"source/_posts/java_IO/1492928105791_3.png","hash":"d5636be0247331e417bafb8e6f010a6f1e1614a7","modified":1725956401713},{"_id":"source/_posts/java_IO/JavaNIOBuffer.png","hash":"037af1141944d17bc173428be00f11f109366639","modified":1725956401714},{"_id":"source/_posts/java_IO/java-io-model-0.png","hash":"a318b5e73bf71ba44231e0d5d0955b3903ba9dd3","modified":1725956401701},{"_id":"source/_posts/java_IO/java-io-model-2.png","hash":"d0fac0e6cd9cd891cced92123e3a48b0be88bc91","modified":1725956401702},{"_id":"source/_posts/java_IO/image-20240226193441574.png","hash":"99bf223ee0be5ef7987de6bb4be85b1aa676fc0a","modified":1725956401702},{"_id":"source/_posts/java_IO/java-io-model-4.png","hash":"ffa8adcc681931a00bea1d850737f6805ec2ae8c","modified":1725956401713},{"_id":"source/_posts/java_IO/java-io-model-1.png","hash":"c00fe47ed4bec8a77ff9cff9290e553cad9ab0ed","modified":1725956401701},{"_id":"source/_posts/java_IO/java-io-model-3.png","hash":"51f5eb4f88eebbdc9fe4aa76d7588cd607a718c6","modified":1725956401702},{"_id":"source/_posts/java_IO/java-io-reactor-4.png","hash":"ce4049bd90956c03406ef5ae48ea2ceebe52524b","modified":1725956401730},{"_id":"source/_posts/java两锁之一的synchronized/image-20240513145730228.png","hash":"69b8f94715243e31b3df1c58a974175093bf3bc5","modified":1715583450281},{"_id":"source/_posts/java_IO/java-io-reactor-1.png","hash":"d690001ef2b51658e5dbb8bd96226bc9de977d7d","modified":1725956401730},{"_id":"source/_posts/java两锁之一的synchronized/image-20240513150908609.png","hash":"e5a9c4fd8c08519d5f19713f7ed65a85117c4f1c","modified":1715584148630},{"_id":"source/_posts/java两锁之一的synchronized/java重量级锁.webp","hash":"011b924544ca2bfea4a42539b71545a40f2b5da1","modified":1715588354009},{"_id":"source/_posts/jvm/82a369cjhi.jpeg","hash":"0eed71a1bb7226dbfaeb8f29027e8e27c3020738","modified":1725957326549},{"_id":"source/_posts/jvm/image-20231116194904286.png","hash":"00b56b56f41e19f04b1beb5ede61774364f337dd","modified":1725957326549},{"_id":"source/_posts/jvm/image-20231116204902025.png","hash":"8273a2fc0d974570d082f045096c1fcef8f71ddf","modified":1725957326550},{"_id":"source/_posts/jvm/image-20231116203451353.png","hash":"52e9bdbf6996349b7d02659cc1d4fc57582b14b4","modified":1725957326550},{"_id":"source/_posts/jvm/image-20231205215707315.png","hash":"6d1598a3c3da1e0f151d7869f2320a633393042f","modified":1725957326550},{"_id":"source/_posts/jvm/image-20231214195613362.png","hash":"16fef897b442ebe0e67463eca651815d79e97586","modified":1725957326550},{"_id":"source/_posts/jvm/image-20231214194507254.png","hash":"d7a617c794b06671c3ce6d04e70db8ba8435c5ec","modified":1725957326550},{"_id":"source/_posts/jvm/image-20231214221246377.png","hash":"5334d62e62db5bf23006c9c647ee1ca2fc11ddbd","modified":1725957326550},{"_id":"source/_posts/jvm/image-20231217221608733.png","hash":"d261335241db5cba5bc588b9602e9f202cc6bd1d","modified":1725957326552},{"_id":"source/_posts/jvm/image-20240326163359886.png","hash":"0ff8a835a4a83b65263cc665b81989d3c988ded8","modified":1725957326554},{"_id":"source/_posts/jvm/image-20231116200128095.png","hash":"dfd24825774e25b638ec08dfbb54476f55d8586c","modified":1725957326552},{"_id":"source/_posts/jvm/image-20231127105115660.png","hash":"367c188c133c4b3edeaaa149a9f6c54c1450ac87","modified":1725957326553},{"_id":"source/_posts/jvm/image-20231201151500158.png","hash":"e15c18c6a16428547d1804b26ff0505faeb1ea2f","modified":1725957326551},{"_id":"source/_posts/jvm/image-20231201151745264.png","hash":"019f77a8437bb601e502d64b737b7c3dd470711a","modified":1725957326551},{"_id":"source/_posts/jvm/image-20231201151606407.png","hash":"7ce0518b0a233d0146f49b6480160e564b934181","modified":1725957326551},{"_id":"source/_posts/jvm/image-20231206112755092.png","hash":"48daa92af8d70897103a5c70524af9b3192a0861","modified":1725957326553},{"_id":"source/_posts/jvm/image-20231214111741606.png","hash":"73c1d4f0016df7959a0ecc39f4295c383f51d7d6","modified":1725957326553},{"_id":"source/_posts/jvm/image-20231214193447991.png","hash":"047c5753cdf22cb3d59227b4d08b2fe77fcc781f","modified":1725957326554},{"_id":"source/_posts/jvm/image-20231217221643907.png","hash":"269d70f92fe6b4e13059e5e2da8a376b73a51f6a","modified":1725957326555},{"_id":"source/_posts/SpringBoot日志基础/image-20240530151255937.png","hash":"d92ab8047512c19885398659fdcac579c9cde2b5","modified":1725351318394},{"_id":"source/_posts/java_IO/image-20240225220137926.png","hash":"56290dec079f99c158461267572a6b8a2573988c","modified":1725956401731},{"_id":"source/_posts/jvm/image-20231116202718426.png","hash":"48c3fcc26a170a09cda5657669a83e8d9daee9b4","modified":1725957326557},{"_id":"source/_posts/java两锁之一的synchronized/jvm_markWord.png","hash":"7db0b5805349a77b68e50f3403fc764027782733","modified":1712642133183},{"_id":"source/_posts/java_IO/java-io-overview2.png","hash":"7c01838928822ba000e7958481874dbd0b6a6824","modified":1725956401730},{"_id":"source/_posts/jvm/image-20231116202440545.png","hash":"c7037a97472868d5d833b2506e09cce8e344be92","modified":1725957326555},{"_id":"source/_posts/jvm/image-20231205215113256.png","hash":"ca6ae4481a64eb68f2fd64cd20c18acbb29d5d38","modified":1725957326557},{"_id":"source/_posts/SpringBoot参数校验/image-20240602190311638.png","hash":"41444ce20ca558d87c398536409a3080a1397fe1","modified":1717326191797},{"_id":"source/_posts/java_IO/image-20240226191911489.png","hash":"3d37fd294bbbcd4df7d3a96e1900e7feda728b64","modified":1725956401759},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1715669101119},{"_id":"themes/next/.gitignore","hash":"087b7677078303acb2acb47432165950e4d29b43","modified":1715669101129},{"_id":"themes/next/.gitattributes","hash":"aeeca2f1e987d83232d7870d1435a4e3ed66b648","modified":1715669101119},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1715669101129},{"_id":"themes/next/_vendors.yml","hash":"673b2abe0100894b014e94ee3c68ad8528cf126d","modified":1715669101129},{"_id":"themes/next/.stylelintrc","hash":"20f46858e47aba6b3fc47e9b43e9f7531fa66e33","modified":1715669101129},{"_id":"themes/next/eslint.config.js","hash":"e35570c8e7ef9ea4adad7bafb3558dfd8e928e48","modified":1715669101139},{"_id":"themes/next/package.json","hash":"aba13d6547cae25364dc84cadccf717a82ba2a19","modified":1715669101199},{"_id":"themes/next/renovate.json","hash":"767b077c7b615e20af3cf865813cd64674a9bea6","modified":1715669101199},{"_id":"themes/next/.githooks/install.js","hash":"72757c6827909a5f2c217ddbbdf6034ca6fab74a","modified":1715669101119},{"_id":"themes/next/.githooks/pre-commit","hash":"b69b9d0b51e27d5d4c87c3242f5067c2cda26e44","modified":1715669101119},{"_id":"themes/next/README.md","hash":"ede4d2a210b26eabd1546c864ff0bc40455122b5","modified":1715669101129},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1715669101139},{"_id":"themes/next/LICENSE.md","hash":"8cfb03967dd4cbaf3b825271ffce0039aa3fc22a","modified":1715669101129},{"_id":"themes/next/docs/AUTHORS.md","hash":"579014d47f45b27fd1618b9709f0efe9585c7449","modified":1715669101139},{"_id":"themes/next/docs/LICENSE.txt","hash":"d1cd5a8e83d3bbdb50f902d2b487813da95ddfd3","modified":1715669101139},{"_id":"themes/next/languages/README.md","hash":"b1c96465b3bc139bf5ba6200974b66581d8ff85a","modified":1715669101139},{"_id":"themes/next/languages/de.yml","hash":"5101612f7cac38884206d28319532f1aab32fbe6","modified":1715669101139},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1715669101139},{"_id":"themes/next/languages/bn.yml","hash":"30ffd43588ddf2cd39432d964087242e1c3e5407","modified":1715669101139},{"_id":"themes/next/languages/en.yml","hash":"5ca2c0b3c95dd87485f2d2b3477f88810ad1a63b","modified":1715669101139},{"_id":"themes/next/languages/eo.yml","hash":"7bd0124c2d1dcdbfde350fce335e130556ebcee8","modified":1715669101139},{"_id":"themes/next/languages/fa.yml","hash":"cc6ef3144b954daa29ce7d42f08191eafe052fab","modified":1715669101149},{"_id":"themes/next/languages/es.yml","hash":"31c2a47d14cd5b804cae0c0b44d43bece069d3aa","modified":1715669101139},{"_id":"themes/next/languages/ar.yml","hash":"c77fc13e0431e71eeb0f767a0a436284fc81df90","modified":1715669101139},{"_id":"themes/next/languages/id.yml","hash":"bd2c30def05a37c66653900ca07952d52a142961","modified":1715669101149},{"_id":"themes/next/languages/fr.yml","hash":"3a7469446f77e5d1a12eee828ebc49ecb43b6c35","modified":1715669101149},{"_id":"themes/next/languages/ko.yml","hash":"04927e331652ee13f9c8a110fe12d7f936a6b0e6","modified":1715669101149},{"_id":"themes/next/languages/ja.yml","hash":"e660ec12b9eade103492aba7aa9b23ef06d353a9","modified":1715669101149},{"_id":"themes/next/languages/it.yml","hash":"4969c4f17d88003135218de72ddf0bf8d894dc07","modified":1715669101149},{"_id":"themes/next/languages/pt-BR.yml","hash":"ff9aa6a6549d07b7dc667094f34a06945e2c21b4","modified":1715669101149},{"_id":"themes/next/languages/nl.yml","hash":"4575f93c4ee4383bdfaca01ad6ffff5664cbbbae","modified":1715669101149},{"_id":"themes/next/languages/ru.yml","hash":"d726265bc5cf8bd4fb64f85b2d07b3326439bb00","modified":1715669101149},{"_id":"themes/next/languages/si.yml","hash":"07f98d6ca99bceef35254c60fc0e4401ff608557","modified":1715669101149},{"_id":"themes/next/languages/th.yml","hash":"dc434da945d52dc7a8d26acc80b23e6922712f89","modified":1715669101149},{"_id":"themes/next/languages/pt.yml","hash":"1fa9f4f4f208191afd0e6108ce89d91c657a6bd0","modified":1715669101149},{"_id":"themes/next/languages/uk.yml","hash":"10a2f2e7183410d1d10fa937e3e0198b46bf4930","modified":1715669101149},{"_id":"themes/next/languages/tk.yml","hash":"7b9115e0520dc81a95a7c8e4f56a01fc84f74017","modified":1715669101149},{"_id":"themes/next/languages/vi.yml","hash":"8344cb90ee92a21a398faff3317c025a43446db5","modified":1715669101149},{"_id":"themes/next/languages/tr.yml","hash":"822ec400a0a2bb2245abf31e9ed4f3af77b2814e","modified":1715669101149},{"_id":"themes/next/layout/_layout.njk","hash":"0f2760cd7550ca30ffcc28e2dbd7f031a237b5a7","modified":1715669101159},{"_id":"themes/next/layout/category.njk","hash":"82f541452cae76a94ee15cb8d8a888f44260a0fd","modified":1715669101199},{"_id":"themes/next/languages/zh-HK.yml","hash":"6cfdc633870b814f3d75438e86f6ee5dba068987","modified":1715669101149},{"_id":"themes/next/languages/zh-TW.yml","hash":"198e3745b99ba5a2b75cc24d03f3412e272b7fa1","modified":1715669101159},{"_id":"themes/next/layout/archive.njk","hash":"aa491dba8f746e626c273a920effedf7d0b32170","modified":1715669101199},{"_id":"themes/next/layout/post.njk","hash":"6767de9702a07a2a4e16a8a6bc9c5919536c1e3f","modified":1715669101199},{"_id":"themes/next/languages/zh-CN.yml","hash":"c06c95121b3e5bd5abe01848073fbe7f9d6dcda9","modified":1715669101149},{"_id":"themes/next/layout/index.njk","hash":"fa52c3049871e879980cb6abccdea3792ca4ce70","modified":1715669101199},{"_id":"themes/next/test/index.js","hash":"983a505399796b9d9e174ba46d89abbdde38f8ee","modified":1715669101309},{"_id":"themes/next/layout/tag.njk","hash":"b6c017d30d08ddd30d66e9c6f3a71aa65d214eac","modified":1715669101199},{"_id":"themes/next/layout/page.njk","hash":"d24238eea91a347050a663c7a7de8cebaab4c595","modified":1715669101199},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"a60b386c7889f25f811182cae76e6474cb3254d1","modified":1715669101159},{"_id":"themes/next/docs/ru/README.md","hash":"c101be459aaff0fb7ec8a2d17031a3795545ea0d","modified":1715669101139},{"_id":"themes/next/layout/_partials/comments.njk","hash":"60f4620dd479da6d86d1d493440e9e2a28b6e132","modified":1715669101159},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"e077bebf4fb89b159b840b30f0230b95ff7db8a5","modified":1715669101139},{"_id":"themes/next/docs/zh-CN/README.md","hash":"48d170250e3f0c7aaf6ede8d52c602422936ba1e","modified":1715669101139},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"a09ceb82b45dd8b7da76c227f3d0bb7eebe7d5d1","modified":1715669101139},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"b9fc0a6b02f0380de939d1ea2a7c7d2e6be9f462","modified":1715689675785},{"_id":"themes/next/layout/_scripts/index.njk","hash":"6cb844a8c24642abc8733cbc8efcbcdbbf9481e8","modified":1715669101179},{"_id":"themes/next/layout/_macro/post.njk","hash":"c39170b22c4c9cb11d935c301a90ad8c18f3e0e8","modified":1715669101159},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"c55167bc0dbe7e104d4f4d782e98fcabc7e07a35","modified":1715669101169},{"_id":"themes/next/layout/_partials/languages.njk","hash":"537026fc120adeef9148c98ebf074207e3810538","modified":1715669101159},{"_id":"themes/next/layout/_partials/footer.njk","hash":"8047c6e8aa8fbf7f177d5f97b5df3df6045fb38b","modified":1715689152541},{"_id":"themes/next/layout/_third-party/addtoany.njk","hash":"9ef81adb0c35ebdb4499602155e87611aee0762a","modified":1715669101179},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"0a1470440f11362df2b1cd6b6228e273d9f999d6","modified":1715669101179},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"bb5d32170b469dc018ceaa10a5b7cb892c9b85a4","modified":1715669101169},{"_id":"themes/next/layout/_third-party/index.njk","hash":"9bab629e2971b029545511b48f397445858ac7f0","modified":1715669101189},{"_id":"themes/next/scripts/events/index.js","hash":"8ae618d4436dab49928c2bebc0837e5310dbe7de","modified":1715669101199},{"_id":"themes/next/layout/_third-party/fancybox.njk","hash":"53ad3c31762b74e5d29787b37d5e494cc4fded9b","modified":1715669101189},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"73bc15a9c3c5c239ab90efa19a1e721f41f3cb93","modified":1715669101189},{"_id":"themes/next/scripts/filters/locals.js","hash":"87f3bff03fa9fd96cf0787a6442464a7ff57f76b","modified":1715669101209},{"_id":"themes/next/scripts/filters/minify.js","hash":"0f6b9b0eb41f6319e75ff86f9254cf1a9d3333b8","modified":1715669101219},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"0c9a1fe9906672724dbf274154a37bac1915ca2c","modified":1715669101209},{"_id":"themes/next/layout/_third-party/pace.njk","hash":"13b2a77b4858a127f458ea092b6f713b052befac","modified":1715669101189},{"_id":"themes/next/scripts/filters/post.js","hash":"e6cf4c94fc2291215a3345134ddbbc74d5091b00","modified":1715669101219},{"_id":"themes/next/source/css/_colors.styl","hash":"a88430865c99f47ce1d8240f8895819b8b7b0c06","modified":1715669101229},{"_id":"themes/next/scripts/helpers/font.js","hash":"0a6fa582a0890ecaf5f03f758a730936e48aeca1","modified":1715669101219},{"_id":"themes/next/scripts/helpers/navigation.js","hash":"82f6e81bacf23d10cac71b09cff8708e47891ef3","modified":1715669101219},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bf50f31a3adecef3f42a2df7cda70a369d102e09","modified":1715669101219},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"7d0b7ea07f35739d9f05fc133282fa188a2f2991","modified":1715669101219},{"_id":"themes/next/source/css/_mixins.styl","hash":"1e56914de01b968b535d777f5b717e88002021e9","modified":1715669101269},{"_id":"themes/next/scripts/helpers/next-paginator.js","hash":"2e8dcc12a52517bb4e00ea611720bcd298624112","modified":1715669101219},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"ceff5e76564a5d6ed3e0222bccf581e106d80f3c","modified":1715669101219},{"_id":"themes/next/scripts/tags/button.js","hash":"86c71c73a63744efbbbb367612871fede0d69529","modified":1715669101219},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"8e912c715702addaf0cefe63e580e45b97ae8c3f","modified":1715669101219},{"_id":"themes/next/source/css/main.styl","hash":"c326550ce8b4deaa9b647bcfe3cdc04c100644e6","modified":1715669101279},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"12814eb1845830204e3a398eb93a2c15e0ff8d94","modified":1715669101219},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"b4d12e6fe29089be0f43bafc9eea736602cd16bf","modified":1715669101219},{"_id":"themes/next/scripts/tags/index.js","hash":"1a680bb01e14152905efe3ef624621dd74cf27c3","modified":1715669101219},{"_id":"themes/next/source/css/noscript.styl","hash":"64b378a4d2f0b36bf666fba13b57c59da3a8ac83","modified":1715669101279},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"b139224ff2cc668f4d95bde184934833e05b29df","modified":1715669101219},{"_id":"themes/next/scripts/tags/note.js","hash":"a12fd53e421400836a3722ae69130969558d6ac0","modified":1715669101229},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e0ed5fe1bc9d2957952a1aacdf3252d6ef3f9743","modified":1715669101229},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"652140814527db74bcde9110142824dc727be889","modified":1715669101219},{"_id":"themes/next/scripts/tags/label.js","hash":"c18b0e619a779ed40be7f014db92af18f45fbd5c","modified":1715669101219},{"_id":"themes/next/scripts/tags/pdf.js","hash":"317ba4611020cc840854386dde098dbbe452777e","modified":1715669101229},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"3f358bb78c5c6fdf45de287f3ead553e3a6a93c2","modified":1715669101219},{"_id":"themes/next/scripts/tags/video.js","hash":"f6ad3f52779f0636251238d3cbdc5b6f91cc5aba","modified":1715669101229},{"_id":"themes/next/test/helpers/index.js","hash":"2fb58dca3df2fe53116ee2b1232fa26ebe7b2ce5","modified":1715669101309},{"_id":"themes/next/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1715669101279},{"_id":"themes/next/scripts/tags/wavedrom.js","hash":"188c1dd5d7dbc566cac00946da86aa76fff1c682","modified":1715669101229},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1715669101279},{"_id":"themes/next/test/helpers/next-url.js","hash":"557d2c819184620e5ca65cb0a140a4cf7f7aeb9e","modified":1715669101309},{"_id":"themes/next/test/helpers/font.js","hash":"6f5076bd3f2724e47b46ca69028393a9b6275cd1","modified":1715669101309},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1715669101279},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1715669101279},{"_id":"themes/next/source/images/cat1.jpg","hash":"f251d159d88c3db90db9be0c3c474433ac51f713","modified":1696691043971},{"_id":"themes/next/source/images/favicon.ico","hash":"fe2f6c4f4585152e221759ef35a725f8b879cbcd","modified":1715238358931},{"_id":"themes/next/source/images/cat2.jpg","hash":"8d684a3f8b2b7a1fa2da3fb28631d41b93a0bb98","modified":1696691041722},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"5a81f1c5d66561b3bcb05dae48148088a3fb5c79","modified":1715669101279},{"_id":"themes/next/source/js/bookmark.js","hash":"e2fd71f2876531f4c8bf1f38828aae35dd82cca4","modified":1715669101279},{"_id":"themes/next/source/js/comments.js","hash":"0b4daf0ce610760bd52e95d423f61f3e1c72442a","modified":1715669101289},{"_id":"themes/next/source/js/comments-buttons.js","hash":"81ea6cbcdf0357094753d7523919c1eafa38e79f","modified":1715669101279},{"_id":"themes/next/source/images/logo.svg","hash":"099e11ab995a2c8981427a85476d082609848c77","modified":1715669101279},{"_id":"themes/next/source/js/config.js","hash":"211a9ab35205ccfa6b7c74394bade84da0d00af7","modified":1715669101289},{"_id":"themes/next/test/validate/index.js","hash":"560862194991c5963da5a411629d8e6c71d20ee2","modified":1715669101309},{"_id":"themes/next/source/js/pjax.js","hash":"c7802d0e721197eb854f0cd9b83f1f9dad247786","modified":1715669101289},{"_id":"themes/next/source/js/motion.js","hash":"40442746ab45600b59c94c716e30eab9ba912734","modified":1715669101289},{"_id":"themes/next/source/js/next-boot.js","hash":"67256d0b4e4f8277bef8fd5b05d2443d945cb008","modified":1715669101289},{"_id":"themes/next/source/js/schedule.js","hash":"4858233224756e3cadfabd8135f7c4b1e3673b44","modified":1715669101289},{"_id":"themes/next/test/tags/center-quote.js","hash":"2ac4b5a358681691a17e736de06fce0b640a7023","modified":1715669101309},{"_id":"themes/next/test/tags/button.js","hash":"a50ca44eaec3d91c2958e3157d624cd3e68828c7","modified":1715669101309},{"_id":"themes/next/source/js/sidebar.js","hash":"f3052996408a09233ffaf8d631fd930443ccd781","modified":1715669101289},{"_id":"themes/next/test/tags/index.js","hash":"5cad001936a694bf32d59751cc2b68a66199f976","modified":1715669101309},{"_id":"themes/next/test/tags/label.js","hash":"6cad7d84c42511459a89cda3971e8ea5cdee0125","modified":1715669101309},{"_id":"themes/next/test/tags/caniuse.js","hash":"2852be850d9103c25114253a45e6c62e32517de4","modified":1715669101309},{"_id":"themes/next/test/tags/group-pictures.js","hash":"8f66d3c6f03fb11d85aa2ab05c9b3c9aa2b4e994","modified":1715669101309},{"_id":"themes/next/source/js/utils.js","hash":"ca8e963f81d579319e6ba2a188f8c4a633493b92","modified":1715669101309},{"_id":"themes/next/test/tags/link-grid.js","hash":"41730266306c02362258384cd73659223928361f","modified":1715669101309},{"_id":"themes/next/test/tags/mermaid.js","hash":"4d56e937497f6c1095a5e264a64243ef203f2b5a","modified":1715669101309},{"_id":"themes/next/test/tags/tabs.js","hash":"b19d2592347eae5d6a7a97ca7e8cec03e8f25b51","modified":1715669101309},{"_id":"themes/next/test/tags/pdf.js","hash":"2d114596a8a180b2f3cd2a9c6528a328961f12d4","modified":1715669101309},{"_id":"themes/next/test/tags/note.js","hash":"161a81ce749e239d2403681372d48ecc1b51d7b9","modified":1715669101309},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"1b2ae17f3c394ce310fe2d9ed5f4d07d8cc74ae7","modified":1715669101159},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"fd75652957c1c3668874fdfd16f4f56027be0d8b","modified":1715669101159},{"_id":"themes/next/test/tags/video.js","hash":"88db9a3a26cd35525c43c0339fcd1c5965ec9518","modified":1715669101309},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"e016c3f80db433f17781caf26e44f2089a71550a","modified":1715669101159},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"7bf2b6ab499775355bbf8f3ae597ff7bc00e89e4","modified":1715669101159},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"828700af2a2f273d3e3e0554ffc60706d889d539","modified":1715669101159},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"20cb9c39bcdcfa3f710df7bc5838d6e62d4dd674","modified":1715669101159},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"62513f08e9e7f4abeaeedca91fd0af0861a2540f","modified":1715669101159},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"92553feb26f30f7fc9147bc4ef122908a9da06be","modified":1715669101169},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"6ec9c97e91c793cc2eb5ac0f7c3c36fdaaf637d1","modified":1715669101169},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"b352346dd2cb42f7eeaec5e39d9a2a353b029775","modified":1715669101169},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"1fe44a1e156cd30e3e9fd8313e1011ad30970f83","modified":1715669101169},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"ebe45ab38ace03ea74eed3f676ec1cb5805a3c8a","modified":1715669101169},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"752df7d12360a077c51a25609916a3ecc1763bb3","modified":1715669101169},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"8d76300e31178e790400a37adfaf9bc0e5f8fae7","modified":1715669101169},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"10145ae7ef87b502d20bfa08beb2b899228f1419","modified":1715669101169},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"9a7eda45ad0753d5f624c51a56e00277ba97c93d","modified":1715669101169},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"22c922214982c4bb78ea92fa2ff1de93d98216a3","modified":1715669101169},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"fd6fde597ea2fb7b80cffd0a3553c8e73acb8ab2","modified":1715669101169},{"_id":"themes/next/layout/_partials/post/post-share.njk","hash":"8a6414987474592e82b3e57eeb0bd526ae42d235","modified":1715669101169},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"3fbc72427c1211e5dcfd269af1a74852a7ba5c1a","modified":1715669101179},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"09d2c9487d75894d45a823e3237ae9f90fd6ee01","modified":1715669101179},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"9a9c4fb7e7c4fe4b7d474bdfdb4ed2b0a5423df2","modified":1715669101169},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"3e80332f88b101141be69f2a07f54ed8c053eabb","modified":1715669101179},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"52ad137450f7b3d6a330e16b3ed1c6174290f0eb","modified":1715669101179},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"81abcf790cf97395cde9e3cd6d5d1aa5656bd134","modified":1715669101179},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"17173c45f0b740669ef45aaae1fe96eeb0a0ff52","modified":1715669101179},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"9ff9ec05c2037beea229a6bb698f9e3546973220","modified":1715669101179},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"1856c4b035c5b8e64300a11af0461b519dfc4cf4","modified":1715669101189},{"_id":"themes/next/layout/_third-party/analytics/microsoft-clarity.njk","hash":"24719266662fcff63e88a21ee9b5b284abb8b37c","modified":1715669101179},{"_id":"themes/next/layout/_third-party/analytics/plausible.njk","hash":"64ed6fecae79f9f9c61e956d2bd077792473e069","modified":1715669101179},{"_id":"themes/next/layout/_third-party/analytics/matomo.njk","hash":"43238bc1bc2e88d707f8097814ef3ff830cbe641","modified":1715669101179},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"1df65b1390add93b86ae3f9423d96a130b0ece04","modified":1715669101189},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"a62aa1ed4e35b8d0451d83f341bf0a97538bc9a4","modified":1715669101189},{"_id":"themes/next/layout/_third-party/analytics/umami.njk","hash":"c8b8c10dcf5c4ffa4a8aec5ba5892842ec204ac0","modified":1715669101179},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"c5086b4c35f730f82c99c4a8317f2f153ebde869","modified":1715669101189},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"599f3f5e4385501d0010edc02ed9ca547d2467f7","modified":1715669101189},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"5f7967bd946060f4102263a552ddfbae9975e7ea","modified":1715669101179},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"b0828dd1b1fd66ecd612d9e886a08e7579e9a4f7","modified":1715669101189},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"6fd4df5c21cfe530dbb0c012bc0b202f2c362b9c","modified":1715669101189},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"210c32b654adae3d8076c4417d370b42af258cea","modified":1715669101189},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"38badcc7624a13961381c2465478056b9602aee5","modified":1715669101189},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"d97790e4b442a1e3ded7d7b4f84b8ee6cdb6e8ea","modified":1715669101189},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"b8e0d5de584cece5e05b03db5b86145aa1e422b4","modified":1715669101189},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"a7921be7328e1509d33b435175f5333a9aada66f","modified":1715669101189},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"dd8f963acd5a3685be46fd5319c06df0308d99b2","modified":1715669101199},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"af5336e8bbdc4638435971da115bb7443d374ade","modified":1715669101189},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"866ffa15a3250678eb8a90aa6f609fa965db90fd","modified":1715669101199},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"0386c708975cc5faea4f782611c5d2c6b8ac2850","modified":1715669101199},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"8703d1855bb8d251c9b7c2940b7e3be525e53000","modified":1715669101199},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"550cc7f57bc3ab3d093e34741e7860222851d4d4","modified":1715669101209},{"_id":"themes/next/layout/_third-party/tags/wavedrom.njk","hash":"baec18165d767094ecb2dda7141ca3bd8c6f2eb9","modified":1715669101199},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"761760031e49edb77277bd4a8582774959240d6b","modified":1715669101209},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"1cb58aa6b88f7461c3c3f9605273686adcc30979","modified":1715669101209},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3283bdd6e5ac7d10376df8ddd5faaec5dc1bd667","modified":1715669101209},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"4dbe9652ae53a181c86eb7e9005a5255f0540055","modified":1715669101209},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"c22cbccd7d514947e084eeac6a3af1aa41ec857a","modified":1715669101209},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"96e58efba0dc76af409cc7d2db225f0fe4526ea8","modified":1715669101209},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"bb8ebb541c40362c0cbbd8e83d3b777302bb6c40","modified":1715669101209},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"df360f546d59b1fee8926806268754433dfa5de7","modified":1715669101209},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"a50718c081685fd35ff8ea9ca13682c284399ed8","modified":1715669101209},{"_id":"themes/next/scripts/events/lib/config.js","hash":"7c29184a37222d6499c5220264fda6942afc03a9","modified":1715669101199},{"_id":"themes/next/scripts/events/lib/navigation.js","hash":"0a2df7d40d64c61ce7e730bb8269b848b03526d1","modified":1715669101209},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"1f1ea7b579a49f17574c31d78d663c54896133eb","modified":1715669101209},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"af3e7066a7a8d87448aadde3bc9c848077aae418","modified":1715669101209},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"da22c6008fc8d214ba8561b412233380a06c40f9","modified":1715669101209},{"_id":"themes/next/source/js/third-party/addtoany.js","hash":"5cff12a5c9fc55a68f0f57a291494cd738301ba4","modified":1715669101289},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"54c52744898eb5d2073b83f98bb1a61759da92dc","modified":1715669101279},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"9cd228d5de7c2e49a231be072c9ef13af2dd95ff","modified":1715669101279},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"c4537fa2de33d98baff2c87a73801770414e0b69","modified":1715669101279},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c42a1685b29650e0ab078a496b2bfe0a4483f922","modified":1715669101279},{"_id":"themes/next/source/css/_variables/base.styl","hash":"a8fb90f7a2973bf133c2bff50579c322d1fbd790","modified":1715669101279},{"_id":"themes/next/source/js/third-party/fancybox.js","hash":"e3022c2ea60409a82a3e2a0d3615e4a25c684551","modified":1715669101299},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"f882924c7b99afc23106e39164516888b2972c7b","modified":1715669101229},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"5b0197e061f57e00875be3636ba372a67693abe0","modified":1715669101299},{"_id":"themes/next/source/js/third-party/pace.js","hash":"0ebee77b2307bf4b260afb06c060171ef42b7141","modified":1715669101299},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"f3defd56be33dba4866a695396d96c767ce63182","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"49c3063b46d65796003a822deed971abee41675e","modified":1715669101229},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"f768ecb2fe3e9384777c1c115cd7409e9155edd7","modified":1715669101249},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e728caca94567b4d4215402d01e449e23969e7e1","modified":1715669101269},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"7782dfae7a0f8cd61b936fa8ac980440a7bbd3bb","modified":1715669101249},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"cf8446f4378dcab27b55ede1635c608ae6b8a5c8","modified":1715669101249},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"1239f1b432a6932b2bb9ebcfbaabf724b8f4e59a","modified":1715669101249},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"db9e807cc8531ee0052f7cdf6a4cb92a8add3fd2","modified":1715669101249},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"b9388016f8d9274703e77e306a1feaad1b7b9d6c","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"b9322d644b2090d793521555646673322f2dd5e8","modified":1715669101259},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"2db5ada757f7ffb9a36b06400cf30d80ec039b6e","modified":1715669101269},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"0bf248d61593fbcdfd83b018b92199f4da3699b1","modified":1715669101269},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"be9d0e9493802c22f16a0645a59d0c2b556c1c3c","modified":1715669101269},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"fd4a2d2303f107a021837aa6e3d977c2f9d14c42","modified":1715669101259},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"89bf3f6b82cb0fafbbd483431df8f450857c5a0b","modified":1715669101269},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"2f19fe2aba8f63fc99641e50bcb96cc9a4feb8a4","modified":1715669101269},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"68f8d30071516913a7a958e01d010e8a93f7aa24","modified":1715669101269},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"e6e8892fccb02bff163d9b574984e0440a00d756","modified":1715669101269},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"36438f7b47d7ebd250a25f97c743fda484283046","modified":1715669101269},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2fb4b3f88e34a8544436a05634690217f9483419","modified":1715669101269},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1715669101269},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1715669101269},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"daabc99dff5f0fa3d02e2f9d669f528544823160","modified":1715669101279},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"b26770e09de9b51c851bb90fae19b27860e7fc9f","modified":1715669101269},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"7905f428b46d100ac5928875cb1e2b99fa86fc0b","modified":1715669101279},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"3ab87229f9a8357446f77f05a0c6854fb5363fd5","modified":1715669101269},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"84567000b5f4ac8a5c035fe982f4e3510d8a74b2","modified":1715669101279},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"72e0766752b78a723fb30e92d533a8b353104e2d","modified":1715669101289},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f9579a02599de063ccff336177ba964a2931a6e9","modified":1715669101289},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5c3dd08c520a16ee49f85fa12b4935e725ef261","modified":1715669101279},{"_id":"themes/next/source/js/third-party/chat/tidio.js","hash":"77c231bcd64f1c09bd9989909e9fee703b65f47f","modified":1715669101289},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"f755e8537ccbbb0bd84c26923f320d4e206e7428","modified":1715669101289},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"b4cb06fdf531292e2361398a98d75a4ca2b8473a","modified":1715669101289},{"_id":"themes/next/source/js/third-party/analytics/matomo.js","hash":"f24604710002234f18a7b5cfe9ccdf3ed6e725a8","modified":1715669101289},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"1e8509356fb027d948d118ab220d9631f4d482fa","modified":1715669101299},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"27a27de3d4e0d33e9c647f7ae78e1dd6d36d2463","modified":1715669101289},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"5c63ec71458b4fe0cd98fd4a04e11c3746764f11","modified":1715669101299},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"b9b9fd2f0e098a123b34a4932da912a9485ffe6c","modified":1715669101299},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"07e0038b221b9a4fd8ccac75093de3dee1f8315e","modified":1715669101289},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"68892d74ef5fc308c6e7e6b4f190826d79f3055d","modified":1715669101299},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"ec44d7f1c8b51b0aa3cccba099a78f3575ac828c","modified":1715669101299},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"5673d28509a8e837a512da490a88b7bf5162fc49","modified":1715669101289},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"d93556184b2c0aa1dbc4a6fb892d2f77b80d7d9f","modified":1715669101299},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"ce12b5007c9aa997738641c06a1c081c357e27bd","modified":1715669101299},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"696bdf9afc54246c26b8f8d87fc0746ec49b2ba5","modified":1715669101299},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"f57bcb69a6a306adf7af416f23c270007f872064","modified":1715669101299},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"e109c2d6828f527f0289d5fa3bb02fce63ee6d93","modified":1715669101299},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fde10ce94e9ae21a03b60d41d532835b54abdcb1","modified":1715669101229},{"_id":"themes/next/source/js/third-party/tags/wavedrom.js","hash":"9cafc8f751581d496f1f3c056b95f3b8e1ebbf4e","modified":1715669101299},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"f9fe39bef5fb2565abbffcb26390868c13d18359","modified":1715669101229},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"7db3233f0b33870943ce1547326a67f9e628b411","modified":1715669101299},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"6ce7a068192a7ca3487eb40645f2fdebc04ce89e","modified":1715669101299},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1715669101229},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"56d719bcdcba3d725141c55bbd4b168f3942f912","modified":1715669101229},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"6d8827b14ea1af16bfa21e194006ba9fa10ce50b","modified":1715669101229},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"aa04527f76de7646573ea327d4f6145200d6070d","modified":1715669101229},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"c524d5990a8e7ed9caf17978cf372bb0646f7b9f","modified":1715669101229},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"091b8c763e43447d087c122a86538f290f83136a","modified":1715669101229},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"c34936a17c3d8af6c0988ac6746d7509dc0b50eb","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"7245d8364092c2d184e658e801ba94815a2a1f81","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"4790d37a40b80f7278ec55274f017dad21791038","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"69dff7cf231d01f85671758455726dd666664a73","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"d514d09525256d510c83829aa6895bb40678d576","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/third-party/disqusjs.styl","hash":"a2ffaa06c963514a79fda52665e707af6e8e2f5e","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"0a698c3adba896a46e26850967cb73295c521940","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"406c03be3cf8a8411227bc1fecf942ca368f7e2a","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"8a7b70ef14c7110aaceb30ea2f7eb4b202f0f0cd","modified":1715669101239},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"c8648c8ea3105556be0068d9fb2735261d0d94bc","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"6ad0da4a5585508abbe78342a680607face98e19","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"1e5776ad4c5c8bcf7596ac74dcabc30704b3f5a0","modified":1715669101239},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"05af22f3edc2383a3d97ec4c05e9ac43b014bead","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"d28856f365a9373c4ae6fe1e5673d63df2dfd65f","modified":1715669101239},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"8525ba52332fc3c276ec03de7bf290e4dec54558","modified":1715669101239},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"038625515ba4760e4dda6792549bddc0db5a3d20","modified":1715669101239},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"39066b4e2e914d85736c9c33fa51f21a3f86c0e4","modified":1715669101239},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"137c9a41ed0f2c92f0913732090ae154cf596f74","modified":1715669101249},{"_id":"themes/next/source/css/_common/outline/sidebar/related-posts.styl","hash":"b3689beb90cda64cafecaf6b25981fe8a9525992","modified":1715669101249},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"d9bc2b520636b9df7f946295cd430593df4118ff","modified":1715669101249},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"f4de9eb94bebdf7790522e103de51205a64cae9e","modified":1715669101239},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"63fb6d36d9ea62c7e39274c666e102b12f64ff77","modified":1715669101249},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"dce8ea62d7d7b08a0444fbb2f617be30bfcfc152","modified":1715669101249},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"d8a028f532d562e6a86bb3b9c7b992e4b6dbbb51","modified":1715669101249},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"f8a97aad14e0b16b555ee0048da5402f818f9693","modified":1715669101249},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"f5c1a6afcd2d460ccd5987ef1af747fc99d3ea72","modified":1715669101249},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"794eabec62d6070255fa10516487cff70e0030bf","modified":1715669101249},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2de038def2cb91da143b14696366c14a66e0e569","modified":1715669101249},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"98a233884b1953952b8364895617fe53def60038","modified":1715669101259},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"8f82d5141a18f6319e0609a3f6e4fcca6d442203","modified":1715669101249},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"cbc6b0938a2e60f35a5df32210904fb16e4938da","modified":1715669101249},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"6b3680e0dbea8e14c1cec24ef63b7fae5e37f7ef","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"1772ade171aa6bd806909d69003cfc498c3af019","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"8d9218980e185210ce034e9769ab639b9630fd88","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/highlight/fold.styl","hash":"41c0516f76513036e30a70509a6d33e8a79bdba2","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"531daf2612c6217950677a2d03924459ce57c291","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"c7754dc6c866928b538f0863a05b96ec44b5e986","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"333f48b1107c63e992fdbe1290eeb2a7cc1d7a0c","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"3324e9d09faf3903bc9815358bda4000bbb691fa","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7075dd32dd70da1e161e4bd14b46f1e8be62fa3c","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"77122986509a6b4968bae2729417b7016137534c","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/tags/wavedrom.styl","hash":"2f4c791b5999b2e1a707bd473c1db7c21d206a27","modified":1715669101259},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"ed76879122ad1b62d210522de4037808644a590d","modified":1715669101259},{"_id":"source/_posts/jvm/image-20231117160926362.png","hash":"ca2a068264f66effa943f77e692caad25c59dde0","modified":1725957326960}],"Category":[{"name":"后端开发","_id":"cm2vyo6bh0004skushbwx17zg"},{"name":"计算机基础","_id":"cm2vyo6bl000askusel27eoii"},{"name":"算法","_id":"cm2vyo6bw001jskus0i18h5lv"}],"Data":[],"Page":[{"title":"Categories","date":"2024-04-16T06:02:47.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: Categories\ndate: 2024-04-16 14:02:47\ntype: \"categories\"\n---\n","updated":"2024-05-14T12:11:42.191Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cm2vyo6bb0000skusfw4ogric","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"Tags","date":"2024-04-16T06:02:37.000Z","type":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: Tags\ndate: 2024-04-16 14:02:37\ntype: \"tags\"\n---\n\n","updated":"2024-05-14T12:13:16.357Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cm2vyo6bf0002skusdrzy29dk","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"About","date":"2024-04-16T06:02:23.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: About\ndate: 2024-04-16 14:02:23\n---\n","updated":"2024-05-14T12:11:57.905Z","path":"about/index.html","comments":1,"layout":"page","_id":"cm2vyo6bi0006skusaym8407v","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"java两锁之一的ReetrantLock","date":"2024-05-13T12:03:35.000Z","_content":"\n# 1. UnSafe\n\nUnSafe是实现的基础\n","source":"_drafts/java两锁之一的ReetrantLock.md","raw":"---\ntitle: java两锁之一的ReetrantLock\ndate: 2024-05-13 20:03:35\ntags:\n    - JUC\ncategories:\n    - 后端开发\n---\n\n# 1. UnSafe\n\nUnSafe是实现的基础\n","slug":"java两锁之一的ReetrantLock","published":0,"updated":"2024-09-10T08:44:37.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6bc0001skus6dl9acmp","content":"<h1 id=\"1-UnSafe\"><a href=\"#1-UnSafe\" class=\"headerlink\" title=\"1. UnSafe\"></a>1. UnSafe</h1><p>UnSafe是实现的基础</p>\n","site":{"data":{}},"length":9,"excerpt":"","more":"<h1 id=\"1-UnSafe\"><a href=\"#1-UnSafe\" class=\"headerlink\" title=\"1. UnSafe\"></a>1. UnSafe</h1><p>UnSafe是实现的基础</p>\n"},{"title":"什么是HTTPS?","date":"2024-04-22T13:22:13.000Z","_content":"\n# 1. HTTPS概述\n\nHTTPS相较于HTTP多了一个安全层，也就是`HTTPS ≈ HTTP + SSL/TLS`。\n\nSSL（Secure Sockets Layer）安全套接层，TSL（Transport Secure Layer）传输层安全协议，可以看做SSL的高版本。\n\n## 1.1 HTTPS要干的事\n\nHTTPS要实现的功能主要有三个（先整体看一下，下面具体说）\n\n1. **机密性**：防止被别人截取到重要信息。使用混合加密\n\n2. **报文完整性**：防止通信信息被恶意篡改。使用hash算法，信息是`m`传输`m+H(m)`\n3. **端点鉴别**：校验客户端和服务端的身份（防止中间人攻击）。使用CA证书\n\n# 2. 机密性\n\n加密主要有两大类，分别是**对称加密**和**非对称加密**\n\n**场景**：Alice和Bob要进行通信，以及旁观的Trudy\n\n## 2.1 对称加密\n\n**Alice**向**Bob**说`bob,i love you.alice`，由于说的是明文，在一旁的**Trudy**也可以听到。\n\n**Alice**和**Bob**也发现了这一点，于是他们就想出了一个简单的办法，将要传达的信息通过一下**规则R**转变后再发送\n\n**规则R**：\n\n```\n明文字母: a b c d e f g h i j k l m n o p q r s t u v w x y z\n密文字母: m n b v c x z a s d f g h j k l p o i u y t r e w q\n```\n\n这样`bob,i love you.alice`就变成了`nkn, s gktc wky.mgsbc`。**Bob**在接收到信息后再根据**规则R**解密，获得真正的信息。\n\n这样**Trudy**就会听的一脸懵，你们在说啥？不过聪明的`Trudy`每天听他们交流，统计了所有词的出现频率，根据他们平时交流用的词汇数量（比如**bob**和**nkn**出现次数差不多，就推测`b=n,o=k`）推出了他们交流使用的**规则R**，这样他们交流的内容就被**Trudy**破解了(不过这种暴力破解方式遇到比较复杂的加密方式就很难破解了)。\n\n另外，**Trudy**还有可能偷听到**Alice**与**Bob**协商的规则R，这样Trudy甚至不需要时间推算就可以获取加密信息。\n\n## 2.2 非对称加密\n\n不久后，Alice和Bob也知道了这一方法的不妥，他们殚精竭虑又想出了一个新的办法，非对称加密（以RSA算法为例）。\n\n(RSA算法是基于数学模运算实现的，本质是两种运算算力的不对等，感兴趣的自行查阅)\n\nBob持有RSA算法的私钥，然后Bob将公钥告诉Alice。之后Alice就可以用公钥将信息加密然后发送给Bob，Bob将得到的信息用自己的私钥解密就可以得出真正的信息。\n\n**问题**：\n\n1. 这种Trudy可能不知道Alice向Bob说了什么但是还是可以篡改Alice向Bob发送的信息，这样Bob也不知道Alice在说啥了。\n\n2. Trudy也可以知道Bob告诉Alice的公钥，然后假装自己是Alice向Bob发送`bob,i hate you.alice`，Bob就有可能误会Alice。\n\n# 3. 报文完整性\n\n为了防止Trudy篡改消息，Alice将要发出的消息，用进行以下处理：\n\n原消息为**message**，处理后的消息为**message + hashCode(message)**，将`hashCode(message)`作为校验码，由于两个大片内容的散列函数值几乎不可能相同，所以Bob只需要将**message的hashcode值**与**校验码**进行比较就可以确定信息是否被篡改过。\n\n但是问题又来了？万一校验码也一起被替换了怎么办？\n\n于是Alice和Bob又商量了一个新的加密方式。假设要发送的消息为`m`，两人协商一个**鉴别密钥s**，将校验码变为`h(m+s)`，信息还是`m`，这样Bob收到后，就可以将**信息`m`加上密钥`s`拼接**在一起计算**hashCode**与**校验码**比较。\n\n问题又又又来了，Alice和Bob怎么保证**鉴别密钥s**只有他们两个知道呢？\n\n可以明显发现，Alice与Bob沟通依赖出现了死循环，内部消化不了，只能通过外部助力，这样CA就应运而生\n\n# 4. 端点鉴别\n\n为了防止Trudy假装成Alice，Bob需要鉴别谁是真正的Alice。\n\nHTTPS中使用将公钥和信息发送方（Alice）绑定的方式来保证数据一定是由Alice发送的，具体是通过认证中心（Certification Authority，CA）来完成的。\n\n**CA认证过程**：Alice和Bob通信时，Alice需要获得Bob的公钥。现在不直接将Bob的公钥发给Alice，而是先通过一个第三方的机构（CA）来将Bob公钥加上一些信息生成为一个证书，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_drafts/什么是HTTPS.md","raw":"---\ntitle: 什么是HTTPS?\ndate: 2024-04-22 21:22:13\ncategories: 计算机基础\ntags: 计算机网络\n---\n\n# 1. HTTPS概述\n\nHTTPS相较于HTTP多了一个安全层，也就是`HTTPS ≈ HTTP + SSL/TLS`。\n\nSSL（Secure Sockets Layer）安全套接层，TSL（Transport Secure Layer）传输层安全协议，可以看做SSL的高版本。\n\n## 1.1 HTTPS要干的事\n\nHTTPS要实现的功能主要有三个（先整体看一下，下面具体说）\n\n1. **机密性**：防止被别人截取到重要信息。使用混合加密\n\n2. **报文完整性**：防止通信信息被恶意篡改。使用hash算法，信息是`m`传输`m+H(m)`\n3. **端点鉴别**：校验客户端和服务端的身份（防止中间人攻击）。使用CA证书\n\n# 2. 机密性\n\n加密主要有两大类，分别是**对称加密**和**非对称加密**\n\n**场景**：Alice和Bob要进行通信，以及旁观的Trudy\n\n## 2.1 对称加密\n\n**Alice**向**Bob**说`bob,i love you.alice`，由于说的是明文，在一旁的**Trudy**也可以听到。\n\n**Alice**和**Bob**也发现了这一点，于是他们就想出了一个简单的办法，将要传达的信息通过一下**规则R**转变后再发送\n\n**规则R**：\n\n```\n明文字母: a b c d e f g h i j k l m n o p q r s t u v w x y z\n密文字母: m n b v c x z a s d f g h j k l p o i u y t r e w q\n```\n\n这样`bob,i love you.alice`就变成了`nkn, s gktc wky.mgsbc`。**Bob**在接收到信息后再根据**规则R**解密，获得真正的信息。\n\n这样**Trudy**就会听的一脸懵，你们在说啥？不过聪明的`Trudy`每天听他们交流，统计了所有词的出现频率，根据他们平时交流用的词汇数量（比如**bob**和**nkn**出现次数差不多，就推测`b=n,o=k`）推出了他们交流使用的**规则R**，这样他们交流的内容就被**Trudy**破解了(不过这种暴力破解方式遇到比较复杂的加密方式就很难破解了)。\n\n另外，**Trudy**还有可能偷听到**Alice**与**Bob**协商的规则R，这样Trudy甚至不需要时间推算就可以获取加密信息。\n\n## 2.2 非对称加密\n\n不久后，Alice和Bob也知道了这一方法的不妥，他们殚精竭虑又想出了一个新的办法，非对称加密（以RSA算法为例）。\n\n(RSA算法是基于数学模运算实现的，本质是两种运算算力的不对等，感兴趣的自行查阅)\n\nBob持有RSA算法的私钥，然后Bob将公钥告诉Alice。之后Alice就可以用公钥将信息加密然后发送给Bob，Bob将得到的信息用自己的私钥解密就可以得出真正的信息。\n\n**问题**：\n\n1. 这种Trudy可能不知道Alice向Bob说了什么但是还是可以篡改Alice向Bob发送的信息，这样Bob也不知道Alice在说啥了。\n\n2. Trudy也可以知道Bob告诉Alice的公钥，然后假装自己是Alice向Bob发送`bob,i hate you.alice`，Bob就有可能误会Alice。\n\n# 3. 报文完整性\n\n为了防止Trudy篡改消息，Alice将要发出的消息，用进行以下处理：\n\n原消息为**message**，处理后的消息为**message + hashCode(message)**，将`hashCode(message)`作为校验码，由于两个大片内容的散列函数值几乎不可能相同，所以Bob只需要将**message的hashcode值**与**校验码**进行比较就可以确定信息是否被篡改过。\n\n但是问题又来了？万一校验码也一起被替换了怎么办？\n\n于是Alice和Bob又商量了一个新的加密方式。假设要发送的消息为`m`，两人协商一个**鉴别密钥s**，将校验码变为`h(m+s)`，信息还是`m`，这样Bob收到后，就可以将**信息`m`加上密钥`s`拼接**在一起计算**hashCode**与**校验码**比较。\n\n问题又又又来了，Alice和Bob怎么保证**鉴别密钥s**只有他们两个知道呢？\n\n可以明显发现，Alice与Bob沟通依赖出现了死循环，内部消化不了，只能通过外部助力，这样CA就应运而生\n\n# 4. 端点鉴别\n\n为了防止Trudy假装成Alice，Bob需要鉴别谁是真正的Alice。\n\nHTTPS中使用将公钥和信息发送方（Alice）绑定的方式来保证数据一定是由Alice发送的，具体是通过认证中心（Certification Authority，CA）来完成的。\n\n**CA认证过程**：Alice和Bob通信时，Alice需要获得Bob的公钥。现在不直接将Bob的公钥发给Alice，而是先通过一个第三方的机构（CA）来将Bob公钥加上一些信息生成为一个证书，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"什么是HTTPS","published":0,"updated":"2024-09-03T08:38:29.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6bg0003skus6nt9fcxq","content":"<h1 id=\"1-HTTPS概述\"><a href=\"#1-HTTPS概述\" class=\"headerlink\" title=\"1. HTTPS概述\"></a>1. HTTPS概述</h1><p>HTTPS相较于HTTP多了一个安全层，也就是<code>HTTPS ≈ HTTP + SSL/TLS</code>。</p>\n<p>SSL（Secure Sockets Layer）安全套接层，TSL（Transport Secure Layer）传输层安全协议，可以看做SSL的高版本。</p>\n<h2 id=\"1-1-HTTPS要干的事\"><a href=\"#1-1-HTTPS要干的事\" class=\"headerlink\" title=\"1.1 HTTPS要干的事\"></a>1.1 HTTPS要干的事</h2><p>HTTPS要实现的功能主要有三个（先整体看一下，下面具体说）</p>\n<ol>\n<li><p><strong>机密性</strong>：防止被别人截取到重要信息。使用混合加密</p>\n</li>\n<li><p><strong>报文完整性</strong>：防止通信信息被恶意篡改。使用hash算法，信息是<code>m</code>传输<code>m+H(m)</code></p>\n</li>\n<li><p><strong>端点鉴别</strong>：校验客户端和服务端的身份（防止中间人攻击）。使用CA证书</p>\n</li>\n</ol>\n<h1 id=\"2-机密性\"><a href=\"#2-机密性\" class=\"headerlink\" title=\"2. 机密性\"></a>2. 机密性</h1><p>加密主要有两大类，分别是<strong>对称加密</strong>和<strong>非对称加密</strong></p>\n<p><strong>场景</strong>：Alice和Bob要进行通信，以及旁观的Trudy</p>\n<h2 id=\"2-1-对称加密\"><a href=\"#2-1-对称加密\" class=\"headerlink\" title=\"2.1 对称加密\"></a>2.1 对称加密</h2><p><strong>Alice</strong>向<strong>Bob</strong>说<code>bob,i love you.alice</code>，由于说的是明文，在一旁的<strong>Trudy</strong>也可以听到。</p>\n<p><strong>Alice</strong>和<strong>Bob</strong>也发现了这一点，于是他们就想出了一个简单的办法，将要传达的信息通过一下<strong>规则R</strong>转变后再发送</p>\n<p><strong>规则R</strong>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">明文字母: <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> <span class=\"selector-tag\">c</span> <span class=\"selector-tag\">d</span> <span class=\"selector-tag\">e</span> <span class=\"selector-tag\">f</span> <span class=\"selector-tag\">g</span> <span class=\"selector-tag\">h</span> <span class=\"selector-tag\">i</span> <span class=\"selector-tag\">j</span> <span class=\"selector-tag\">k</span> <span class=\"selector-tag\">l</span> <span class=\"selector-tag\">m</span> <span class=\"selector-tag\">n</span> <span class=\"selector-tag\">o</span> <span class=\"selector-tag\">p</span> <span class=\"selector-tag\">q</span> <span class=\"selector-tag\">r</span> <span class=\"selector-tag\">s</span> <span class=\"selector-tag\">t</span> <span class=\"selector-tag\">u</span> <span class=\"selector-tag\">v</span> <span class=\"selector-tag\">w</span> <span class=\"selector-tag\">x</span> <span class=\"selector-tag\">y</span> <span class=\"selector-tag\">z</span></span><br><span class=\"line\">密文字母: <span class=\"selector-tag\">m</span> <span class=\"selector-tag\">n</span> <span class=\"selector-tag\">b</span> <span class=\"selector-tag\">v</span> <span class=\"selector-tag\">c</span> <span class=\"selector-tag\">x</span> <span class=\"selector-tag\">z</span> <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">s</span> <span class=\"selector-tag\">d</span> <span class=\"selector-tag\">f</span> <span class=\"selector-tag\">g</span> <span class=\"selector-tag\">h</span> <span class=\"selector-tag\">j</span> <span class=\"selector-tag\">k</span> <span class=\"selector-tag\">l</span> <span class=\"selector-tag\">p</span> <span class=\"selector-tag\">o</span> <span class=\"selector-tag\">i</span> <span class=\"selector-tag\">u</span> <span class=\"selector-tag\">y</span> <span class=\"selector-tag\">t</span> <span class=\"selector-tag\">r</span> <span class=\"selector-tag\">e</span> <span class=\"selector-tag\">w</span> <span class=\"selector-tag\">q</span></span><br></pre></td></tr></table></figure>\n\n<p>这样<code>bob,i love you.alice</code>就变成了<code>nkn, s gktc wky.mgsbc</code>。<strong>Bob</strong>在接收到信息后再根据<strong>规则R</strong>解密，获得真正的信息。</p>\n<p>这样<strong>Trudy</strong>就会听的一脸懵，你们在说啥？不过聪明的<code>Trudy</code>每天听他们交流，统计了所有词的出现频率，根据他们平时交流用的词汇数量（比如<strong>bob</strong>和<strong>nkn</strong>出现次数差不多，就推测<code>b=n,o=k</code>）推出了他们交流使用的<strong>规则R</strong>，这样他们交流的内容就被<strong>Trudy</strong>破解了(不过这种暴力破解方式遇到比较复杂的加密方式就很难破解了)。</p>\n<p>另外，<strong>Trudy</strong>还有可能偷听到<strong>Alice</strong>与<strong>Bob</strong>协商的规则R，这样Trudy甚至不需要时间推算就可以获取加密信息。</p>\n<h2 id=\"2-2-非对称加密\"><a href=\"#2-2-非对称加密\" class=\"headerlink\" title=\"2.2 非对称加密\"></a>2.2 非对称加密</h2><p>不久后，Alice和Bob也知道了这一方法的不妥，他们殚精竭虑又想出了一个新的办法，非对称加密（以RSA算法为例）。</p>\n<p>(RSA算法是基于数学模运算实现的，本质是两种运算算力的不对等，感兴趣的自行查阅)</p>\n<p>Bob持有RSA算法的私钥，然后Bob将公钥告诉Alice。之后Alice就可以用公钥将信息加密然后发送给Bob，Bob将得到的信息用自己的私钥解密就可以得出真正的信息。</p>\n<p><strong>问题</strong>：</p>\n<ol>\n<li><p>这种Trudy可能不知道Alice向Bob说了什么但是还是可以篡改Alice向Bob发送的信息，这样Bob也不知道Alice在说啥了。</p>\n</li>\n<li><p>Trudy也可以知道Bob告诉Alice的公钥，然后假装自己是Alice向Bob发送<code>bob,i hate you.alice</code>，Bob就有可能误会Alice。</p>\n</li>\n</ol>\n<h1 id=\"3-报文完整性\"><a href=\"#3-报文完整性\" class=\"headerlink\" title=\"3. 报文完整性\"></a>3. 报文完整性</h1><p>为了防止Trudy篡改消息，Alice将要发出的消息，用进行以下处理：</p>\n<p>原消息为<strong>message</strong>，处理后的消息为<strong>message + hashCode(message)<strong>，将<code>hashCode(message)</code>作为校验码，由于两个大片内容的散列函数值几乎不可能相同，所以Bob只需要将</strong>message的hashcode值</strong>与<strong>校验码</strong>进行比较就可以确定信息是否被篡改过。</p>\n<p>但是问题又来了？万一校验码也一起被替换了怎么办？</p>\n<p>于是Alice和Bob又商量了一个新的加密方式。假设要发送的消息为<code>m</code>，两人协商一个<strong>鉴别密钥s</strong>，将校验码变为<code>h(m+s)</code>，信息还是<code>m</code>，这样Bob收到后，就可以将<strong>信息<code>m</code>加上密钥<code>s</code>拼接</strong>在一起计算<strong>hashCode</strong>与<strong>校验码</strong>比较。</p>\n<p>问题又又又来了，Alice和Bob怎么保证<strong>鉴别密钥s</strong>只有他们两个知道呢？</p>\n<p>可以明显发现，Alice与Bob沟通依赖出现了死循环，内部消化不了，只能通过外部助力，这样CA就应运而生</p>\n<h1 id=\"4-端点鉴别\"><a href=\"#4-端点鉴别\" class=\"headerlink\" title=\"4. 端点鉴别\"></a>4. 端点鉴别</h1><p>为了防止Trudy假装成Alice，Bob需要鉴别谁是真正的Alice。</p>\n<p>HTTPS中使用将公钥和信息发送方（Alice）绑定的方式来保证数据一定是由Alice发送的，具体是通过认证中心（Certification Authority，CA）来完成的。</p>\n<p><strong>CA认证过程</strong>：Alice和Bob通信时，Alice需要获得Bob的公钥。现在不直接将Bob的公钥发给Alice，而是先通过一个第三方的机构（CA）来将Bob公钥加上一些信息生成为一个证书，</p>\n","site":{"data":{}},"length":1197,"excerpt":"","more":"<h1 id=\"1-HTTPS概述\"><a href=\"#1-HTTPS概述\" class=\"headerlink\" title=\"1. HTTPS概述\"></a>1. HTTPS概述</h1><p>HTTPS相较于HTTP多了一个安全层，也就是<code>HTTPS ≈ HTTP + SSL/TLS</code>。</p>\n<p>SSL（Secure Sockets Layer）安全套接层，TSL（Transport Secure Layer）传输层安全协议，可以看做SSL的高版本。</p>\n<h2 id=\"1-1-HTTPS要干的事\"><a href=\"#1-1-HTTPS要干的事\" class=\"headerlink\" title=\"1.1 HTTPS要干的事\"></a>1.1 HTTPS要干的事</h2><p>HTTPS要实现的功能主要有三个（先整体看一下，下面具体说）</p>\n<ol>\n<li><p><strong>机密性</strong>：防止被别人截取到重要信息。使用混合加密</p>\n</li>\n<li><p><strong>报文完整性</strong>：防止通信信息被恶意篡改。使用hash算法，信息是<code>m</code>传输<code>m+H(m)</code></p>\n</li>\n<li><p><strong>端点鉴别</strong>：校验客户端和服务端的身份（防止中间人攻击）。使用CA证书</p>\n</li>\n</ol>\n<h1 id=\"2-机密性\"><a href=\"#2-机密性\" class=\"headerlink\" title=\"2. 机密性\"></a>2. 机密性</h1><p>加密主要有两大类，分别是<strong>对称加密</strong>和<strong>非对称加密</strong></p>\n<p><strong>场景</strong>：Alice和Bob要进行通信，以及旁观的Trudy</p>\n<h2 id=\"2-1-对称加密\"><a href=\"#2-1-对称加密\" class=\"headerlink\" title=\"2.1 对称加密\"></a>2.1 对称加密</h2><p><strong>Alice</strong>向<strong>Bob</strong>说<code>bob,i love you.alice</code>，由于说的是明文，在一旁的<strong>Trudy</strong>也可以听到。</p>\n<p><strong>Alice</strong>和<strong>Bob</strong>也发现了这一点，于是他们就想出了一个简单的办法，将要传达的信息通过一下<strong>规则R</strong>转变后再发送</p>\n<p><strong>规则R</strong>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">明文字母: <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">b</span> <span class=\"selector-tag\">c</span> <span class=\"selector-tag\">d</span> <span class=\"selector-tag\">e</span> <span class=\"selector-tag\">f</span> <span class=\"selector-tag\">g</span> <span class=\"selector-tag\">h</span> <span class=\"selector-tag\">i</span> <span class=\"selector-tag\">j</span> <span class=\"selector-tag\">k</span> <span class=\"selector-tag\">l</span> <span class=\"selector-tag\">m</span> <span class=\"selector-tag\">n</span> <span class=\"selector-tag\">o</span> <span class=\"selector-tag\">p</span> <span class=\"selector-tag\">q</span> <span class=\"selector-tag\">r</span> <span class=\"selector-tag\">s</span> <span class=\"selector-tag\">t</span> <span class=\"selector-tag\">u</span> <span class=\"selector-tag\">v</span> <span class=\"selector-tag\">w</span> <span class=\"selector-tag\">x</span> <span class=\"selector-tag\">y</span> <span class=\"selector-tag\">z</span></span><br><span class=\"line\">密文字母: <span class=\"selector-tag\">m</span> <span class=\"selector-tag\">n</span> <span class=\"selector-tag\">b</span> <span class=\"selector-tag\">v</span> <span class=\"selector-tag\">c</span> <span class=\"selector-tag\">x</span> <span class=\"selector-tag\">z</span> <span class=\"selector-tag\">a</span> <span class=\"selector-tag\">s</span> <span class=\"selector-tag\">d</span> <span class=\"selector-tag\">f</span> <span class=\"selector-tag\">g</span> <span class=\"selector-tag\">h</span> <span class=\"selector-tag\">j</span> <span class=\"selector-tag\">k</span> <span class=\"selector-tag\">l</span> <span class=\"selector-tag\">p</span> <span class=\"selector-tag\">o</span> <span class=\"selector-tag\">i</span> <span class=\"selector-tag\">u</span> <span class=\"selector-tag\">y</span> <span class=\"selector-tag\">t</span> <span class=\"selector-tag\">r</span> <span class=\"selector-tag\">e</span> <span class=\"selector-tag\">w</span> <span class=\"selector-tag\">q</span></span><br></pre></td></tr></table></figure>\n\n<p>这样<code>bob,i love you.alice</code>就变成了<code>nkn, s gktc wky.mgsbc</code>。<strong>Bob</strong>在接收到信息后再根据<strong>规则R</strong>解密，获得真正的信息。</p>\n<p>这样<strong>Trudy</strong>就会听的一脸懵，你们在说啥？不过聪明的<code>Trudy</code>每天听他们交流，统计了所有词的出现频率，根据他们平时交流用的词汇数量（比如<strong>bob</strong>和<strong>nkn</strong>出现次数差不多，就推测<code>b=n,o=k</code>）推出了他们交流使用的<strong>规则R</strong>，这样他们交流的内容就被<strong>Trudy</strong>破解了(不过这种暴力破解方式遇到比较复杂的加密方式就很难破解了)。</p>\n<p>另外，<strong>Trudy</strong>还有可能偷听到<strong>Alice</strong>与<strong>Bob</strong>协商的规则R，这样Trudy甚至不需要时间推算就可以获取加密信息。</p>\n<h2 id=\"2-2-非对称加密\"><a href=\"#2-2-非对称加密\" class=\"headerlink\" title=\"2.2 非对称加密\"></a>2.2 非对称加密</h2><p>不久后，Alice和Bob也知道了这一方法的不妥，他们殚精竭虑又想出了一个新的办法，非对称加密（以RSA算法为例）。</p>\n<p>(RSA算法是基于数学模运算实现的，本质是两种运算算力的不对等，感兴趣的自行查阅)</p>\n<p>Bob持有RSA算法的私钥，然后Bob将公钥告诉Alice。之后Alice就可以用公钥将信息加密然后发送给Bob，Bob将得到的信息用自己的私钥解密就可以得出真正的信息。</p>\n<p><strong>问题</strong>：</p>\n<ol>\n<li><p>这种Trudy可能不知道Alice向Bob说了什么但是还是可以篡改Alice向Bob发送的信息，这样Bob也不知道Alice在说啥了。</p>\n</li>\n<li><p>Trudy也可以知道Bob告诉Alice的公钥，然后假装自己是Alice向Bob发送<code>bob,i hate you.alice</code>，Bob就有可能误会Alice。</p>\n</li>\n</ol>\n<h1 id=\"3-报文完整性\"><a href=\"#3-报文完整性\" class=\"headerlink\" title=\"3. 报文完整性\"></a>3. 报文完整性</h1><p>为了防止Trudy篡改消息，Alice将要发出的消息，用进行以下处理：</p>\n<p>原消息为<strong>message</strong>，处理后的消息为<strong>message + hashCode(message)<strong>，将<code>hashCode(message)</code>作为校验码，由于两个大片内容的散列函数值几乎不可能相同，所以Bob只需要将</strong>message的hashcode值</strong>与<strong>校验码</strong>进行比较就可以确定信息是否被篡改过。</p>\n<p>但是问题又来了？万一校验码也一起被替换了怎么办？</p>\n<p>于是Alice和Bob又商量了一个新的加密方式。假设要发送的消息为<code>m</code>，两人协商一个<strong>鉴别密钥s</strong>，将校验码变为<code>h(m+s)</code>，信息还是<code>m</code>，这样Bob收到后，就可以将<strong>信息<code>m</code>加上密钥<code>s</code>拼接</strong>在一起计算<strong>hashCode</strong>与<strong>校验码</strong>比较。</p>\n<p>问题又又又来了，Alice和Bob怎么保证<strong>鉴别密钥s</strong>只有他们两个知道呢？</p>\n<p>可以明显发现，Alice与Bob沟通依赖出现了死循环，内部消化不了，只能通过外部助力，这样CA就应运而生</p>\n<h1 id=\"4-端点鉴别\"><a href=\"#4-端点鉴别\" class=\"headerlink\" title=\"4. 端点鉴别\"></a>4. 端点鉴别</h1><p>为了防止Trudy假装成Alice，Bob需要鉴别谁是真正的Alice。</p>\n<p>HTTPS中使用将公钥和信息发送方（Alice）绑定的方式来保证数据一定是由Alice发送的，具体是通过认证中心（Certification Authority，CA）来完成的。</p>\n<p><strong>CA认证过程</strong>：Alice和Bob通信时，Alice需要获得Bob的公钥。现在不直接将Bob的公钥发给Alice，而是先通过一个第三方的机构（CA）来将Bob公钥加上一些信息生成为一个证书，</p>\n"},{"title":"AOP","date":"2024-09-30T12:35:09.000Z","_content":"\n# 1. AOP基础\n\n## 1.1 动态代理\n\n我们都知道java是面向对象语言，服务也被看做对象（比如后端开发中常见的Dao层数据查询对象，Service层的业务对象等）。正常服务间协作，一个对象如果需要使用另一个对象只需要维持一个引用关系就行了，但是这时就有可能出现某个对象被其他大部分对象引用的情况，以日志打印为例。每个业务对象使用都需要创建一个日志对象，并且将打印逻辑嵌在业务代码中（创建一个类组合两个功能也是类似的情况），这无疑增加了开发人员的工作量也增加了不同功能之间的耦合度，不利于后期维护。\n\n我们可以发现这种增加引用关系，增加代码的操作高度相似，那么能不能抽象出一个对象来专门负责这个功能呢？当然是可以的，java动态代理就是很好的实现之一。\n\n\n\n提前定义代理要使用的类和接口。\n\n```java\npublic interface UserService {\n    public void addUser(String name);\n}\n```\n\n```java\npublic class UserServiceImpl implements UserService{\n    @Override\n    public void addUser(String name) {\n        System.out.println(\"Adding user: \" + name);\n    }\n}\n```\n\n## 1.2 jdk动态代理\n\n```java\npublic class JDKProxyDemo {\n    private UserService target;\n\n    /**\n     * init.\n     *\n     * @param target target\n     */\n    public JDKProxyDemo(UserServiceImpl target) {\n        super();\n        this.target = target;\n    }\n\n    public UserService getLoggingProxy() {\n        UserService proxy;\n        ClassLoader loader = target.getClass().getClassLoader();\n        Class[] interfaces = new Class[]{UserService.class};\n        InvocationHandler h = new InvocationHandler() {\n            /**\n             * proxy: 代理对象。 一般不使用该对象 method: 正在被调用的方法 args: 调用方法传入的参数\n             */\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                String methodName = method.getName();\n                // log - before method\n                System.out.println(\"[before] execute method: \" + methodName);\n\n                // call method\n                Object result = null;\n                try {\n                    // 前置通知\n                    result = method.invoke(target, args);\n                    // 返回通知, 可以访问到方法的返回值\n                } catch (NullPointerException e) {\n                    e.printStackTrace();\n                    // 异常通知, 可以访问到方法出现的异常\n                }\n                // 后置通知. 因为方法可以能会出异常, 所以访问不到方法的返回值\n\n                // log - after method\n                System.out.println(\"[after] execute method: \" + methodName + \", return value: \" + result);\n                return result;\n            }\n        };\n        /**\n         * loader: 代理对象使用的类加载器.\n         * interfaces: 指定代理对象的类型. 即代理代理对象中可以有哪些方法.\n         * h: 当具体调用代理对象的方法时, 应该如何进行响应, 实际上就是调用 InvocationHandler 的 invoke 方法\n         */\n        proxy = (UserService) Proxy.newProxyInstance(loader, interfaces, h);\n        return proxy;\n    }\n\n    public static void main(String[] args) {\n        UserService userService = new JDKProxyDemo(new UserServiceImpl()).getLoggingProxy();\n        userService.addUser(\"name\");\n    }\n}\n```\n\n## 1.3 cglib动态代理\n\n```java\npublic class CglibProxyDemo implements MethodInterceptor {\n    private Object target;\n\n    public Object getUserLogProxy(Object target) {\n        //给业务对象赋值\n        this.target = target;\n        //创建加强器，用来创建动态代理类\n        Enhancer enhancer = new Enhancer();\n        //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）\n        enhancer.setSuperclass(this.target.getClass());\n        //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦\n        enhancer.setCallback(this);\n        // 创建动态代理类对象并返回\n        return enhancer.create();\n    }\n\n    // 实现回调方法\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        // log - before method\n        System.out.println(\"[before] execute method: \" + method.getName());\n\n        // call method\n        Object result = proxy.invokeSuper(obj, args);\n\n        // log - after method\n        System.out.println(\"[after] execute method: \" + method.getName() + \", return value: \" + result);\n        return null;\n    }\n\n    public static void main(String[] args) {\n        // proxy\n        UserService userService = (UserService) new CglibProxyDemo().getUserLogProxy(new UserServiceImpl());\n\n        // call methods\n        userService.addUser(\"test\");\n    }\n}\n```\n\n## 1.4 两代理区别\n\nJDK是基于接口和反射技术实现的动态代理，动态生成代理类调用接口方法，只能代理类中实现接口的方法。\n\nCGLIB是基于类继承和ASM字节码编程实现的动态代理，动态生成代理类调用被代理类的方法，限制比较小。\n","source":"_posts/AOP.md","raw":"---\ntitle: AOP\ndate: 2024-09-30 20:35:09\ntags: \n   - SpringBoot\ncategories:\n   - 后端开发\n---\n\n# 1. AOP基础\n\n## 1.1 动态代理\n\n我们都知道java是面向对象语言，服务也被看做对象（比如后端开发中常见的Dao层数据查询对象，Service层的业务对象等）。正常服务间协作，一个对象如果需要使用另一个对象只需要维持一个引用关系就行了，但是这时就有可能出现某个对象被其他大部分对象引用的情况，以日志打印为例。每个业务对象使用都需要创建一个日志对象，并且将打印逻辑嵌在业务代码中（创建一个类组合两个功能也是类似的情况），这无疑增加了开发人员的工作量也增加了不同功能之间的耦合度，不利于后期维护。\n\n我们可以发现这种增加引用关系，增加代码的操作高度相似，那么能不能抽象出一个对象来专门负责这个功能呢？当然是可以的，java动态代理就是很好的实现之一。\n\n\n\n提前定义代理要使用的类和接口。\n\n```java\npublic interface UserService {\n    public void addUser(String name);\n}\n```\n\n```java\npublic class UserServiceImpl implements UserService{\n    @Override\n    public void addUser(String name) {\n        System.out.println(\"Adding user: \" + name);\n    }\n}\n```\n\n## 1.2 jdk动态代理\n\n```java\npublic class JDKProxyDemo {\n    private UserService target;\n\n    /**\n     * init.\n     *\n     * @param target target\n     */\n    public JDKProxyDemo(UserServiceImpl target) {\n        super();\n        this.target = target;\n    }\n\n    public UserService getLoggingProxy() {\n        UserService proxy;\n        ClassLoader loader = target.getClass().getClassLoader();\n        Class[] interfaces = new Class[]{UserService.class};\n        InvocationHandler h = new InvocationHandler() {\n            /**\n             * proxy: 代理对象。 一般不使用该对象 method: 正在被调用的方法 args: 调用方法传入的参数\n             */\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                String methodName = method.getName();\n                // log - before method\n                System.out.println(\"[before] execute method: \" + methodName);\n\n                // call method\n                Object result = null;\n                try {\n                    // 前置通知\n                    result = method.invoke(target, args);\n                    // 返回通知, 可以访问到方法的返回值\n                } catch (NullPointerException e) {\n                    e.printStackTrace();\n                    // 异常通知, 可以访问到方法出现的异常\n                }\n                // 后置通知. 因为方法可以能会出异常, 所以访问不到方法的返回值\n\n                // log - after method\n                System.out.println(\"[after] execute method: \" + methodName + \", return value: \" + result);\n                return result;\n            }\n        };\n        /**\n         * loader: 代理对象使用的类加载器.\n         * interfaces: 指定代理对象的类型. 即代理代理对象中可以有哪些方法.\n         * h: 当具体调用代理对象的方法时, 应该如何进行响应, 实际上就是调用 InvocationHandler 的 invoke 方法\n         */\n        proxy = (UserService) Proxy.newProxyInstance(loader, interfaces, h);\n        return proxy;\n    }\n\n    public static void main(String[] args) {\n        UserService userService = new JDKProxyDemo(new UserServiceImpl()).getLoggingProxy();\n        userService.addUser(\"name\");\n    }\n}\n```\n\n## 1.3 cglib动态代理\n\n```java\npublic class CglibProxyDemo implements MethodInterceptor {\n    private Object target;\n\n    public Object getUserLogProxy(Object target) {\n        //给业务对象赋值\n        this.target = target;\n        //创建加强器，用来创建动态代理类\n        Enhancer enhancer = new Enhancer();\n        //为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）\n        enhancer.setSuperclass(this.target.getClass());\n        //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦\n        enhancer.setCallback(this);\n        // 创建动态代理类对象并返回\n        return enhancer.create();\n    }\n\n    // 实现回调方法\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        // log - before method\n        System.out.println(\"[before] execute method: \" + method.getName());\n\n        // call method\n        Object result = proxy.invokeSuper(obj, args);\n\n        // log - after method\n        System.out.println(\"[after] execute method: \" + method.getName() + \", return value: \" + result);\n        return null;\n    }\n\n    public static void main(String[] args) {\n        // proxy\n        UserService userService = (UserService) new CglibProxyDemo().getUserLogProxy(new UserServiceImpl());\n\n        // call methods\n        userService.addUser(\"test\");\n    }\n}\n```\n\n## 1.4 两代理区别\n\nJDK是基于接口和反射技术实现的动态代理，动态生成代理类调用接口方法，只能代理类中实现接口的方法。\n\nCGLIB是基于类继承和ASM字节码编程实现的动态代理，动态生成代理类调用被代理类的方法，限制比较小。\n","slug":"AOP","published":1,"updated":"2024-10-27T11:54:17.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6bj0007skusfo93bthh","content":"<h1 id=\"1-AOP基础\"><a href=\"#1-AOP基础\" class=\"headerlink\" title=\"1. AOP基础\"></a>1. AOP基础</h1><h2 id=\"1-1-动态代理\"><a href=\"#1-1-动态代理\" class=\"headerlink\" title=\"1.1 动态代理\"></a>1.1 动态代理</h2><p>我们都知道java是面向对象语言，服务也被看做对象（比如后端开发中常见的Dao层数据查询对象，Service层的业务对象等）。正常服务间协作，一个对象如果需要使用另一个对象只需要维持一个引用关系就行了，但是这时就有可能出现某个对象被其他大部分对象引用的情况，以日志打印为例。每个业务对象使用都需要创建一个日志对象，并且将打印逻辑嵌在业务代码中（创建一个类组合两个功能也是类似的情况），这无疑增加了开发人员的工作量也增加了不同功能之间的耦合度，不利于后期维护。</p>\n<p>我们可以发现这种增加引用关系，增加代码的操作高度相似，那么能不能抽象出一个对象来专门负责这个功能呢？当然是可以的，java动态代理就是很好的实现之一。</p>\n<p>提前定义代理要使用的类和接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addUser</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addUser</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Adding user: &quot;</span> + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-jdk动态代理\"><a href=\"#1-2-jdk动态代理\" class=\"headerlink\" title=\"1.2 jdk动态代理\"></a>1.2 jdk动态代理</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JDKProxyDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * init.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> target target</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">JDKProxyDemo</span><span class=\"params\">(UserServiceImpl target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> UserService <span class=\"title function_\">getLoggingProxy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        UserService proxy;</span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">loader</span> <span class=\"operator\">=</span> target.getClass().getClassLoader();</span><br><span class=\"line\">        Class[] interfaces = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;UserService.class&#125;;</span><br><span class=\"line\">        <span class=\"type\">InvocationHandler</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * proxy: 代理对象。 一般不使用该对象 method: 正在被调用的方法 args: 调用方法传入的参数</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> method.getName();</span><br><span class=\"line\">                <span class=\"comment\">// log - before method</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;[before] execute method: &quot;</span> + methodName);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// call method</span></span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 前置通知</span></span><br><span class=\"line\">                    result = method.invoke(target, args);</span><br><span class=\"line\">                    <span class=\"comment\">// 返回通知, 可以访问到方法的返回值</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (NullPointerException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    <span class=\"comment\">// 异常通知, 可以访问到方法出现的异常</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 后置通知. 因为方法可以能会出异常, 所以访问不到方法的返回值</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// log - after method</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;[after] execute method: &quot;</span> + methodName + <span class=\"string\">&quot;, return value: &quot;</span> + result);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * loader: 代理对象使用的类加载器.</span></span><br><span class=\"line\"><span class=\"comment\">         * interfaces: 指定代理对象的类型. 即代理代理对象中可以有哪些方法.</span></span><br><span class=\"line\"><span class=\"comment\">         * h: 当具体调用代理对象的方法时, 应该如何进行响应, 实际上就是调用 InvocationHandler 的 invoke 方法</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        proxy = (UserService) Proxy.newProxyInstance(loader, interfaces, h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JDKProxyDemo</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceImpl</span>()).getLoggingProxy();</span><br><span class=\"line\">        userService.addUser(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-cglib动态代理\"><a href=\"#1-3-cglib动态代理\" class=\"headerlink\" title=\"1.3 cglib动态代理\"></a>1.3 cglib动态代理</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CglibProxyDemo</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getUserLogProxy</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//给业务对象赋值</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">        <span class=\"comment\">//创建加强器，用来创建动态代理类</span></span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">        <span class=\"comment\">//为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）</span></span><br><span class=\"line\">        enhancer.setSuperclass(<span class=\"built_in\">this</span>.target.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦</span></span><br><span class=\"line\">        enhancer.setCallback(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建动态代理类对象并返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现回调方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">// log - before method</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[before] execute method: &quot;</span> + method.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// call method</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> proxy.invokeSuper(obj, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// log - after method</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[after] execute method: &quot;</span> + method.getName() + <span class=\"string\">&quot;, return value: &quot;</span> + result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// proxy</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> (UserService) <span class=\"keyword\">new</span> <span class=\"title class_\">CglibProxyDemo</span>().getUserLogProxy(<span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceImpl</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// call methods</span></span><br><span class=\"line\">        userService.addUser(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-两代理区别\"><a href=\"#1-4-两代理区别\" class=\"headerlink\" title=\"1.4 两代理区别\"></a>1.4 两代理区别</h2><p>JDK是基于接口和反射技术实现的动态代理，动态生成代理类调用接口方法，只能代理类中实现接口的方法。</p>\n<p>CGLIB是基于类继承和ASM字节码编程实现的动态代理，动态生成代理类调用被代理类的方法，限制比较小。</p>\n","site":{"data":{}},"length":884,"excerpt":"","more":"<h1 id=\"1-AOP基础\"><a href=\"#1-AOP基础\" class=\"headerlink\" title=\"1. AOP基础\"></a>1. AOP基础</h1><h2 id=\"1-1-动态代理\"><a href=\"#1-1-动态代理\" class=\"headerlink\" title=\"1.1 动态代理\"></a>1.1 动态代理</h2><p>我们都知道java是面向对象语言，服务也被看做对象（比如后端开发中常见的Dao层数据查询对象，Service层的业务对象等）。正常服务间协作，一个对象如果需要使用另一个对象只需要维持一个引用关系就行了，但是这时就有可能出现某个对象被其他大部分对象引用的情况，以日志打印为例。每个业务对象使用都需要创建一个日志对象，并且将打印逻辑嵌在业务代码中（创建一个类组合两个功能也是类似的情况），这无疑增加了开发人员的工作量也增加了不同功能之间的耦合度，不利于后期维护。</p>\n<p>我们可以发现这种增加引用关系，增加代码的操作高度相似，那么能不能抽象出一个对象来专门负责这个功能呢？当然是可以的，java动态代理就是很好的实现之一。</p>\n<p>提前定义代理要使用的类和接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addUser</span><span class=\"params\">(String name)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addUser</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Adding user: &quot;</span> + name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-jdk动态代理\"><a href=\"#1-2-jdk动态代理\" class=\"headerlink\" title=\"1.2 jdk动态代理\"></a>1.2 jdk动态代理</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">JDKProxyDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * init.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> target target</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">JDKProxyDemo</span><span class=\"params\">(UserServiceImpl target)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>();</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> UserService <span class=\"title function_\">getLoggingProxy</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        UserService proxy;</span><br><span class=\"line\">        <span class=\"type\">ClassLoader</span> <span class=\"variable\">loader</span> <span class=\"operator\">=</span> target.getClass().getClassLoader();</span><br><span class=\"line\">        Class[] interfaces = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[]&#123;UserService.class&#125;;</span><br><span class=\"line\">        <span class=\"type\">InvocationHandler</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             * proxy: 代理对象。 一般不使用该对象 method: 正在被调用的方法 args: 调用方法传入的参数</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> method.getName();</span><br><span class=\"line\">                <span class=\"comment\">// log - before method</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;[before] execute method: &quot;</span> + methodName);</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// call method</span></span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 前置通知</span></span><br><span class=\"line\">                    result = method.invoke(target, args);</span><br><span class=\"line\">                    <span class=\"comment\">// 返回通知, 可以访问到方法的返回值</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (NullPointerException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                    <span class=\"comment\">// 异常通知, 可以访问到方法出现的异常</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 后置通知. 因为方法可以能会出异常, 所以访问不到方法的返回值</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// log - after method</span></span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;[after] execute method: &quot;</span> + methodName + <span class=\"string\">&quot;, return value: &quot;</span> + result);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * loader: 代理对象使用的类加载器.</span></span><br><span class=\"line\"><span class=\"comment\">         * interfaces: 指定代理对象的类型. 即代理代理对象中可以有哪些方法.</span></span><br><span class=\"line\"><span class=\"comment\">         * h: 当具体调用代理对象的方法时, 应该如何进行响应, 实际上就是调用 InvocationHandler 的 invoke 方法</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        proxy = (UserService) Proxy.newProxyInstance(loader, interfaces, h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">JDKProxyDemo</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceImpl</span>()).getLoggingProxy();</span><br><span class=\"line\">        userService.addUser(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-cglib动态代理\"><a href=\"#1-3-cglib动态代理\" class=\"headerlink\" title=\"1.3 cglib动态代理\"></a>1.3 cglib动态代理</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CglibProxyDemo</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">getUserLogProxy</span><span class=\"params\">(Object target)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//给业务对象赋值</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.target = target;</span><br><span class=\"line\">        <span class=\"comment\">//创建加强器，用来创建动态代理类</span></span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\">        <span class=\"comment\">//为加强器指定要代理的业务类（即：为下面生成的代理类指定父类）</span></span><br><span class=\"line\">        enhancer.setSuperclass(<span class=\"built_in\">this</span>.target.getClass());</span><br><span class=\"line\">        <span class=\"comment\">//设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦</span></span><br><span class=\"line\">        enhancer.setCallback(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建动态代理类对象并返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现回调方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        <span class=\"comment\">// log - before method</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[before] execute method: &quot;</span> + method.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// call method</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> proxy.invokeSuper(obj, args);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// log - after method</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[after] execute method: &quot;</span> + method.getName() + <span class=\"string\">&quot;, return value: &quot;</span> + result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// proxy</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> (UserService) <span class=\"keyword\">new</span> <span class=\"title class_\">CglibProxyDemo</span>().getUserLogProxy(<span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceImpl</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// call methods</span></span><br><span class=\"line\">        userService.addUser(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-两代理区别\"><a href=\"#1-4-两代理区别\" class=\"headerlink\" title=\"1.4 两代理区别\"></a>1.4 两代理区别</h2><p>JDK是基于接口和反射技术实现的动态代理，动态生成代理类调用接口方法，只能代理类中实现接口的方法。</p>\n<p>CGLIB是基于类继承和ASM字节码编程实现的动态代理，动态生成代理类调用被代理类的方法，限制比较小。</p>\n"},{"title":"SpringBoot参数校验","date":"2024-08-13T15:56:00.000Z","_content":"\n**spring-boot-starter-validation**相关的参数校验\n\n<!--more-->\n\n# 1. 参数校验\n\n## 1.1 Spring参数校验快速开始\n\n### 1.1.1 导入依赖\n\n```xml\n <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-validation</artifactId>\n  </dependency>\n```\n\n### 1.1.2 使用\n\n参数校验实操分两步\n\n- 在Controller层将要校验的参数上标注`@Vaild`注解\n- 在要校验对象属性加上具体的约束\n\n**例子**：\n\n1. 我要校验登录的用户名和密码不能为空，那么我就在参数loginUserDTO前加上`@valid`注解。\n\n   ```java\n   @RestController\n   public class testVaildController {\n       @Resource\n       public LoginService loginService;\n       @PostMapping(\"/login\")\n       public ResponseResult login(@RequestBody @Valid LoginUserDTO loginUserDTO){\n           return ResponseResult.success(loginService.login(loginUserDTO.getUserName(),loginUserDTO.getPassword()));\n       }\n   }\n   ```\n\n2. 然后在LoginUserDTO类中加上具体的约束\n\n   ```java\n   public class LoginUserDTO {\n      @NotBlank(message = \"用户名不能为空\")\n      private String userName = \"\";\n      @NotBlank(message = \"密码不能为空\")\n      private String password = \"\";\n   \n      \n      public String getUserName() {\n         return this.userName;\n      }\n   \n      public void setUserName(String userName) {\n         this.userName = userName;\n      }\n   \n      public String getPassword() {\n         return this.password;\n      }\n   \n      public void setPassword(String password) {\n         this.password = password;\n      }\n   }\n   ```\n\n   这样参数校验就可以生效了，测试接口结果如下：\n\n   ```json\n   {\n       \"timestamp\": \"2024-05-24T09:15:58.364+00:00\",\n       \"status\": 400,\n       \"error\": \"Bad Request\",\n       \"path\": \"/login\"\n   }\n   ```\n\n3. 异常捕获\n\n   为了**更有效的传递信息**以及进行**结果统一返回**、**日志记录**等操作，我们通常会定义异常处理器来统一处理参数校验的异常（BindException是什么见下文异常信息）\n\n   ```java\n   @RestControllerAdvice\n   public class GlobalExceptionHandler {\n       Logger logger = LoggerFactory.getLogger(\"GlobalExceptionHandler\");\n       //抛出的异常是MethodArgumentNotValidException,BindException是它的父类\n       @ExceptionHandler(BindException.class)\n       public ResponseResult bindExceptionHandler(BindException e) {\n           //具体返回什么据情况而定，这里直接返回所有defalutMessage(写在约束注解里的信息)了\n           List<String> list = new ArrayList<>();\n           BindingResult bindingResult = e.getBindingResult();\n           for (ObjectError objectError : bindingResult.getAllErrors()) {\n               FieldError fieldError = (FieldError) objectError;\n               //这里直接使用默认appender打印日志在控制台了，真实线上可以同步到本地、ELK等地方\n               logger.error(\"参数 {} ,{} 校验错误：{}\", fieldError.getField(), fieldError.getRejectedValue(), fieldError.getDefaultMessage());\n               list.add(fieldError.getDefaultMessage());\n           }\n           return ResponseResult.error(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),list.toString());\n       }\n   }\n   ```\n\n**测试数据与结果如下**:\n\n```json\n{\n    \"userName\": \"\",\n    \"password\": \"\"\n}\n\n{\n    \"data\": null,\n    \"code\": 500,\n    \"msg\": \"[用户名不能为空, 密码不能为空]\"\n}\n```\n\n## 1.2 常用的校验注解\n\n1. **控制检查**\n\n   | 注解        | 说明                                   |\n   | ----------- | -------------------------------------- |\n   | `@NotBlank` | 用于字符串，字符串不能为null也不能为空 |\n   | `@NotEmpty` | 字符串同上，集合不能为空，必须有元素   |\n   | `@NotNull`  | 不能为null                             |\n   | `@Null`     | 必须为null                             |\n\n2. **数值检查**\n\n   | 注解                        | 说明                                                         |\n   | --------------------------- | ------------------------------------------------------------ |\n   | `@DecimalMax(value)`        | 被标注元素必须是数字，必须小于等于value                      |\n   | `@DecimalMin(value)`        | 被标注元素必须是数字，必须大于等于value                      |\n   | `@Digits(integer,fraction)` | 被标注的元素必须为数字，其值的整数部分精度为 `integer`，小数部分精度为 `fraction` |\n   | `@Positive`                 | 被标注的元素必须为正数                                       |\n   | `@PositiveOrZero`           | 被标注的元素必须为正数或 0                                   |\n   | `@Max(value)`               | 被标注的元素必须小于等于指定的值                             |\n   | `@Min(value)`               | 被标注的元素必须大于等于指定的值                             |\n   | `@negative`                 | 被标注的元素必须为负数                                       |\n   | `NegativeOrZero`            | 被标注的元素必须为负数或 0                                   |\n\n3. **Boolean检查**（不太用的到的样子）\n\n   | 注解         | 说明                         |\n   | ------------ | ---------------------------- |\n   | @AssertFalse | 被标注的元素必须值为 `false` |\n   | @AssertTrue  | 被标注的元素必须值为 `true`  |\n\n4. **长度检查**\n\n   | 注解           | 说明                                                         |\n   | -------------- | ------------------------------------------------------------ |\n   | @Size(min,max) | 被标注的元素长度必须在 `min` 和 `max` 之间，可以是 String、Collection、Map、数组 |\n\n5. **日期检查**\n\n   | 注解               | 说明                                 |\n   | ------------------ | ------------------------------------ |\n   | `@Future`          | 被标注的元素必须是一个将来的日期     |\n   | `@FutureOrPresent` | 被标注的元素必须是现在或者将来的日期 |\n   | `@Past`            | 被标注的元素必须是一个过去的日期     |\n   | `@PastOrPresent`   | 被标注的元素必须是现在或者过去的日期 |\n\n6. **其他**\n\n   | 注解             | 说明                           |\n   | ---------------- | ------------------------------ |\n   | @Email           | 被标注的元素必须是电子邮箱地址 |\n   | @Pattern(regexp) | 被标注的元素必须符合正则表达式 |\n\n\n## 1.3 @Vaild与@Vaildated\n\n在第一步加注解的时候，可以明显的看到还有一个可能也是参数校验的注解`@Validated`，把`@Vaild`换成`@Validated`，我们惊奇的发现参数校验也能正常的工作，接下来我们就来看看这两注解之间的联系与区别。\n\n### 1.3.1 来源\n\n一个是**Spring**的，一个是**javax**，了解过`@Autowired`与`@Resource`区别的老哥可能很快就反应过来了，就像这两个注解一样。一个是JSR规范的，一个是Spring规范的\n\n```java\nimport org.springframework.validation.annotation.Validated;\nimport javax.validation.Valid;\n```\n\n### 1.3.2 定义区别\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Validated {\n    Class<?>[] value() default {};\n}\n\n@Target({ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Valid {\n}\n```\n\n**差异主要有两点**：\n\n- 能标注的地方\n\n  可以看到`@Valid`注解除了能标注在**类、方法、方法参数**上还能标注在**类里面属性、任何使用类型的地方**。\n\n- 属性\n\n  `Validated`注解里面比`Valid`多了一个value \n\n接下来我们来结合定义区别看看它们的功能差异\n\n### 1.3.3 功能差异\n\n#### 嵌套校验\n\n上文校验的时候我们在类属性上加上相关的限制注解就可以了，但是如果属性是一个类的实例，我们想校验这个作为属性的实例里面的字段，我们就只能使用`@Vaild`加在属性上，标注这是需要校验的属性。**`@Validated`不能标注在属性上**，自然也就**不支持嵌套校验**\n\n```java\n@PostMapping(\"/buy\")\n    public ResponseResult buy(@RequestBody @Valid ShoppingCart shoppingCart){\n        return ResponseResult.success(payService.pay(shoppingCart.getUserId(),shoppingCart.getItemList()));\n    }\n//购物车类\npublic class ShoppingCart {\n    @Positive(message = \"用户id必须大于0\")\n    private Long userId;\n    @NotEmpty(message = \"不能为空\")\n    @Valid\n    private List<Item> itemList;\n\n    public Long getUserId() {\n        return userId;\n    }\n\n    public void setUserId(Long userId) {\n        this.userId = userId;\n    }\n\n    public List<Item> getItemList() {\n        return itemList;\n    }\n\n    public void setItemList(List<Item> itemList) {\n        this.itemList = itemList;\n    }\n}\n//物品类\npublic class Item {\n    @Positive(message = \"价格必须大于0\")\n    private BigDecimal price;\n    @NotBlank(message = \"物品名不能为空\")\n    private String name;\n    @Positive(message = \"数量必须大于0\")\n    private int number;\n\n    public BigDecimal getPrice() {\n        return price;\n    }\n\n    public void setPrice(BigDecimal price) {\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getNumber() {\n        return number;\n    }\n\n    public void setNumber(int number) {\n        this.number = number;\n    }\n}\n//...服务自行模拟\n```\n\n**结果**\n\n```json\n{\n    \"userId\": \"1\",\n    \"itemList\":[\n        {\n        \"price\": \"142.0\",\n        \"name\": \"小风车\",\n        \"number\": 1\n        },\n        {\n        \"price\": \"-2\",\n        \"name\": \"\",\n        \"number\": -1\n        }\n    ]\n}\n\n{\n    \"data\": null,\n    \"code\": 500,\n    \"msg\": \"[数量必须大于0, 价格必须大于0, 物品名不能为空]\"\n}\n```\n\n可以看到校验成功了，当然这里的异常捕获逻辑比较简单，具体生产环境里可以将返回具体的校验信息，进行更清晰的信息提示。\n\n\n\n**杂记**：\n\n- `@Valid`作用域比较广还可以标注在许多意向不到的位置\n\n  ```java\n  //比如，(可以自行观察一下运行结果,都是可以正常校验的)\n  private  List<@Valid Item> itemList;\n  private @Valid List< Item> itemList;\n  ```\n\n- `@Valid`与`@Validated`可以混用\n\n  ```java\n  //controller里面注解改为@Validated依然可以生效 \n  @PostMapping(\"/buy\")\n      public  ResponseResult  buy(@RequestBody @Validated ShoppingCart  shoppingCart){\n          return ResponseResult.success(payService.pay(shoppingCart.getUserId(),shoppingCart.getItemList()));\n      }\n  ```\n\n- 消息的顺序不固定\n\n  ```java\n  {\n      \"data\": null,\n      \"code\": 500,\n      \"msg\": \"[数量必须大于0, 价格必须大于0, 物品名不能为空]\" //这三条消息打印的顺序是不固定的\n  }\n  ```\n\n\n\n#### 分组校验\n\n上面看注解代码的时候可以明显注意到`@Validated`注解里面有个`value`属性。**`@Valid`没有value属性**，自然也就**不支持分组校验**\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Validated {\n    //传入分组,默认是Defalut.class\n    Class<?>[] value() default {};\n}\n```\n\n这就和`@Validated`的分组校验有关了，(`@Valid`没有定义这个属性，自然也就不支持分组校验）\n\n```java\n//Default是个接口，只起到标记作用\npackage javax.validation.groups;\n\npublic interface Default {\n}\n```\n\n我们可以自定义分组来指定需要校验的时机。\n\n```java\n//定义Group类，里面两个接口用作校验(也可以用类，不过和原生的贴合一点比较好)\npublic class Group {\n   public interface GroupTest1{}\n   public interface GroupTest2{}\n}\n```\n\n**测试**\n\n```java\npublic class LoginUserDTO {\n    //只有分组属于这两个才校验\n   @NotBlank(message = \"账户不能为空\",groups = {Group.GroupTest1.class, Default.class})\n   private String userName = \"\";\n   @NotBlank(message = \"密码不能为空\")\n   private String password = \"\";\n\n   \n   public String getUserName() {\n      return this.userName;\n   }\n\n   public void setUserName(String userName) {\n      this.userName = userName;\n   }\n\n   public String getPassword() {\n      return this.password;\n   }\n\n   public void setPassword(String password) {\n      this.password = password;\n   }\n}\n//controller\n\t@PostMapping(\"/login\")\n    public ResponseResult login(@RequestBody @Validated(value = {Group.GroupTest2.class}) LoginUserDTO loginUserDTO){\n        return ResponseResult.success(loginService.login(loginUserDTO.getUserName(),loginUserDTO.getPassword()));\n    }\n\n```\n\n**结果**：\n\n```json\n//不属于分组，不校验userName（其他情况自行尝试\n{\n    \"userName\":\"\",\n    \"password\":\"123456\"\n}\n{\n    \"data\": \"登录成功\",\n    \"code\": 200,\n    \"msg\": \"操作成功\"\n}\n```\n\n\n\n# 2. 深入理解@Valid与@Validated\n\n因为`@Valid`与`@Validated`能混合使用，我们可以大胆猜测一下，一定有一个`Adapter`来承担两者的适配工作，搜搜Valid相关的Adapter，还真有一个。\n\n## 2.1 SpringValidtorAdapter\n\n```java\npublic class SpringValidatorAdapter implements SmartValidator, javax.validation.Validator {\n    \t@Nullable\n\tprivate javax.validation.Validator targetValidator;\n    //没有返回值，重写Spring中Validator的方法\n\t@Override\n\tpublic void validate(Object target, Errors errors, Object... validationHints) {\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(\n\t\t\t\t\tthis.targetValidator.validate(target, asValidationGroups(validationHints)), errors);\n\t\t}\n\t}\n    //有返回值，重写的javax中Validator的方法\n    @Override\n\tpublic <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {\n\t\tAssert.state(this.targetValidator != null, \"No target Validator set\");\n\t\treturn this.targetValidator.validate(object, groups);\n\t}\n    \n}\n```\n\n**SpringValidtorAdapter的结构**\n\n![image-20240602190311638](F:/Blog/source/_posts/SpringBoot参数校验/image-20240602190311638.png)\n\n根据上面结构图和代码，可以看到`SpringValidatorAdapter`实现了两个不同的`validator`接口，针对其中核心方法`validate()`进行了返回值的适配（有点像`Runnable`和` Callable`之间的适配）\n\n## 2.2 具体校验器的获取实现\n\n### 2.2.1 ValidatorFactory\n\n```java\npublic interface ValidatorFactory extends AutoCloseable {\n\n\t// 显然，这个接口是最为重要的\n\tValidator getValidator();\n\t// 定义一个新的ValidatorContext验证器上下文，并且和Validator关联上\n\tValidatorContext usingContext();\n    \n\tMessageInterpolator getMessageInterpolator();\n\tTraversableResolver getTraversableResolver();\n\tConstraintValidatorFactory getConstraintValidatorFactory();\n\tParameterNameProvider getParameterNameProvider();\n\tClockProvider getClockProvider();\n\n\tpublic <T> T unwrap(Class<T> type);\n\t// 复写AutoCloseable的方法\n\t@Override\n\tpublic void close();\n\n}\n```\n\n`ValidatorFactory`的实现可以分成两部分，`hibernate`和`Spring`实现。\n\n#### LocalValidatorFactoryBean\n\n`LocalValidatorFactoryBean`不仅是`ValidatorFactory`实现，还是`SpringValidAdapter`子类\n\n```java\npublic class LocalValidatorFactoryBean extends SpringValidatorAdapter\n\t\timplements ValidatorFactory, ApplicationContextAware, InitializingBean, DisposableBean {\n    \n    //重写的InitializingBean中的方法，Bean初始化时会执行\n    @Override\n\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\tpublic void afterPropertiesSet() {\n\t\tConfiguration<?> configuration;\n        \n        ...\n      \n        //根据配置创建工厂，并从工厂里面拿到Validator\n\t\ttry {\n\t\t\tthis.validatorFactory = configuration.buildValidatorFactory();\n\t\t\tsetTargetValidator(this.validatorFactory.getValidator());\n\t\t}\n\t\tfinally {\n\t\t\tcloseMappingStreams(mappingStreams);\n\t\t}\n\t}\n}\n```\n\n#### ValidatorFactoryImpl\n\n在最开始我们导入了校验starter，导入的就有**org.hibernate.validator**相关的类\n\n```java\npackage org.hibernate.validator.internal.engine;\n\npublic class ValidatorFactoryImpl implements HibernateValidatorFactory {\n    @Override\n\tpublic Validator getValidator() {\n\t\treturn createValidator(\n\t\t\t\tconstraintValidatorManager.getDefaultConstraintValidatorFactory(),\n\t\t\t\tvalueExtractorManager,\n\t\t\t\tvalidatorFactoryScopedContext,\n\t\t\t\tmethodValidationConfiguration\n\t\t);\n\t}\n    \n    Validator createValidator(ConstraintValidatorFactory constraintValidatorFactory, \n                              ValueExtractorManager valueExtractorManager,\n\t\t\tValidatorFactoryScopedContext validatorFactoryScopedContext,\n                              MethodValidationConfiguration methodValidationConfiguration) {\n        \n\t\tBeanMetaDataManager beanMetaDataManager = beanMetaDataManagers.computeIfAbsent(\n\t\t\t\tnew BeanMetaDataManagerKey( validatorFactoryScopedContext.getParameterNameProvider(), \n                                           valueExtractorManager, methodValidationConfiguration ),\n\t\t\t\tkey -> new BeanMetaDataManager(\n\t\t\t\t\t\tconstraintHelper,\n\t\t\t\t\t\texecutableHelper,\n\t\t\t\t\t\ttypeResolutionHelper,\n\t\t\t\t\t\tvalidatorFactoryScopedContext.getParameterNameProvider(),\n\t\t\t\t\t\tvalueExtractorManager,\n\t\t\t\t\t\tvalidationOrderGenerator,\n\t\t\t\t\t\tbuildDataProviders(),\n\t\t\t\t\t\tmethodValidationConfiguration\n\t\t\t\t)\n\t\t );\n\n\t\treturn new ValidatorImpl(\n\t\t\t\tconstraintValidatorFactory,\n\t\t\t\tbeanMetaDataManager,\n\t\t\t\tvalueExtractorManager,\n\t\t\t\tconstraintValidatorManager,\n\t\t\t\tvalidationOrderGenerator,\n\t\t\t\tvalidatorFactoryScopedContext\n\t\t);\n\t}\n}\n```\n\n### 2.2.2 ValidatorImpl\n\n`ValidatorImpl`是**Hibernate Validator**提供的唯一校验器实现，校验过程很复杂，了解是哪个类就行，感兴趣可以深度剖析\n\n```java\npublic class ValidatorImpl implements Validator, ExecutableValidator {\n    private static final Collection<Class<?>> DEFAULT_GROUPS = Collections.<Class<?>>singletonList( Default.class );\n\n\t// 分组Group校验的顺序问题\n\t// 若依赖于校验顺序，可用使用@GroupSequence注解来控制Group顺序\n\tprivate final transient ValidationOrderGenerator validationOrderGenerator;\n\tprivate final ConstraintValidatorFactory constraintValidatorFactory;\n\t...\n\n\n\t@Override\n\tpublic final <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {\n\t\tContracts.assertNotNull( object, MESSAGES.validatedObjectMustNotBeNull() );\n        // groups里面的内容不能有null\n\t\tsanityCheckGroups( groups );\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tClass<T> rootBeanClass = (Class<T>) object.getClass();\n\t\tBeanMetaData<T> rootBeanMetaData = beanMetaDataManager.getBeanMetaData( rootBeanClass );\n        //没有约束直接返回\n\t\tif ( !rootBeanMetaData.hasConstraints() ) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n        \n\t\tBaseBeanValidationContext<T> validationContext = getValidationContextBuilder().forValidate( rootBeanClass, rootBeanMetaData, object );\n\n\t\tValidationOrder validationOrder = determineGroupValidationOrder( groups );\n         // ValueContext一个实例用于收集所有相关信息，以验证单个类、属性或方法调用。\n\t\tBeanValueContext<?, Object> valueContext = ValueContexts.getLocalExecutionContextForBean(\n\t\t\t\tvalidatorScopedContext.getParameterNameProvider(),\n\t\t\t\tobject,\n\t\t\t\tvalidationContext.getRootBeanMetaData(),\n\t\t\t\tPathImpl.createRootPath()\n\t\t);\n        // 返回的是失败的消息对象：ConstraintViolation  它是被存储在ValidationContext里的\n\t\treturn validateInContext( validationContext, valueContext, validationOrder );\n        \n}\n```\n\n# 3. 异常信息\n\n## 3.1 说明\n\n参数校验失败抛出的异常时`MethodArgumentNotValidException`，不过建议捕获`BindException`，因为`MethodArgumentNotValidException`是对`BindResult`的封装，只能通过`getMessage()`获取封装好的信息，不够灵活\n\n```java\n//看的出来，确实很简单\npublic class MethodArgumentNotValidException extends BindException {\n    private final MethodParameter parameter;\n\n    public MethodArgumentNotValidException(MethodParameter parameter, BindingResult bindingResult) {\n        super(bindingResult);\n        this.parameter = parameter;\n    }\n\n    public final MethodParameter getParameter() {\n        return this.parameter;\n    }\n\n    public String getMessage() {\n        StringBuilder sb = (new StringBuilder(\"Validation failed for argument [\")).append(this.parameter.getParameterIndex()).append(\"] in \").append(this.parameter.getExecutable().toGenericString());\n        BindingResult bindingResult = this.getBindingResult();\n        if (bindingResult.getErrorCount() > 1) {\n            sb.append(\" with \").append(bindingResult.getErrorCount()).append(\" errors\");\n        }\n\n        sb.append(\": \");\n        Iterator var3 = bindingResult.getAllErrors().iterator();\n\n        while(var3.hasNext()) {\n            ObjectError error = (ObjectError)var3.next();\n            sb.append('[').append(error).append(\"] \");\n        }\n\n        return sb.toString();\n    }\n}\n```\n\n## 3.2 BindException\n\n```java\n//BindException里面主要是封装了一个BindResult\npublic class BindException extends Exception implements BindingResult {\n    private final BindingResult bindingResult;\n\n    public BindException(BindingResult bindingResult) {\n        Assert.notNull(bindingResult, \"BindingResult must not be null\");\n        this.bindingResult = bindingResult;\n    }\n\n    public BindException(Object target, String objectName) {\n        Assert.notNull(target, \"Target object must not be null\");\n        this.bindingResult = new BeanPropertyBindingResult(target, objectName);\n    }\n}\n```\n\n### 3.2.1 BindResult\n\nBindResult是一个接口，里面没有什么特别的东西。\n\n```java\npublic interface BindingResult extends Errors {\n    String MODEL_KEY_PREFIX = BindingResult.class.getName() + \".\";\n\n    @Nullable\n    Object getTarget();\n\n    Map<String, Object> getModel();\n\n    @Nullable\n    Object getRawFieldValue(String field);\n\n    @Nullable\n    PropertyEditor findEditor(@Nullable String field, @Nullable Class<?> valueType);\n\n    @Nullable\n    PropertyEditorRegistry getPropertyEditorRegistry();\n\n    String[] resolveMessageCodes(String errorCode);\n\n    String[] resolveMessageCodes(String errorCode, String field);\n\n    void addError(ObjectError error);\n\n    default void recordFieldValue(String field, Class<?> type, @Nullable Object value) {\n    }\n\n    default void recordSuppressedField(String field) {\n    }\n\n    default String[] getSuppressedFields() {\n        return new String[0];\n    }\n}\n```\n\n### 3.2.2 AbstractBindingResult\n\n一般来说抽象类都是接口的基本实现，BindingResult也不例外\n\n```java\npublic abstract class AbstractBindingResult extends AbstractErrors implements BindingResult, Serializable {\n    private final String objectName;\n    private MessageCodesResolver messageCodesResolver = new DefaultMessageCodesResolver();\n    //储存错误信息\n    private final List<ObjectError> errors = new ArrayList();\n    private final Map<String, Class<?>> fieldTypes = new HashMap();\n    private final Map<String, Object> fieldValues = new HashMap();\n    private final Set<String> suppressedFields = new HashSet();\n    \n    ...\n        \n}\n```\n\n#### ObjectError\n\n1. 本体\n\n   ```java\n   public class ObjectError extends DefaultMessageSourceResolvable {\n       //校验失败的对象名，比如shoppingCart\n       private final String objectName;\n       @Nullable\n       private transient Object source;\n       \n   \t...       \n   }\n   ```\n\n2. 子类\n\n   ```java\n   //ObjectError的子类，获取ObjectError可以强转为该类 (具体实现是FieldError的子类ViolationFieldError）\n   public class FieldError extends ObjectError {\n       //校验失败的地方，比如itemList[1].name\n       private final String field;\n       //校验失败的值，比如-1\n       @Nullable\n       private final Object rejectedValue;\n       private final boolean bindingFailure;\n       ...\n   }\n   ```\n\n3. 父类\n\n   ```java\n   //ObjectError的父类\n   public class DefaultMessageSourceResolvable implements MessageSourceResolvable, Serializable {\n       //存放详细的校验类型信息\n       @Nullable\n       private final String[] codes;\n       @Nullable\n       private final Object[] arguments;\n       //注解里面传的Message到这了\n       @Nullable\n       private final String defaultMessage;\n       \n    \t...   \n           \n   }\n   ```\n\n   \n\n**Tips**：可以自行打印观察值，推测存放信息\n\n```java\n @ExceptionHandler(BindException.class)\n    public ResponseResult bindExceptionHandler(BindException e) {\n        List<String> list = new ArrayList<>();\n        BindingResult bindingResult = e.getBindingResult();\n        for (ObjectError objectError : bindingResult.getAllErrors()) {\n            FieldError fieldError = (FieldError) objectError;\n            System.out.println(\"--------------\");\n            System.out.println(\"codes\");\n            Arrays.stream(fieldError.getCodes()).forEach(System.out::println);\n            System.out.println(\"--------------\");\n            System.out.println(\"code\");\n            System.out.println(fieldError.getCode());\n            System.out.println(\"--------------\");\n            System.out.println(\"ObjectName\");\n            System.out.println(fieldError.getObjectName());\n            logger.error(\"参数 {} ,{} 校验错误：{}\", fieldError.getField(), fieldError.getRejectedValue(), fieldError.getDefaultMessage());\n            list.add(fieldError.getDefaultMessage());\n        }\n        return ResponseResult.error(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),list.toString());\n    }\n```\n\n\n\n\n\n\n\n","source":"_posts/SpringBoot参数校验.md","raw":"---\ntitle: SpringBoot参数校验\ndate: 2024-08-13 23:56:00\ntags:\n   - SpringBoot\ncategories:\n   - 后端开发\n---\n\n**spring-boot-starter-validation**相关的参数校验\n\n<!--more-->\n\n# 1. 参数校验\n\n## 1.1 Spring参数校验快速开始\n\n### 1.1.1 导入依赖\n\n```xml\n <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-validation</artifactId>\n  </dependency>\n```\n\n### 1.1.2 使用\n\n参数校验实操分两步\n\n- 在Controller层将要校验的参数上标注`@Vaild`注解\n- 在要校验对象属性加上具体的约束\n\n**例子**：\n\n1. 我要校验登录的用户名和密码不能为空，那么我就在参数loginUserDTO前加上`@valid`注解。\n\n   ```java\n   @RestController\n   public class testVaildController {\n       @Resource\n       public LoginService loginService;\n       @PostMapping(\"/login\")\n       public ResponseResult login(@RequestBody @Valid LoginUserDTO loginUserDTO){\n           return ResponseResult.success(loginService.login(loginUserDTO.getUserName(),loginUserDTO.getPassword()));\n       }\n   }\n   ```\n\n2. 然后在LoginUserDTO类中加上具体的约束\n\n   ```java\n   public class LoginUserDTO {\n      @NotBlank(message = \"用户名不能为空\")\n      private String userName = \"\";\n      @NotBlank(message = \"密码不能为空\")\n      private String password = \"\";\n   \n      \n      public String getUserName() {\n         return this.userName;\n      }\n   \n      public void setUserName(String userName) {\n         this.userName = userName;\n      }\n   \n      public String getPassword() {\n         return this.password;\n      }\n   \n      public void setPassword(String password) {\n         this.password = password;\n      }\n   }\n   ```\n\n   这样参数校验就可以生效了，测试接口结果如下：\n\n   ```json\n   {\n       \"timestamp\": \"2024-05-24T09:15:58.364+00:00\",\n       \"status\": 400,\n       \"error\": \"Bad Request\",\n       \"path\": \"/login\"\n   }\n   ```\n\n3. 异常捕获\n\n   为了**更有效的传递信息**以及进行**结果统一返回**、**日志记录**等操作，我们通常会定义异常处理器来统一处理参数校验的异常（BindException是什么见下文异常信息）\n\n   ```java\n   @RestControllerAdvice\n   public class GlobalExceptionHandler {\n       Logger logger = LoggerFactory.getLogger(\"GlobalExceptionHandler\");\n       //抛出的异常是MethodArgumentNotValidException,BindException是它的父类\n       @ExceptionHandler(BindException.class)\n       public ResponseResult bindExceptionHandler(BindException e) {\n           //具体返回什么据情况而定，这里直接返回所有defalutMessage(写在约束注解里的信息)了\n           List<String> list = new ArrayList<>();\n           BindingResult bindingResult = e.getBindingResult();\n           for (ObjectError objectError : bindingResult.getAllErrors()) {\n               FieldError fieldError = (FieldError) objectError;\n               //这里直接使用默认appender打印日志在控制台了，真实线上可以同步到本地、ELK等地方\n               logger.error(\"参数 {} ,{} 校验错误：{}\", fieldError.getField(), fieldError.getRejectedValue(), fieldError.getDefaultMessage());\n               list.add(fieldError.getDefaultMessage());\n           }\n           return ResponseResult.error(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),list.toString());\n       }\n   }\n   ```\n\n**测试数据与结果如下**:\n\n```json\n{\n    \"userName\": \"\",\n    \"password\": \"\"\n}\n\n{\n    \"data\": null,\n    \"code\": 500,\n    \"msg\": \"[用户名不能为空, 密码不能为空]\"\n}\n```\n\n## 1.2 常用的校验注解\n\n1. **控制检查**\n\n   | 注解        | 说明                                   |\n   | ----------- | -------------------------------------- |\n   | `@NotBlank` | 用于字符串，字符串不能为null也不能为空 |\n   | `@NotEmpty` | 字符串同上，集合不能为空，必须有元素   |\n   | `@NotNull`  | 不能为null                             |\n   | `@Null`     | 必须为null                             |\n\n2. **数值检查**\n\n   | 注解                        | 说明                                                         |\n   | --------------------------- | ------------------------------------------------------------ |\n   | `@DecimalMax(value)`        | 被标注元素必须是数字，必须小于等于value                      |\n   | `@DecimalMin(value)`        | 被标注元素必须是数字，必须大于等于value                      |\n   | `@Digits(integer,fraction)` | 被标注的元素必须为数字，其值的整数部分精度为 `integer`，小数部分精度为 `fraction` |\n   | `@Positive`                 | 被标注的元素必须为正数                                       |\n   | `@PositiveOrZero`           | 被标注的元素必须为正数或 0                                   |\n   | `@Max(value)`               | 被标注的元素必须小于等于指定的值                             |\n   | `@Min(value)`               | 被标注的元素必须大于等于指定的值                             |\n   | `@negative`                 | 被标注的元素必须为负数                                       |\n   | `NegativeOrZero`            | 被标注的元素必须为负数或 0                                   |\n\n3. **Boolean检查**（不太用的到的样子）\n\n   | 注解         | 说明                         |\n   | ------------ | ---------------------------- |\n   | @AssertFalse | 被标注的元素必须值为 `false` |\n   | @AssertTrue  | 被标注的元素必须值为 `true`  |\n\n4. **长度检查**\n\n   | 注解           | 说明                                                         |\n   | -------------- | ------------------------------------------------------------ |\n   | @Size(min,max) | 被标注的元素长度必须在 `min` 和 `max` 之间，可以是 String、Collection、Map、数组 |\n\n5. **日期检查**\n\n   | 注解               | 说明                                 |\n   | ------------------ | ------------------------------------ |\n   | `@Future`          | 被标注的元素必须是一个将来的日期     |\n   | `@FutureOrPresent` | 被标注的元素必须是现在或者将来的日期 |\n   | `@Past`            | 被标注的元素必须是一个过去的日期     |\n   | `@PastOrPresent`   | 被标注的元素必须是现在或者过去的日期 |\n\n6. **其他**\n\n   | 注解             | 说明                           |\n   | ---------------- | ------------------------------ |\n   | @Email           | 被标注的元素必须是电子邮箱地址 |\n   | @Pattern(regexp) | 被标注的元素必须符合正则表达式 |\n\n\n## 1.3 @Vaild与@Vaildated\n\n在第一步加注解的时候，可以明显的看到还有一个可能也是参数校验的注解`@Validated`，把`@Vaild`换成`@Validated`，我们惊奇的发现参数校验也能正常的工作，接下来我们就来看看这两注解之间的联系与区别。\n\n### 1.3.1 来源\n\n一个是**Spring**的，一个是**javax**，了解过`@Autowired`与`@Resource`区别的老哥可能很快就反应过来了，就像这两个注解一样。一个是JSR规范的，一个是Spring规范的\n\n```java\nimport org.springframework.validation.annotation.Validated;\nimport javax.validation.Valid;\n```\n\n### 1.3.2 定义区别\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Validated {\n    Class<?>[] value() default {};\n}\n\n@Target({ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Valid {\n}\n```\n\n**差异主要有两点**：\n\n- 能标注的地方\n\n  可以看到`@Valid`注解除了能标注在**类、方法、方法参数**上还能标注在**类里面属性、任何使用类型的地方**。\n\n- 属性\n\n  `Validated`注解里面比`Valid`多了一个value \n\n接下来我们来结合定义区别看看它们的功能差异\n\n### 1.3.3 功能差异\n\n#### 嵌套校验\n\n上文校验的时候我们在类属性上加上相关的限制注解就可以了，但是如果属性是一个类的实例，我们想校验这个作为属性的实例里面的字段，我们就只能使用`@Vaild`加在属性上，标注这是需要校验的属性。**`@Validated`不能标注在属性上**，自然也就**不支持嵌套校验**\n\n```java\n@PostMapping(\"/buy\")\n    public ResponseResult buy(@RequestBody @Valid ShoppingCart shoppingCart){\n        return ResponseResult.success(payService.pay(shoppingCart.getUserId(),shoppingCart.getItemList()));\n    }\n//购物车类\npublic class ShoppingCart {\n    @Positive(message = \"用户id必须大于0\")\n    private Long userId;\n    @NotEmpty(message = \"不能为空\")\n    @Valid\n    private List<Item> itemList;\n\n    public Long getUserId() {\n        return userId;\n    }\n\n    public void setUserId(Long userId) {\n        this.userId = userId;\n    }\n\n    public List<Item> getItemList() {\n        return itemList;\n    }\n\n    public void setItemList(List<Item> itemList) {\n        this.itemList = itemList;\n    }\n}\n//物品类\npublic class Item {\n    @Positive(message = \"价格必须大于0\")\n    private BigDecimal price;\n    @NotBlank(message = \"物品名不能为空\")\n    private String name;\n    @Positive(message = \"数量必须大于0\")\n    private int number;\n\n    public BigDecimal getPrice() {\n        return price;\n    }\n\n    public void setPrice(BigDecimal price) {\n        this.price = price;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getNumber() {\n        return number;\n    }\n\n    public void setNumber(int number) {\n        this.number = number;\n    }\n}\n//...服务自行模拟\n```\n\n**结果**\n\n```json\n{\n    \"userId\": \"1\",\n    \"itemList\":[\n        {\n        \"price\": \"142.0\",\n        \"name\": \"小风车\",\n        \"number\": 1\n        },\n        {\n        \"price\": \"-2\",\n        \"name\": \"\",\n        \"number\": -1\n        }\n    ]\n}\n\n{\n    \"data\": null,\n    \"code\": 500,\n    \"msg\": \"[数量必须大于0, 价格必须大于0, 物品名不能为空]\"\n}\n```\n\n可以看到校验成功了，当然这里的异常捕获逻辑比较简单，具体生产环境里可以将返回具体的校验信息，进行更清晰的信息提示。\n\n\n\n**杂记**：\n\n- `@Valid`作用域比较广还可以标注在许多意向不到的位置\n\n  ```java\n  //比如，(可以自行观察一下运行结果,都是可以正常校验的)\n  private  List<@Valid Item> itemList;\n  private @Valid List< Item> itemList;\n  ```\n\n- `@Valid`与`@Validated`可以混用\n\n  ```java\n  //controller里面注解改为@Validated依然可以生效 \n  @PostMapping(\"/buy\")\n      public  ResponseResult  buy(@RequestBody @Validated ShoppingCart  shoppingCart){\n          return ResponseResult.success(payService.pay(shoppingCart.getUserId(),shoppingCart.getItemList()));\n      }\n  ```\n\n- 消息的顺序不固定\n\n  ```java\n  {\n      \"data\": null,\n      \"code\": 500,\n      \"msg\": \"[数量必须大于0, 价格必须大于0, 物品名不能为空]\" //这三条消息打印的顺序是不固定的\n  }\n  ```\n\n\n\n#### 分组校验\n\n上面看注解代码的时候可以明显注意到`@Validated`注解里面有个`value`属性。**`@Valid`没有value属性**，自然也就**不支持分组校验**\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Validated {\n    //传入分组,默认是Defalut.class\n    Class<?>[] value() default {};\n}\n```\n\n这就和`@Validated`的分组校验有关了，(`@Valid`没有定义这个属性，自然也就不支持分组校验）\n\n```java\n//Default是个接口，只起到标记作用\npackage javax.validation.groups;\n\npublic interface Default {\n}\n```\n\n我们可以自定义分组来指定需要校验的时机。\n\n```java\n//定义Group类，里面两个接口用作校验(也可以用类，不过和原生的贴合一点比较好)\npublic class Group {\n   public interface GroupTest1{}\n   public interface GroupTest2{}\n}\n```\n\n**测试**\n\n```java\npublic class LoginUserDTO {\n    //只有分组属于这两个才校验\n   @NotBlank(message = \"账户不能为空\",groups = {Group.GroupTest1.class, Default.class})\n   private String userName = \"\";\n   @NotBlank(message = \"密码不能为空\")\n   private String password = \"\";\n\n   \n   public String getUserName() {\n      return this.userName;\n   }\n\n   public void setUserName(String userName) {\n      this.userName = userName;\n   }\n\n   public String getPassword() {\n      return this.password;\n   }\n\n   public void setPassword(String password) {\n      this.password = password;\n   }\n}\n//controller\n\t@PostMapping(\"/login\")\n    public ResponseResult login(@RequestBody @Validated(value = {Group.GroupTest2.class}) LoginUserDTO loginUserDTO){\n        return ResponseResult.success(loginService.login(loginUserDTO.getUserName(),loginUserDTO.getPassword()));\n    }\n\n```\n\n**结果**：\n\n```json\n//不属于分组，不校验userName（其他情况自行尝试\n{\n    \"userName\":\"\",\n    \"password\":\"123456\"\n}\n{\n    \"data\": \"登录成功\",\n    \"code\": 200,\n    \"msg\": \"操作成功\"\n}\n```\n\n\n\n# 2. 深入理解@Valid与@Validated\n\n因为`@Valid`与`@Validated`能混合使用，我们可以大胆猜测一下，一定有一个`Adapter`来承担两者的适配工作，搜搜Valid相关的Adapter，还真有一个。\n\n## 2.1 SpringValidtorAdapter\n\n```java\npublic class SpringValidatorAdapter implements SmartValidator, javax.validation.Validator {\n    \t@Nullable\n\tprivate javax.validation.Validator targetValidator;\n    //没有返回值，重写Spring中Validator的方法\n\t@Override\n\tpublic void validate(Object target, Errors errors, Object... validationHints) {\n\t\tif (this.targetValidator != null) {\n\t\t\tprocessConstraintViolations(\n\t\t\t\t\tthis.targetValidator.validate(target, asValidationGroups(validationHints)), errors);\n\t\t}\n\t}\n    //有返回值，重写的javax中Validator的方法\n    @Override\n\tpublic <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {\n\t\tAssert.state(this.targetValidator != null, \"No target Validator set\");\n\t\treturn this.targetValidator.validate(object, groups);\n\t}\n    \n}\n```\n\n**SpringValidtorAdapter的结构**\n\n![image-20240602190311638](F:/Blog/source/_posts/SpringBoot参数校验/image-20240602190311638.png)\n\n根据上面结构图和代码，可以看到`SpringValidatorAdapter`实现了两个不同的`validator`接口，针对其中核心方法`validate()`进行了返回值的适配（有点像`Runnable`和` Callable`之间的适配）\n\n## 2.2 具体校验器的获取实现\n\n### 2.2.1 ValidatorFactory\n\n```java\npublic interface ValidatorFactory extends AutoCloseable {\n\n\t// 显然，这个接口是最为重要的\n\tValidator getValidator();\n\t// 定义一个新的ValidatorContext验证器上下文，并且和Validator关联上\n\tValidatorContext usingContext();\n    \n\tMessageInterpolator getMessageInterpolator();\n\tTraversableResolver getTraversableResolver();\n\tConstraintValidatorFactory getConstraintValidatorFactory();\n\tParameterNameProvider getParameterNameProvider();\n\tClockProvider getClockProvider();\n\n\tpublic <T> T unwrap(Class<T> type);\n\t// 复写AutoCloseable的方法\n\t@Override\n\tpublic void close();\n\n}\n```\n\n`ValidatorFactory`的实现可以分成两部分，`hibernate`和`Spring`实现。\n\n#### LocalValidatorFactoryBean\n\n`LocalValidatorFactoryBean`不仅是`ValidatorFactory`实现，还是`SpringValidAdapter`子类\n\n```java\npublic class LocalValidatorFactoryBean extends SpringValidatorAdapter\n\t\timplements ValidatorFactory, ApplicationContextAware, InitializingBean, DisposableBean {\n    \n    //重写的InitializingBean中的方法，Bean初始化时会执行\n    @Override\n\t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n\tpublic void afterPropertiesSet() {\n\t\tConfiguration<?> configuration;\n        \n        ...\n      \n        //根据配置创建工厂，并从工厂里面拿到Validator\n\t\ttry {\n\t\t\tthis.validatorFactory = configuration.buildValidatorFactory();\n\t\t\tsetTargetValidator(this.validatorFactory.getValidator());\n\t\t}\n\t\tfinally {\n\t\t\tcloseMappingStreams(mappingStreams);\n\t\t}\n\t}\n}\n```\n\n#### ValidatorFactoryImpl\n\n在最开始我们导入了校验starter，导入的就有**org.hibernate.validator**相关的类\n\n```java\npackage org.hibernate.validator.internal.engine;\n\npublic class ValidatorFactoryImpl implements HibernateValidatorFactory {\n    @Override\n\tpublic Validator getValidator() {\n\t\treturn createValidator(\n\t\t\t\tconstraintValidatorManager.getDefaultConstraintValidatorFactory(),\n\t\t\t\tvalueExtractorManager,\n\t\t\t\tvalidatorFactoryScopedContext,\n\t\t\t\tmethodValidationConfiguration\n\t\t);\n\t}\n    \n    Validator createValidator(ConstraintValidatorFactory constraintValidatorFactory, \n                              ValueExtractorManager valueExtractorManager,\n\t\t\tValidatorFactoryScopedContext validatorFactoryScopedContext,\n                              MethodValidationConfiguration methodValidationConfiguration) {\n        \n\t\tBeanMetaDataManager beanMetaDataManager = beanMetaDataManagers.computeIfAbsent(\n\t\t\t\tnew BeanMetaDataManagerKey( validatorFactoryScopedContext.getParameterNameProvider(), \n                                           valueExtractorManager, methodValidationConfiguration ),\n\t\t\t\tkey -> new BeanMetaDataManager(\n\t\t\t\t\t\tconstraintHelper,\n\t\t\t\t\t\texecutableHelper,\n\t\t\t\t\t\ttypeResolutionHelper,\n\t\t\t\t\t\tvalidatorFactoryScopedContext.getParameterNameProvider(),\n\t\t\t\t\t\tvalueExtractorManager,\n\t\t\t\t\t\tvalidationOrderGenerator,\n\t\t\t\t\t\tbuildDataProviders(),\n\t\t\t\t\t\tmethodValidationConfiguration\n\t\t\t\t)\n\t\t );\n\n\t\treturn new ValidatorImpl(\n\t\t\t\tconstraintValidatorFactory,\n\t\t\t\tbeanMetaDataManager,\n\t\t\t\tvalueExtractorManager,\n\t\t\t\tconstraintValidatorManager,\n\t\t\t\tvalidationOrderGenerator,\n\t\t\t\tvalidatorFactoryScopedContext\n\t\t);\n\t}\n}\n```\n\n### 2.2.2 ValidatorImpl\n\n`ValidatorImpl`是**Hibernate Validator**提供的唯一校验器实现，校验过程很复杂，了解是哪个类就行，感兴趣可以深度剖析\n\n```java\npublic class ValidatorImpl implements Validator, ExecutableValidator {\n    private static final Collection<Class<?>> DEFAULT_GROUPS = Collections.<Class<?>>singletonList( Default.class );\n\n\t// 分组Group校验的顺序问题\n\t// 若依赖于校验顺序，可用使用@GroupSequence注解来控制Group顺序\n\tprivate final transient ValidationOrderGenerator validationOrderGenerator;\n\tprivate final ConstraintValidatorFactory constraintValidatorFactory;\n\t...\n\n\n\t@Override\n\tpublic final <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {\n\t\tContracts.assertNotNull( object, MESSAGES.validatedObjectMustNotBeNull() );\n        // groups里面的内容不能有null\n\t\tsanityCheckGroups( groups );\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tClass<T> rootBeanClass = (Class<T>) object.getClass();\n\t\tBeanMetaData<T> rootBeanMetaData = beanMetaDataManager.getBeanMetaData( rootBeanClass );\n        //没有约束直接返回\n\t\tif ( !rootBeanMetaData.hasConstraints() ) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n        \n\t\tBaseBeanValidationContext<T> validationContext = getValidationContextBuilder().forValidate( rootBeanClass, rootBeanMetaData, object );\n\n\t\tValidationOrder validationOrder = determineGroupValidationOrder( groups );\n         // ValueContext一个实例用于收集所有相关信息，以验证单个类、属性或方法调用。\n\t\tBeanValueContext<?, Object> valueContext = ValueContexts.getLocalExecutionContextForBean(\n\t\t\t\tvalidatorScopedContext.getParameterNameProvider(),\n\t\t\t\tobject,\n\t\t\t\tvalidationContext.getRootBeanMetaData(),\n\t\t\t\tPathImpl.createRootPath()\n\t\t);\n        // 返回的是失败的消息对象：ConstraintViolation  它是被存储在ValidationContext里的\n\t\treturn validateInContext( validationContext, valueContext, validationOrder );\n        \n}\n```\n\n# 3. 异常信息\n\n## 3.1 说明\n\n参数校验失败抛出的异常时`MethodArgumentNotValidException`，不过建议捕获`BindException`，因为`MethodArgumentNotValidException`是对`BindResult`的封装，只能通过`getMessage()`获取封装好的信息，不够灵活\n\n```java\n//看的出来，确实很简单\npublic class MethodArgumentNotValidException extends BindException {\n    private final MethodParameter parameter;\n\n    public MethodArgumentNotValidException(MethodParameter parameter, BindingResult bindingResult) {\n        super(bindingResult);\n        this.parameter = parameter;\n    }\n\n    public final MethodParameter getParameter() {\n        return this.parameter;\n    }\n\n    public String getMessage() {\n        StringBuilder sb = (new StringBuilder(\"Validation failed for argument [\")).append(this.parameter.getParameterIndex()).append(\"] in \").append(this.parameter.getExecutable().toGenericString());\n        BindingResult bindingResult = this.getBindingResult();\n        if (bindingResult.getErrorCount() > 1) {\n            sb.append(\" with \").append(bindingResult.getErrorCount()).append(\" errors\");\n        }\n\n        sb.append(\": \");\n        Iterator var3 = bindingResult.getAllErrors().iterator();\n\n        while(var3.hasNext()) {\n            ObjectError error = (ObjectError)var3.next();\n            sb.append('[').append(error).append(\"] \");\n        }\n\n        return sb.toString();\n    }\n}\n```\n\n## 3.2 BindException\n\n```java\n//BindException里面主要是封装了一个BindResult\npublic class BindException extends Exception implements BindingResult {\n    private final BindingResult bindingResult;\n\n    public BindException(BindingResult bindingResult) {\n        Assert.notNull(bindingResult, \"BindingResult must not be null\");\n        this.bindingResult = bindingResult;\n    }\n\n    public BindException(Object target, String objectName) {\n        Assert.notNull(target, \"Target object must not be null\");\n        this.bindingResult = new BeanPropertyBindingResult(target, objectName);\n    }\n}\n```\n\n### 3.2.1 BindResult\n\nBindResult是一个接口，里面没有什么特别的东西。\n\n```java\npublic interface BindingResult extends Errors {\n    String MODEL_KEY_PREFIX = BindingResult.class.getName() + \".\";\n\n    @Nullable\n    Object getTarget();\n\n    Map<String, Object> getModel();\n\n    @Nullable\n    Object getRawFieldValue(String field);\n\n    @Nullable\n    PropertyEditor findEditor(@Nullable String field, @Nullable Class<?> valueType);\n\n    @Nullable\n    PropertyEditorRegistry getPropertyEditorRegistry();\n\n    String[] resolveMessageCodes(String errorCode);\n\n    String[] resolveMessageCodes(String errorCode, String field);\n\n    void addError(ObjectError error);\n\n    default void recordFieldValue(String field, Class<?> type, @Nullable Object value) {\n    }\n\n    default void recordSuppressedField(String field) {\n    }\n\n    default String[] getSuppressedFields() {\n        return new String[0];\n    }\n}\n```\n\n### 3.2.2 AbstractBindingResult\n\n一般来说抽象类都是接口的基本实现，BindingResult也不例外\n\n```java\npublic abstract class AbstractBindingResult extends AbstractErrors implements BindingResult, Serializable {\n    private final String objectName;\n    private MessageCodesResolver messageCodesResolver = new DefaultMessageCodesResolver();\n    //储存错误信息\n    private final List<ObjectError> errors = new ArrayList();\n    private final Map<String, Class<?>> fieldTypes = new HashMap();\n    private final Map<String, Object> fieldValues = new HashMap();\n    private final Set<String> suppressedFields = new HashSet();\n    \n    ...\n        \n}\n```\n\n#### ObjectError\n\n1. 本体\n\n   ```java\n   public class ObjectError extends DefaultMessageSourceResolvable {\n       //校验失败的对象名，比如shoppingCart\n       private final String objectName;\n       @Nullable\n       private transient Object source;\n       \n   \t...       \n   }\n   ```\n\n2. 子类\n\n   ```java\n   //ObjectError的子类，获取ObjectError可以强转为该类 (具体实现是FieldError的子类ViolationFieldError）\n   public class FieldError extends ObjectError {\n       //校验失败的地方，比如itemList[1].name\n       private final String field;\n       //校验失败的值，比如-1\n       @Nullable\n       private final Object rejectedValue;\n       private final boolean bindingFailure;\n       ...\n   }\n   ```\n\n3. 父类\n\n   ```java\n   //ObjectError的父类\n   public class DefaultMessageSourceResolvable implements MessageSourceResolvable, Serializable {\n       //存放详细的校验类型信息\n       @Nullable\n       private final String[] codes;\n       @Nullable\n       private final Object[] arguments;\n       //注解里面传的Message到这了\n       @Nullable\n       private final String defaultMessage;\n       \n    \t...   \n           \n   }\n   ```\n\n   \n\n**Tips**：可以自行打印观察值，推测存放信息\n\n```java\n @ExceptionHandler(BindException.class)\n    public ResponseResult bindExceptionHandler(BindException e) {\n        List<String> list = new ArrayList<>();\n        BindingResult bindingResult = e.getBindingResult();\n        for (ObjectError objectError : bindingResult.getAllErrors()) {\n            FieldError fieldError = (FieldError) objectError;\n            System.out.println(\"--------------\");\n            System.out.println(\"codes\");\n            Arrays.stream(fieldError.getCodes()).forEach(System.out::println);\n            System.out.println(\"--------------\");\n            System.out.println(\"code\");\n            System.out.println(fieldError.getCode());\n            System.out.println(\"--------------\");\n            System.out.println(\"ObjectName\");\n            System.out.println(fieldError.getObjectName());\n            logger.error(\"参数 {} ,{} 校验错误：{}\", fieldError.getField(), fieldError.getRejectedValue(), fieldError.getDefaultMessage());\n            list.add(fieldError.getDefaultMessage());\n        }\n        return ResponseResult.error(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),list.toString());\n    }\n```\n\n\n\n\n\n\n\n","slug":"SpringBoot参数校验","published":1,"updated":"2024-09-03T02:40:15.063Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6bj0008skusexl99vng","content":"<p><strong>spring-boot-starter-validation</strong>相关的参数校验</p>\n<span id=\"more\"></span>\n\n<h1 id=\"1-参数校验\"><a href=\"#1-参数校验\" class=\"headerlink\" title=\"1. 参数校验\"></a>1. 参数校验</h1><h2 id=\"1-1-Spring参数校验快速开始\"><a href=\"#1-1-Spring参数校验快速开始\" class=\"headerlink\" title=\"1.1 Spring参数校验快速开始\"></a>1.1 Spring参数校验快速开始</h2><h3 id=\"1-1-1-导入依赖\"><a href=\"#1-1-1-导入依赖\" class=\"headerlink\" title=\"1.1.1 导入依赖\"></a>1.1.1 导入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-validation<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-2-使用\"><a href=\"#1-1-2-使用\" class=\"headerlink\" title=\"1.1.2 使用\"></a>1.1.2 使用</h3><p>参数校验实操分两步</p>\n<ul>\n<li>在Controller层将要校验的参数上标注<code>@Vaild</code>注解</li>\n<li>在要校验对象属性加上具体的约束</li>\n</ul>\n<p><strong>例子</strong>：</p>\n<ol>\n<li><p>我要校验登录的用户名和密码不能为空，那么我就在参数loginUserDTO前加上<code>@valid</code>注解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testVaildController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LoginService loginService;</span><br><span class=\"line\">    <span class=\"meta\">@PostMapping(&quot;/login&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResponseResult <span class=\"title function_\">login</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> <span class=\"meta\">@Valid</span> LoginUserDTO loginUserDTO)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseResult.success(loginService.login(loginUserDTO.getUserName(),loginUserDTO.getPassword()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后在LoginUserDTO类中加上具体的约束</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginUserDTO</span> &#123;</span><br><span class=\"line\">   <span class=\"meta\">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">userName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">   <span class=\"meta\">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getUserName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.userName;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setUserName</span><span class=\"params\">(String userName)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.userName = userName;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getPassword</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.password;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setPassword</span><span class=\"params\">(String password)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.password = password;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样参数校验就可以生效了，测试接口结果如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;2024-05-24T09:15:58.364+00:00&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;status&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">400</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;error&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Bad Request&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;path&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/login&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>异常捕获</p>\n<p>为了<strong>更有效的传递信息</strong>以及进行<strong>结果统一返回</strong>、<strong>日志记录</strong>等操作，我们通常会定义异常处理器来统一处理参数校验的异常（BindException是什么见下文异常信息）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GlobalExceptionHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(<span class=\"string\">&quot;GlobalExceptionHandler&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//抛出的异常是MethodArgumentNotValidException,BindException是它的父类</span></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(BindException.class)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResponseResult <span class=\"title function_\">bindExceptionHandler</span><span class=\"params\">(BindException e)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//具体返回什么据情况而定，这里直接返回所有defalutMessage(写在约束注解里的信息)了</span></span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">BindingResult</span> <span class=\"variable\">bindingResult</span> <span class=\"operator\">=</span> e.getBindingResult();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ObjectError objectError : bindingResult.getAllErrors()) &#123;</span><br><span class=\"line\">            <span class=\"type\">FieldError</span> <span class=\"variable\">fieldError</span> <span class=\"operator\">=</span> (FieldError) objectError;</span><br><span class=\"line\">            <span class=\"comment\">//这里直接使用默认appender打印日志在控制台了，真实线上可以同步到本地、ELK等地方</span></span><br><span class=\"line\">            logger.error(<span class=\"string\">&quot;参数 &#123;&#125; ,&#123;&#125; 校验错误：&#123;&#125;&quot;</span>, fieldError.getField(), fieldError.getRejectedValue(), fieldError.getDefaultMessage());</span><br><span class=\"line\">            list.add(fieldError.getDefaultMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseResult.error(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),list.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>测试数据与结果如下</strong>:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;userName&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;password&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;data&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">null</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;code&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">500</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;msg&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;[用户名不能为空, 密码不能为空]&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-常用的校验注解\"><a href=\"#1-2-常用的校验注解\" class=\"headerlink\" title=\"1.2 常用的校验注解\"></a>1.2 常用的校验注解</h2><ol>\n<li><p><strong>控制检查</strong></p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>@NotBlank</code></td>\n<td>用于字符串，字符串不能为null也不能为空</td>\n</tr>\n<tr>\n<td><code>@NotEmpty</code></td>\n<td>字符串同上，集合不能为空，必须有元素</td>\n</tr>\n<tr>\n<td><code>@NotNull</code></td>\n<td>不能为null</td>\n</tr>\n<tr>\n<td><code>@Null</code></td>\n<td>必须为null</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>数值检查</strong></p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>@DecimalMax(value)</code></td>\n<td>被标注元素必须是数字，必须小于等于value</td>\n</tr>\n<tr>\n<td><code>@DecimalMin(value)</code></td>\n<td>被标注元素必须是数字，必须大于等于value</td>\n</tr>\n<tr>\n<td><code>@Digits(integer,fraction)</code></td>\n<td>被标注的元素必须为数字，其值的整数部分精度为 <code>integer</code>，小数部分精度为 <code>fraction</code></td>\n</tr>\n<tr>\n<td><code>@Positive</code></td>\n<td>被标注的元素必须为正数</td>\n</tr>\n<tr>\n<td><code>@PositiveOrZero</code></td>\n<td>被标注的元素必须为正数或 0</td>\n</tr>\n<tr>\n<td><code>@Max(value)</code></td>\n<td>被标注的元素必须小于等于指定的值</td>\n</tr>\n<tr>\n<td><code>@Min(value)</code></td>\n<td>被标注的元素必须大于等于指定的值</td>\n</tr>\n<tr>\n<td><code>@negative</code></td>\n<td>被标注的元素必须为负数</td>\n</tr>\n<tr>\n<td><code>NegativeOrZero</code></td>\n<td>被标注的元素必须为负数或 0</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>Boolean检查</strong>（不太用的到的样子）</p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@AssertFalse</td>\n<td>被标注的元素必须值为 <code>false</code></td>\n</tr>\n<tr>\n<td>@AssertTrue</td>\n<td>被标注的元素必须值为 <code>true</code></td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>长度检查</strong></p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@Size(min,max)</td>\n<td>被标注的元素长度必须在 <code>min</code> 和 <code>max</code> 之间，可以是 String、Collection、Map、数组</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>日期检查</strong></p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>@Future</code></td>\n<td>被标注的元素必须是一个将来的日期</td>\n</tr>\n<tr>\n<td><code>@FutureOrPresent</code></td>\n<td>被标注的元素必须是现在或者将来的日期</td>\n</tr>\n<tr>\n<td><code>@Past</code></td>\n<td>被标注的元素必须是一个过去的日期</td>\n</tr>\n<tr>\n<td><code>@PastOrPresent</code></td>\n<td>被标注的元素必须是现在或者过去的日期</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>其他</strong></p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@Email</td>\n<td>被标注的元素必须是电子邮箱地址</td>\n</tr>\n<tr>\n<td>@Pattern(regexp)</td>\n<td>被标注的元素必须符合正则表达式</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h2 id=\"1-3-Vaild与-Vaildated\"><a href=\"#1-3-Vaild与-Vaildated\" class=\"headerlink\" title=\"1.3 @Vaild与@Vaildated\"></a>1.3 @Vaild与@Vaildated</h2><p>在第一步加注解的时候，可以明显的看到还有一个可能也是参数校验的注解<code>@Validated</code>，把<code>@Vaild</code>换成<code>@Validated</code>，我们惊奇的发现参数校验也能正常的工作，接下来我们就来看看这两注解之间的联系与区别。</p>\n<h3 id=\"1-3-1-来源\"><a href=\"#1-3-1-来源\" class=\"headerlink\" title=\"1.3.1 来源\"></a>1.3.1 来源</h3><p>一个是<strong>Spring</strong>的，一个是<strong>javax</strong>，了解过<code>@Autowired</code>与<code>@Resource</code>区别的老哥可能很快就反应过来了，就像这两个注解一样。一个是JSR规范的，一个是Spring规范的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.validation.annotation.Validated;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.Valid;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-2-定义区别\"><a href=\"#1-3-2-定义区别\" class=\"headerlink\" title=\"1.3.2 定义区别\"></a>1.3.2 定义区别</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Validated &#123;</span><br><span class=\"line\">    Class&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Valid &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>差异主要有两点</strong>：</p>\n<ul>\n<li><p>能标注的地方</p>\n<p>可以看到<code>@Valid</code>注解除了能标注在<strong>类、方法、方法参数</strong>上还能标注在<strong>类里面属性、任何使用类型的地方</strong>。</p>\n</li>\n<li><p>属性</p>\n<p><code>Validated</code>注解里面比<code>Valid</code>多了一个value</p>\n</li>\n</ul>\n<p>接下来我们来结合定义区别看看它们的功能差异</p>\n<h3 id=\"1-3-3-功能差异\"><a href=\"#1-3-3-功能差异\" class=\"headerlink\" title=\"1.3.3 功能差异\"></a>1.3.3 功能差异</h3><h4 id=\"嵌套校验\"><a href=\"#嵌套校验\" class=\"headerlink\" title=\"嵌套校验\"></a>嵌套校验</h4><p>上文校验的时候我们在类属性上加上相关的限制注解就可以了，但是如果属性是一个类的实例，我们想校验这个作为属性的实例里面的字段，我们就只能使用<code>@Vaild</code>加在属性上，标注这是需要校验的属性。**<code>@Validated</code>不能标注在属性上<strong>，自然也就</strong>不支持嵌套校验**</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/buy&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResponseResult <span class=\"title function_\">buy</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> <span class=\"meta\">@Valid</span> ShoppingCart shoppingCart)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseResult.success(payService.pay(shoppingCart.getUserId(),shoppingCart.getItemList()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//购物车类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ShoppingCart</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Positive(message = &quot;用户id必须大于0&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long userId;</span><br><span class=\"line\">    <span class=\"meta\">@NotEmpty(message = &quot;不能为空&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Valid</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Item&gt; itemList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">getUserId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setUserId</span><span class=\"params\">(Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userId = userId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Item&gt; <span class=\"title function_\">getItemList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> itemList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setItemList</span><span class=\"params\">(List&lt;Item&gt; itemList)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.itemList = itemList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//物品类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Item</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Positive(message = &quot;价格必须大于0&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BigDecimal price;</span><br><span class=\"line\">    <span class=\"meta\">@NotBlank(message = &quot;物品名不能为空&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Positive(message = &quot;数量必须大于0&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> number;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> BigDecimal <span class=\"title function_\">getPrice</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setPrice</span><span class=\"params\">(BigDecimal price)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getNumber</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setNumber</span><span class=\"params\">(<span class=\"type\">int</span> number)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.number = number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...服务自行模拟</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;userId&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;itemList&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;price&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;142.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;小风车&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;number&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;price&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;-2&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;number&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;data&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">null</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;code&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">500</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;msg&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;[数量必须大于0, 价格必须大于0, 物品名不能为空]&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到校验成功了，当然这里的异常捕获逻辑比较简单，具体生产环境里可以将返回具体的校验信息，进行更清晰的信息提示。</p>\n<p><strong>杂记</strong>：</p>\n<ul>\n<li><p><code>@Valid</code>作用域比较广还可以标注在许多意向不到的位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//比如，(可以自行观察一下运行结果,都是可以正常校验的)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>  List&lt;<span class=\"meta\">@Valid</span> Item&gt; itemList;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"meta\">@Valid</span> List&lt; Item&gt; itemList;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>@Valid</code>与<code>@Validated</code>可以混用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//controller里面注解改为@Validated依然可以生效 </span></span><br><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/buy&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  ResponseResult  <span class=\"title function_\">buy</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> <span class=\"meta\">@Validated</span> ShoppingCart  shoppingCart)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseResult.success(payService.pay(shoppingCart.getUserId(),shoppingCart.getItemList()));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>消息的顺序不固定</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;data&quot;</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;code&quot;</span>: <span class=\"number\">500</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;msg&quot;</span>: <span class=\"string\">&quot;[数量必须大于0, 价格必须大于0, 物品名不能为空]&quot;</span> <span class=\"comment\">//这三条消息打印的顺序是不固定的</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"分组校验\"><a href=\"#分组校验\" class=\"headerlink\" title=\"分组校验\"></a>分组校验</h4><p>上面看注解代码的时候可以明显注意到<code>@Validated</code>注解里面有个<code>value</code>属性。**<code>@Valid</code>没有value属性<strong>，自然也就</strong>不支持分组校验**</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Validated &#123;</span><br><span class=\"line\">    <span class=\"comment\">//传入分组,默认是Defalut.class</span></span><br><span class=\"line\">    Class&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就和<code>@Validated</code>的分组校验有关了，(<code>@Valid</code>没有定义这个属性，自然也就不支持分组校验）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Default是个接口，只起到标记作用</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> javax.validation.groups;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Default</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以自定义分组来指定需要校验的时机。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义Group类，里面两个接口用作校验(也可以用类，不过和原生的贴合一点比较好)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Group</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">GroupTest1</span>&#123;&#125;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">GroupTest2</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginUserDTO</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//只有分组属于这两个才校验</span></span><br><span class=\"line\">   <span class=\"meta\">@NotBlank(message = &quot;账户不能为空&quot;,groups = &#123;Group.GroupTest1.class, Default.class&#125;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">userName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">   <span class=\"meta\">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getUserName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.userName;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setUserName</span><span class=\"params\">(String userName)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.userName = userName;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getPassword</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.password;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setPassword</span><span class=\"params\">(String password)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.password = password;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//controller</span></span><br><span class=\"line\">\t<span class=\"meta\">@PostMapping(&quot;/login&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResponseResult <span class=\"title function_\">login</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> <span class=\"meta\">@Validated(value = &#123;Group.GroupTest2.class&#125;)</span> LoginUserDTO loginUserDTO)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseResult.success(loginService.login(loginUserDTO.getUserName(),loginUserDTO.getPassword()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不属于分组，不校验userName（其他情况自行尝试</span></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;userName&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;password&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;data&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;登录成功&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;code&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">200</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;msg&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;操作成功&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"2-深入理解-Valid与-Validated\"><a href=\"#2-深入理解-Valid与-Validated\" class=\"headerlink\" title=\"2. 深入理解@Valid与@Validated\"></a>2. 深入理解@Valid与@Validated</h1><p>因为<code>@Valid</code>与<code>@Validated</code>能混合使用，我们可以大胆猜测一下，一定有一个<code>Adapter</code>来承担两者的适配工作，搜搜Valid相关的Adapter，还真有一个。</p>\n<h2 id=\"2-1-SpringValidtorAdapter\"><a href=\"#2-1-SpringValidtorAdapter\" class=\"headerlink\" title=\"2.1 SpringValidtorAdapter\"></a>2.1 SpringValidtorAdapter</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringValidatorAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">SmartValidator</span>, javax.validation.Validator &#123;</span><br><span class=\"line\">    \t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> javax.validation.Validator targetValidator;</span><br><span class=\"line\">    <span class=\"comment\">//没有返回值，重写Spring中Validator的方法</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">validate</span><span class=\"params\">(Object target, Errors errors, Object... validationHints)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.targetValidator != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tprocessConstraintViolations(</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">this</span>.targetValidator.validate(target, asValidationGroups(validationHints)), errors);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//有返回值，重写的javax中Validator的方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; <span class=\"title function_\">validate</span><span class=\"params\">(T object, Class&lt;?&gt;... groups)</span> &#123;</span><br><span class=\"line\">\t\tAssert.state(<span class=\"built_in\">this</span>.targetValidator != <span class=\"literal\">null</span>, <span class=\"string\">&quot;No target Validator set&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.targetValidator.validate(object, groups);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>SpringValidtorAdapter的结构</strong></p>\n<p><img src=\"/2024/08/13/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/Blog/source/_posts/SpringBoot参数校验/image-20240602190311638.png\" alt=\"image-20240602190311638\"></p>\n<p>根据上面结构图和代码，可以看到<code>SpringValidatorAdapter</code>实现了两个不同的<code>validator</code>接口，针对其中核心方法<code>validate()</code>进行了返回值的适配（有点像<code>Runnable</code>和<code> Callable</code>之间的适配）</p>\n<h2 id=\"2-2-具体校验器的获取实现\"><a href=\"#2-2-具体校验器的获取实现\" class=\"headerlink\" title=\"2.2 具体校验器的获取实现\"></a>2.2 具体校验器的获取实现</h2><h3 id=\"2-2-1-ValidatorFactory\"><a href=\"#2-2-1-ValidatorFactory\" class=\"headerlink\" title=\"2.2.1 ValidatorFactory\"></a>2.2.1 ValidatorFactory</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ValidatorFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AutoCloseable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 显然，这个接口是最为重要的</span></span><br><span class=\"line\">\tValidator <span class=\"title function_\">getValidator</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 定义一个新的ValidatorContext验证器上下文，并且和Validator关联上</span></span><br><span class=\"line\">\tValidatorContext <span class=\"title function_\">usingContext</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\tMessageInterpolator <span class=\"title function_\">getMessageInterpolator</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\tTraversableResolver <span class=\"title function_\">getTraversableResolver</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\tConstraintValidatorFactory <span class=\"title function_\">getConstraintValidatorFactory</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\tParameterNameProvider <span class=\"title function_\">getParameterNameProvider</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\tClockProvider <span class=\"title function_\">getClockProvider</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">unwrap</span><span class=\"params\">(Class&lt;T&gt; type)</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 复写AutoCloseable的方法</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ValidatorFactory</code>的实现可以分成两部分，<code>hibernate</code>和<code>Spring</code>实现。</p>\n<h4 id=\"LocalValidatorFactoryBean\"><a href=\"#LocalValidatorFactoryBean\" class=\"headerlink\" title=\"LocalValidatorFactoryBean\"></a>LocalValidatorFactoryBean</h4><p><code>LocalValidatorFactoryBean</code>不仅是<code>ValidatorFactory</code>实现，还是<code>SpringValidAdapter</code>子类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LocalValidatorFactoryBean</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SpringValidatorAdapter</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">implements</span> <span class=\"title class_\">ValidatorFactory</span>, ApplicationContextAware, InitializingBean, DisposableBean &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//重写的InitializingBean中的方法，Bean初始化时会执行</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterPropertiesSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tConfiguration&lt;?&gt; configuration;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ...</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">//根据配置创建工厂，并从工厂里面拿到Validator</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">this</span>.validatorFactory = configuration.buildValidatorFactory();</span><br><span class=\"line\">\t\t\tsetTargetValidator(<span class=\"built_in\">this</span>.validatorFactory.getValidator());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\tcloseMappingStreams(mappingStreams);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ValidatorFactoryImpl\"><a href=\"#ValidatorFactoryImpl\" class=\"headerlink\" title=\"ValidatorFactoryImpl\"></a>ValidatorFactoryImpl</h4><p>在最开始我们导入了校验starter，导入的就有<strong>org.hibernate.validator</strong>相关的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.hibernate.validator.internal.engine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ValidatorFactoryImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">HibernateValidatorFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Validator <span class=\"title function_\">getValidator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> createValidator(</span><br><span class=\"line\">\t\t\t\tconstraintValidatorManager.getDefaultConstraintValidatorFactory(),</span><br><span class=\"line\">\t\t\t\tvalueExtractorManager,</span><br><span class=\"line\">\t\t\t\tvalidatorFactoryScopedContext,</span><br><span class=\"line\">\t\t\t\tmethodValidationConfiguration</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Validator <span class=\"title function_\">createValidator</span><span class=\"params\">(ConstraintValidatorFactory constraintValidatorFactory, </span></span><br><span class=\"line\"><span class=\"params\">                              ValueExtractorManager valueExtractorManager,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\tValidatorFactoryScopedContext validatorFactoryScopedContext,</span></span><br><span class=\"line\"><span class=\"params\">                              MethodValidationConfiguration methodValidationConfiguration)</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"type\">BeanMetaDataManager</span> <span class=\"variable\">beanMetaDataManager</span> <span class=\"operator\">=</span> beanMetaDataManagers.computeIfAbsent(</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">BeanMetaDataManagerKey</span>( validatorFactoryScopedContext.getParameterNameProvider(), </span><br><span class=\"line\">                                           valueExtractorManager, methodValidationConfiguration ),</span><br><span class=\"line\">\t\t\t\tkey -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">BeanMetaDataManager</span>(</span><br><span class=\"line\">\t\t\t\t\t\tconstraintHelper,</span><br><span class=\"line\">\t\t\t\t\t\texecutableHelper,</span><br><span class=\"line\">\t\t\t\t\t\ttypeResolutionHelper,</span><br><span class=\"line\">\t\t\t\t\t\tvalidatorFactoryScopedContext.getParameterNameProvider(),</span><br><span class=\"line\">\t\t\t\t\t\tvalueExtractorManager,</span><br><span class=\"line\">\t\t\t\t\t\tvalidationOrderGenerator,</span><br><span class=\"line\">\t\t\t\t\t\tbuildDataProviders(),</span><br><span class=\"line\">\t\t\t\t\t\tmethodValidationConfiguration</span><br><span class=\"line\">\t\t\t\t)</span><br><span class=\"line\">\t\t );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ValidatorImpl</span>(</span><br><span class=\"line\">\t\t\t\tconstraintValidatorFactory,</span><br><span class=\"line\">\t\t\t\tbeanMetaDataManager,</span><br><span class=\"line\">\t\t\t\tvalueExtractorManager,</span><br><span class=\"line\">\t\t\t\tconstraintValidatorManager,</span><br><span class=\"line\">\t\t\t\tvalidationOrderGenerator,</span><br><span class=\"line\">\t\t\t\tvalidatorFactoryScopedContext</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-ValidatorImpl\"><a href=\"#2-2-2-ValidatorImpl\" class=\"headerlink\" title=\"2.2.2 ValidatorImpl\"></a>2.2.2 ValidatorImpl</h3><p><code>ValidatorImpl</code>是<strong>Hibernate Validator</strong>提供的唯一校验器实现，校验过程很复杂，了解是哪个类就行，感兴趣可以深度剖析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ValidatorImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Validator</span>, ExecutableValidator &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Collection&lt;Class&lt;?&gt;&gt; DEFAULT_GROUPS = Collections.&lt;Class&lt;?&gt;&gt;singletonList( Default.class );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 分组Group校验的顺序问题</span></span><br><span class=\"line\">\t<span class=\"comment\">// 若依赖于校验顺序，可用使用@GroupSequence注解来控制Group顺序</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> ValidationOrderGenerator validationOrderGenerator;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConstraintValidatorFactory constraintValidatorFactory;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; <span class=\"title function_\">validate</span><span class=\"params\">(T object, Class&lt;?&gt;... groups)</span> &#123;</span><br><span class=\"line\">\t\tContracts.assertNotNull( object, MESSAGES.validatedObjectMustNotBeNull() );</span><br><span class=\"line\">        <span class=\"comment\">// groups里面的内容不能有null</span></span><br><span class=\"line\">\t\tsanityCheckGroups( groups );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">\t\tClass&lt;T&gt; rootBeanClass = (Class&lt;T&gt;) object.getClass();</span><br><span class=\"line\">\t\tBeanMetaData&lt;T&gt; rootBeanMetaData = beanMetaDataManager.getBeanMetaData( rootBeanClass );</span><br><span class=\"line\">        <span class=\"comment\">//没有约束直接返回</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( !rootBeanMetaData.hasConstraints() ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Collections.emptySet();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\tBaseBeanValidationContext&lt;T&gt; validationContext = getValidationContextBuilder().forValidate( rootBeanClass, rootBeanMetaData, object );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">ValidationOrder</span> <span class=\"variable\">validationOrder</span> <span class=\"operator\">=</span> determineGroupValidationOrder( groups );</span><br><span class=\"line\">         <span class=\"comment\">// ValueContext一个实例用于收集所有相关信息，以验证单个类、属性或方法调用。</span></span><br><span class=\"line\">\t\tBeanValueContext&lt;?, Object&gt; valueContext = ValueContexts.getLocalExecutionContextForBean(</span><br><span class=\"line\">\t\t\t\tvalidatorScopedContext.getParameterNameProvider(),</span><br><span class=\"line\">\t\t\t\tobject,</span><br><span class=\"line\">\t\t\t\tvalidationContext.getRootBeanMetaData(),</span><br><span class=\"line\">\t\t\t\tPathImpl.createRootPath()</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">        <span class=\"comment\">// 返回的是失败的消息对象：ConstraintViolation  它是被存储在ValidationContext里的</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> validateInContext( validationContext, valueContext, validationOrder );</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-异常信息\"><a href=\"#3-异常信息\" class=\"headerlink\" title=\"3. 异常信息\"></a>3. 异常信息</h1><h2 id=\"3-1-说明\"><a href=\"#3-1-说明\" class=\"headerlink\" title=\"3.1 说明\"></a>3.1 说明</h2><p>参数校验失败抛出的异常时<code>MethodArgumentNotValidException</code>，不过建议捕获<code>BindException</code>，因为<code>MethodArgumentNotValidException</code>是对<code>BindResult</code>的封装，只能通过<code>getMessage()</code>获取封装好的信息，不够灵活</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//看的出来，确实很简单</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MethodArgumentNotValidException</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BindException</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MethodParameter parameter;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MethodArgumentNotValidException</span><span class=\"params\">(MethodParameter parameter, BindingResult bindingResult)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(bindingResult);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.parameter = parameter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> MethodParameter <span class=\"title function_\">getParameter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.parameter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> (<span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"string\">&quot;Validation failed for argument [&quot;</span>)).append(<span class=\"built_in\">this</span>.parameter.getParameterIndex()).append(<span class=\"string\">&quot;] in &quot;</span>).append(<span class=\"built_in\">this</span>.parameter.getExecutable().toGenericString());</span><br><span class=\"line\">        <span class=\"type\">BindingResult</span> <span class=\"variable\">bindingResult</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getBindingResult();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bindingResult.getErrorCount() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            sb.append(<span class=\"string\">&quot; with &quot;</span>).append(bindingResult.getErrorCount()).append(<span class=\"string\">&quot; errors&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;: &quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Iterator</span> <span class=\"variable\">var3</span> <span class=\"operator\">=</span> bindingResult.getAllErrors().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(var3.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">ObjectError</span> <span class=\"variable\">error</span> <span class=\"operator\">=</span> (ObjectError)var3.next();</span><br><span class=\"line\">            sb.append(<span class=\"string\">&#x27;[&#x27;</span>).append(error).append(<span class=\"string\">&quot;] &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-BindException\"><a href=\"#3-2-BindException\" class=\"headerlink\" title=\"3.2 BindException\"></a>3.2 BindException</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//BindException里面主要是封装了一个BindResult</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BindException</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BindingResult</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BindingResult bindingResult;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BindException</span><span class=\"params\">(BindingResult bindingResult)</span> &#123;</span><br><span class=\"line\">        Assert.notNull(bindingResult, <span class=\"string\">&quot;BindingResult must not be null&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.bindingResult = bindingResult;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BindException</span><span class=\"params\">(Object target, String objectName)</span> &#123;</span><br><span class=\"line\">        Assert.notNull(target, <span class=\"string\">&quot;Target object must not be null&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.bindingResult = <span class=\"keyword\">new</span> <span class=\"title class_\">BeanPropertyBindingResult</span>(target, objectName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-1-BindResult\"><a href=\"#3-2-1-BindResult\" class=\"headerlink\" title=\"3.2.1 BindResult\"></a>3.2.1 BindResult</h3><p>BindResult是一个接口，里面没有什么特别的东西。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BindingResult</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Errors</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">MODEL_KEY_PREFIX</span> <span class=\"operator\">=</span> BindingResult.class.getName() + <span class=\"string\">&quot;.&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    Object <span class=\"title function_\">getTarget</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, Object&gt; <span class=\"title function_\">getModel</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    Object <span class=\"title function_\">getRawFieldValue</span><span class=\"params\">(String field)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    PropertyEditor <span class=\"title function_\">findEditor</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> String field, <span class=\"meta\">@Nullable</span> Class&lt;?&gt; valueType)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    PropertyEditorRegistry <span class=\"title function_\">getPropertyEditorRegistry</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] resolveMessageCodes(String errorCode);</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] resolveMessageCodes(String errorCode, String field);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">addError</span><span class=\"params\">(ObjectError error)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recordFieldValue</span><span class=\"params\">(String field, Class&lt;?&gt; type, <span class=\"meta\">@Nullable</span> Object value)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recordSuppressedField</span><span class=\"params\">(String field)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> String[] getSuppressedFields() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2-AbstractBindingResult\"><a href=\"#3-2-2-AbstractBindingResult\" class=\"headerlink\" title=\"3.2.2 AbstractBindingResult\"></a>3.2.2 AbstractBindingResult</h3><p>一般来说抽象类都是接口的基本实现，BindingResult也不例外</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractBindingResult</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractErrors</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BindingResult</span>, Serializable &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String objectName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">MessageCodesResolver</span> <span class=\"variable\">messageCodesResolver</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultMessageCodesResolver</span>();</span><br><span class=\"line\">    <span class=\"comment\">//储存错误信息</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;ObjectError&gt; errors = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Class&lt;?&gt;&gt; fieldTypes = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; fieldValues = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;String&gt; suppressedFields = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ObjectError\"><a href=\"#ObjectError\" class=\"headerlink\" title=\"ObjectError\"></a>ObjectError</h4><ol>\n<li><p>本体</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObjectError</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DefaultMessageSourceResolvable</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//校验失败的对象名，比如shoppingCart</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String objectName;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Object source;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t...       </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>子类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ObjectError的子类，获取ObjectError可以强转为该类 (具体实现是FieldError的子类ViolationFieldError）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FieldError</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ObjectError</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//校验失败的地方，比如itemList[1].name</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String field;</span><br><span class=\"line\">    <span class=\"comment\">//校验失败的值，比如-1</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object rejectedValue;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> bindingFailure;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>父类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ObjectError的父类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DefaultMessageSourceResolvable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MessageSourceResolvable</span>, Serializable &#123;</span><br><span class=\"line\">    <span class=\"comment\">//存放详细的校验类型信息</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String[] codes;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] arguments;</span><br><span class=\"line\">    <span class=\"comment\">//注解里面传的Message到这了</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String defaultMessage;</span><br><span class=\"line\">    </span><br><span class=\"line\"> \t...   </span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>Tips</strong>：可以自行打印观察值，推测存放信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ExceptionHandler(BindException.class)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> ResponseResult <span class=\"title function_\">bindExceptionHandler</span><span class=\"params\">(BindException e)</span> &#123;</span><br><span class=\"line\">       List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">       <span class=\"type\">BindingResult</span> <span class=\"variable\">bindingResult</span> <span class=\"operator\">=</span> e.getBindingResult();</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (ObjectError objectError : bindingResult.getAllErrors()) &#123;</span><br><span class=\"line\">           <span class=\"type\">FieldError</span> <span class=\"variable\">fieldError</span> <span class=\"operator\">=</span> (FieldError) objectError;</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;--------------&quot;</span>);</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;codes&quot;</span>);</span><br><span class=\"line\">           Arrays.stream(fieldError.getCodes()).forEach(System.out::println);</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;--------------&quot;</span>);</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;code&quot;</span>);</span><br><span class=\"line\">           System.out.println(fieldError.getCode());</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;--------------&quot;</span>);</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;ObjectName&quot;</span>);</span><br><span class=\"line\">           System.out.println(fieldError.getObjectName());</span><br><span class=\"line\">           logger.error(<span class=\"string\">&quot;参数 &#123;&#125; ,&#123;&#125; 校验错误：&#123;&#125;&quot;</span>, fieldError.getField(), fieldError.getRejectedValue(), fieldError.getDefaultMessage());</span><br><span class=\"line\">           list.add(fieldError.getDefaultMessage());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> ResponseResult.error(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),list.toString());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"length":3221,"excerpt":"<p><strong>spring-boot-starter-validation</strong>相关的参数校验</p>","more":"<h1 id=\"1-参数校验\"><a href=\"#1-参数校验\" class=\"headerlink\" title=\"1. 参数校验\"></a>1. 参数校验</h1><h2 id=\"1-1-Spring参数校验快速开始\"><a href=\"#1-1-Spring参数校验快速开始\" class=\"headerlink\" title=\"1.1 Spring参数校验快速开始\"></a>1.1 Spring参数校验快速开始</h2><h3 id=\"1-1-1-导入依赖\"><a href=\"#1-1-1-导入依赖\" class=\"headerlink\" title=\"1.1.1 导入依赖\"></a>1.1.1 导入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-validation<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-2-使用\"><a href=\"#1-1-2-使用\" class=\"headerlink\" title=\"1.1.2 使用\"></a>1.1.2 使用</h3><p>参数校验实操分两步</p>\n<ul>\n<li>在Controller层将要校验的参数上标注<code>@Vaild</code>注解</li>\n<li>在要校验对象属性加上具体的约束</li>\n</ul>\n<p><strong>例子</strong>：</p>\n<ol>\n<li><p>我要校验登录的用户名和密码不能为空，那么我就在参数loginUserDTO前加上<code>@valid</code>注解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">testVaildController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LoginService loginService;</span><br><span class=\"line\">    <span class=\"meta\">@PostMapping(&quot;/login&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResponseResult <span class=\"title function_\">login</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> <span class=\"meta\">@Valid</span> LoginUserDTO loginUserDTO)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseResult.success(loginService.login(loginUserDTO.getUserName(),loginUserDTO.getPassword()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后在LoginUserDTO类中加上具体的约束</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginUserDTO</span> &#123;</span><br><span class=\"line\">   <span class=\"meta\">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">userName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">   <span class=\"meta\">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getUserName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.userName;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setUserName</span><span class=\"params\">(String userName)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.userName = userName;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getPassword</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.password;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setPassword</span><span class=\"params\">(String password)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.password = password;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样参数校验就可以生效了，测试接口结果如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;timestamp&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;2024-05-24T09:15:58.364+00:00&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;status&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">400</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;error&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Bad Request&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;path&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/login&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>异常捕获</p>\n<p>为了<strong>更有效的传递信息</strong>以及进行<strong>结果统一返回</strong>、<strong>日志记录</strong>等操作，我们通常会定义异常处理器来统一处理参数校验的异常（BindException是什么见下文异常信息）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">GlobalExceptionHandler</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Logger</span> <span class=\"variable\">logger</span> <span class=\"operator\">=</span> LoggerFactory.getLogger(<span class=\"string\">&quot;GlobalExceptionHandler&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//抛出的异常是MethodArgumentNotValidException,BindException是它的父类</span></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler(BindException.class)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResponseResult <span class=\"title function_\">bindExceptionHandler</span><span class=\"params\">(BindException e)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//具体返回什么据情况而定，这里直接返回所有defalutMessage(写在约束注解里的信息)了</span></span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">BindingResult</span> <span class=\"variable\">bindingResult</span> <span class=\"operator\">=</span> e.getBindingResult();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ObjectError objectError : bindingResult.getAllErrors()) &#123;</span><br><span class=\"line\">            <span class=\"type\">FieldError</span> <span class=\"variable\">fieldError</span> <span class=\"operator\">=</span> (FieldError) objectError;</span><br><span class=\"line\">            <span class=\"comment\">//这里直接使用默认appender打印日志在控制台了，真实线上可以同步到本地、ELK等地方</span></span><br><span class=\"line\">            logger.error(<span class=\"string\">&quot;参数 &#123;&#125; ,&#123;&#125; 校验错误：&#123;&#125;&quot;</span>, fieldError.getField(), fieldError.getRejectedValue(), fieldError.getDefaultMessage());</span><br><span class=\"line\">            list.add(fieldError.getDefaultMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseResult.error(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),list.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>测试数据与结果如下</strong>:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;userName&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;password&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;data&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">null</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;code&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">500</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;msg&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;[用户名不能为空, 密码不能为空]&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-常用的校验注解\"><a href=\"#1-2-常用的校验注解\" class=\"headerlink\" title=\"1.2 常用的校验注解\"></a>1.2 常用的校验注解</h2><ol>\n<li><p><strong>控制检查</strong></p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>@NotBlank</code></td>\n<td>用于字符串，字符串不能为null也不能为空</td>\n</tr>\n<tr>\n<td><code>@NotEmpty</code></td>\n<td>字符串同上，集合不能为空，必须有元素</td>\n</tr>\n<tr>\n<td><code>@NotNull</code></td>\n<td>不能为null</td>\n</tr>\n<tr>\n<td><code>@Null</code></td>\n<td>必须为null</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>数值检查</strong></p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>@DecimalMax(value)</code></td>\n<td>被标注元素必须是数字，必须小于等于value</td>\n</tr>\n<tr>\n<td><code>@DecimalMin(value)</code></td>\n<td>被标注元素必须是数字，必须大于等于value</td>\n</tr>\n<tr>\n<td><code>@Digits(integer,fraction)</code></td>\n<td>被标注的元素必须为数字，其值的整数部分精度为 <code>integer</code>，小数部分精度为 <code>fraction</code></td>\n</tr>\n<tr>\n<td><code>@Positive</code></td>\n<td>被标注的元素必须为正数</td>\n</tr>\n<tr>\n<td><code>@PositiveOrZero</code></td>\n<td>被标注的元素必须为正数或 0</td>\n</tr>\n<tr>\n<td><code>@Max(value)</code></td>\n<td>被标注的元素必须小于等于指定的值</td>\n</tr>\n<tr>\n<td><code>@Min(value)</code></td>\n<td>被标注的元素必须大于等于指定的值</td>\n</tr>\n<tr>\n<td><code>@negative</code></td>\n<td>被标注的元素必须为负数</td>\n</tr>\n<tr>\n<td><code>NegativeOrZero</code></td>\n<td>被标注的元素必须为负数或 0</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>Boolean检查</strong>（不太用的到的样子）</p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@AssertFalse</td>\n<td>被标注的元素必须值为 <code>false</code></td>\n</tr>\n<tr>\n<td>@AssertTrue</td>\n<td>被标注的元素必须值为 <code>true</code></td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>长度检查</strong></p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@Size(min,max)</td>\n<td>被标注的元素长度必须在 <code>min</code> 和 <code>max</code> 之间，可以是 String、Collection、Map、数组</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>日期检查</strong></p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>@Future</code></td>\n<td>被标注的元素必须是一个将来的日期</td>\n</tr>\n<tr>\n<td><code>@FutureOrPresent</code></td>\n<td>被标注的元素必须是现在或者将来的日期</td>\n</tr>\n<tr>\n<td><code>@Past</code></td>\n<td>被标注的元素必须是一个过去的日期</td>\n</tr>\n<tr>\n<td><code>@PastOrPresent</code></td>\n<td>被标注的元素必须是现在或者过去的日期</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><strong>其他</strong></p>\n<table>\n<thead>\n<tr>\n<th>注解</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>@Email</td>\n<td>被标注的元素必须是电子邮箱地址</td>\n</tr>\n<tr>\n<td>@Pattern(regexp)</td>\n<td>被标注的元素必须符合正则表达式</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h2 id=\"1-3-Vaild与-Vaildated\"><a href=\"#1-3-Vaild与-Vaildated\" class=\"headerlink\" title=\"1.3 @Vaild与@Vaildated\"></a>1.3 @Vaild与@Vaildated</h2><p>在第一步加注解的时候，可以明显的看到还有一个可能也是参数校验的注解<code>@Validated</code>，把<code>@Vaild</code>换成<code>@Validated</code>，我们惊奇的发现参数校验也能正常的工作，接下来我们就来看看这两注解之间的联系与区别。</p>\n<h3 id=\"1-3-1-来源\"><a href=\"#1-3-1-来源\" class=\"headerlink\" title=\"1.3.1 来源\"></a>1.3.1 来源</h3><p>一个是<strong>Spring</strong>的，一个是<strong>javax</strong>，了解过<code>@Autowired</code>与<code>@Resource</code>区别的老哥可能很快就反应过来了，就像这两个注解一样。一个是JSR规范的，一个是Spring规范的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.validation.annotation.Validated;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.validation.Valid;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-2-定义区别\"><a href=\"#1-3-2-定义区别\" class=\"headerlink\" title=\"1.3.2 定义区别\"></a>1.3.2 定义区别</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Validated &#123;</span><br><span class=\"line\">    Class&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Valid &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>差异主要有两点</strong>：</p>\n<ul>\n<li><p>能标注的地方</p>\n<p>可以看到<code>@Valid</code>注解除了能标注在<strong>类、方法、方法参数</strong>上还能标注在<strong>类里面属性、任何使用类型的地方</strong>。</p>\n</li>\n<li><p>属性</p>\n<p><code>Validated</code>注解里面比<code>Valid</code>多了一个value</p>\n</li>\n</ul>\n<p>接下来我们来结合定义区别看看它们的功能差异</p>\n<h3 id=\"1-3-3-功能差异\"><a href=\"#1-3-3-功能差异\" class=\"headerlink\" title=\"1.3.3 功能差异\"></a>1.3.3 功能差异</h3><h4 id=\"嵌套校验\"><a href=\"#嵌套校验\" class=\"headerlink\" title=\"嵌套校验\"></a>嵌套校验</h4><p>上文校验的时候我们在类属性上加上相关的限制注解就可以了，但是如果属性是一个类的实例，我们想校验这个作为属性的实例里面的字段，我们就只能使用<code>@Vaild</code>加在属性上，标注这是需要校验的属性。**<code>@Validated</code>不能标注在属性上<strong>，自然也就</strong>不支持嵌套校验**</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/buy&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResponseResult <span class=\"title function_\">buy</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> <span class=\"meta\">@Valid</span> ShoppingCart shoppingCart)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseResult.success(payService.pay(shoppingCart.getUserId(),shoppingCart.getItemList()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//购物车类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ShoppingCart</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Positive(message = &quot;用户id必须大于0&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long userId;</span><br><span class=\"line\">    <span class=\"meta\">@NotEmpty(message = &quot;不能为空&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Valid</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Item&gt; itemList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">getUserId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setUserId</span><span class=\"params\">(Long userId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.userId = userId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Item&gt; <span class=\"title function_\">getItemList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> itemList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setItemList</span><span class=\"params\">(List&lt;Item&gt; itemList)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.itemList = itemList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//物品类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Item</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Positive(message = &quot;价格必须大于0&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BigDecimal price;</span><br><span class=\"line\">    <span class=\"meta\">@NotBlank(message = &quot;物品名不能为空&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Positive(message = &quot;数量必须大于0&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> number;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> BigDecimal <span class=\"title function_\">getPrice</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setPrice</span><span class=\"params\">(BigDecimal price)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.price = price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setName</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getNumber</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setNumber</span><span class=\"params\">(<span class=\"type\">int</span> number)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.number = number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...服务自行模拟</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;userId&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;itemList&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;price&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;142.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;小风车&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;number&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;price&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;-2&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;number&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">-1</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;data&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">null</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;code&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">500</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;msg&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;[数量必须大于0, 价格必须大于0, 物品名不能为空]&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到校验成功了，当然这里的异常捕获逻辑比较简单，具体生产环境里可以将返回具体的校验信息，进行更清晰的信息提示。</p>\n<p><strong>杂记</strong>：</p>\n<ul>\n<li><p><code>@Valid</code>作用域比较广还可以标注在许多意向不到的位置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//比如，(可以自行观察一下运行结果,都是可以正常校验的)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>  List&lt;<span class=\"meta\">@Valid</span> Item&gt; itemList;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"meta\">@Valid</span> List&lt; Item&gt; itemList;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>@Valid</code>与<code>@Validated</code>可以混用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//controller里面注解改为@Validated依然可以生效 </span></span><br><span class=\"line\"><span class=\"meta\">@PostMapping(&quot;/buy&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  ResponseResult  <span class=\"title function_\">buy</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> <span class=\"meta\">@Validated</span> ShoppingCart  shoppingCart)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseResult.success(payService.pay(shoppingCart.getUserId(),shoppingCart.getItemList()));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>消息的顺序不固定</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;data&quot;</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;code&quot;</span>: <span class=\"number\">500</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;msg&quot;</span>: <span class=\"string\">&quot;[数量必须大于0, 价格必须大于0, 物品名不能为空]&quot;</span> <span class=\"comment\">//这三条消息打印的顺序是不固定的</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"分组校验\"><a href=\"#分组校验\" class=\"headerlink\" title=\"分组校验\"></a>分组校验</h4><p>上面看注解代码的时候可以明显注意到<code>@Validated</code>注解里面有个<code>value</code>属性。**<code>@Valid</code>没有value属性<strong>，自然也就</strong>不支持分组校验**</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Validated &#123;</span><br><span class=\"line\">    <span class=\"comment\">//传入分组,默认是Defalut.class</span></span><br><span class=\"line\">    Class&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就和<code>@Validated</code>的分组校验有关了，(<code>@Valid</code>没有定义这个属性，自然也就不支持分组校验）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Default是个接口，只起到标记作用</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> javax.validation.groups;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Default</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以自定义分组来指定需要校验的时机。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义Group类，里面两个接口用作校验(也可以用类，不过和原生的贴合一点比较好)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Group</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">GroupTest1</span>&#123;&#125;</span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">GroupTest2</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>测试</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginUserDTO</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//只有分组属于这两个才校验</span></span><br><span class=\"line\">   <span class=\"meta\">@NotBlank(message = &quot;账户不能为空&quot;,groups = &#123;Group.GroupTest1.class, Default.class&#125;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">userName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">   <span class=\"meta\">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"type\">String</span> <span class=\"variable\">password</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getUserName</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.userName;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setUserName</span><span class=\"params\">(String userName)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.userName = userName;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> String <span class=\"title function_\">getPassword</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.password;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setPassword</span><span class=\"params\">(String password)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.password = password;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//controller</span></span><br><span class=\"line\">\t<span class=\"meta\">@PostMapping(&quot;/login&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ResponseResult <span class=\"title function_\">login</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> <span class=\"meta\">@Validated(value = &#123;Group.GroupTest2.class&#125;)</span> LoginUserDTO loginUserDTO)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ResponseResult.success(loginService.login(loginUserDTO.getUserName(),loginUserDTO.getPassword()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>结果</strong>：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不属于分组，不校验userName（其他情况自行尝试</span></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;userName&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;password&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;data&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;登录成功&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;code&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">200</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;msg&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;操作成功&quot;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"2-深入理解-Valid与-Validated\"><a href=\"#2-深入理解-Valid与-Validated\" class=\"headerlink\" title=\"2. 深入理解@Valid与@Validated\"></a>2. 深入理解@Valid与@Validated</h1><p>因为<code>@Valid</code>与<code>@Validated</code>能混合使用，我们可以大胆猜测一下，一定有一个<code>Adapter</code>来承担两者的适配工作，搜搜Valid相关的Adapter，还真有一个。</p>\n<h2 id=\"2-1-SpringValidtorAdapter\"><a href=\"#2-1-SpringValidtorAdapter\" class=\"headerlink\" title=\"2.1 SpringValidtorAdapter\"></a>2.1 SpringValidtorAdapter</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringValidatorAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">SmartValidator</span>, javax.validation.Validator &#123;</span><br><span class=\"line\">    \t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> javax.validation.Validator targetValidator;</span><br><span class=\"line\">    <span class=\"comment\">//没有返回值，重写Spring中Validator的方法</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">validate</span><span class=\"params\">(Object target, Errors errors, Object... validationHints)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.targetValidator != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tprocessConstraintViolations(</span><br><span class=\"line\">\t\t\t\t\t<span class=\"built_in\">this</span>.targetValidator.validate(target, asValidationGroups(validationHints)), errors);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//有返回值，重写的javax中Validator的方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; <span class=\"title function_\">validate</span><span class=\"params\">(T object, Class&lt;?&gt;... groups)</span> &#123;</span><br><span class=\"line\">\t\tAssert.state(<span class=\"built_in\">this</span>.targetValidator != <span class=\"literal\">null</span>, <span class=\"string\">&quot;No target Validator set&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.targetValidator.validate(object, groups);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>SpringValidtorAdapter的结构</strong></p>\n<p><img src=\"/2024/08/13/SpringBoot%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/Blog/source/_posts/SpringBoot参数校验/image-20240602190311638.png\" alt=\"image-20240602190311638\"></p>\n<p>根据上面结构图和代码，可以看到<code>SpringValidatorAdapter</code>实现了两个不同的<code>validator</code>接口，针对其中核心方法<code>validate()</code>进行了返回值的适配（有点像<code>Runnable</code>和<code> Callable</code>之间的适配）</p>\n<h2 id=\"2-2-具体校验器的获取实现\"><a href=\"#2-2-具体校验器的获取实现\" class=\"headerlink\" title=\"2.2 具体校验器的获取实现\"></a>2.2 具体校验器的获取实现</h2><h3 id=\"2-2-1-ValidatorFactory\"><a href=\"#2-2-1-ValidatorFactory\" class=\"headerlink\" title=\"2.2.1 ValidatorFactory\"></a>2.2.1 ValidatorFactory</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ValidatorFactory</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AutoCloseable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 显然，这个接口是最为重要的</span></span><br><span class=\"line\">\tValidator <span class=\"title function_\">getValidator</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 定义一个新的ValidatorContext验证器上下文，并且和Validator关联上</span></span><br><span class=\"line\">\tValidatorContext <span class=\"title function_\">usingContext</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\tMessageInterpolator <span class=\"title function_\">getMessageInterpolator</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\tTraversableResolver <span class=\"title function_\">getTraversableResolver</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\tConstraintValidatorFactory <span class=\"title function_\">getConstraintValidatorFactory</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\tParameterNameProvider <span class=\"title function_\">getParameterNameProvider</span><span class=\"params\">()</span>;</span><br><span class=\"line\">\tClockProvider <span class=\"title function_\">getClockProvider</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"title function_\">unwrap</span><span class=\"params\">(Class&lt;T&gt; type)</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 复写AutoCloseable的方法</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">close</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ValidatorFactory</code>的实现可以分成两部分，<code>hibernate</code>和<code>Spring</code>实现。</p>\n<h4 id=\"LocalValidatorFactoryBean\"><a href=\"#LocalValidatorFactoryBean\" class=\"headerlink\" title=\"LocalValidatorFactoryBean\"></a>LocalValidatorFactoryBean</h4><p><code>LocalValidatorFactoryBean</code>不仅是<code>ValidatorFactory</code>实现，还是<code>SpringValidAdapter</code>子类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LocalValidatorFactoryBean</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">SpringValidatorAdapter</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">implements</span> <span class=\"title class_\">ValidatorFactory</span>, ApplicationContextAware, InitializingBean, DisposableBean &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//重写的InitializingBean中的方法，Bean初始化时会执行</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"meta\">@SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterPropertiesSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\tConfiguration&lt;?&gt; configuration;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ...</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">//根据配置创建工厂，并从工厂里面拿到Validator</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">this</span>.validatorFactory = configuration.buildValidatorFactory();</span><br><span class=\"line\">\t\t\tsetTargetValidator(<span class=\"built_in\">this</span>.validatorFactory.getValidator());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t\tcloseMappingStreams(mappingStreams);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ValidatorFactoryImpl\"><a href=\"#ValidatorFactoryImpl\" class=\"headerlink\" title=\"ValidatorFactoryImpl\"></a>ValidatorFactoryImpl</h4><p>在最开始我们导入了校验starter，导入的就有<strong>org.hibernate.validator</strong>相关的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.hibernate.validator.internal.engine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ValidatorFactoryImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">HibernateValidatorFactory</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Validator <span class=\"title function_\">getValidator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> createValidator(</span><br><span class=\"line\">\t\t\t\tconstraintValidatorManager.getDefaultConstraintValidatorFactory(),</span><br><span class=\"line\">\t\t\t\tvalueExtractorManager,</span><br><span class=\"line\">\t\t\t\tvalidatorFactoryScopedContext,</span><br><span class=\"line\">\t\t\t\tmethodValidationConfiguration</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Validator <span class=\"title function_\">createValidator</span><span class=\"params\">(ConstraintValidatorFactory constraintValidatorFactory, </span></span><br><span class=\"line\"><span class=\"params\">                              ValueExtractorManager valueExtractorManager,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\tValidatorFactoryScopedContext validatorFactoryScopedContext,</span></span><br><span class=\"line\"><span class=\"params\">                              MethodValidationConfiguration methodValidationConfiguration)</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\t<span class=\"type\">BeanMetaDataManager</span> <span class=\"variable\">beanMetaDataManager</span> <span class=\"operator\">=</span> beanMetaDataManagers.computeIfAbsent(</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">new</span> <span class=\"title class_\">BeanMetaDataManagerKey</span>( validatorFactoryScopedContext.getParameterNameProvider(), </span><br><span class=\"line\">                                           valueExtractorManager, methodValidationConfiguration ),</span><br><span class=\"line\">\t\t\t\tkey -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">BeanMetaDataManager</span>(</span><br><span class=\"line\">\t\t\t\t\t\tconstraintHelper,</span><br><span class=\"line\">\t\t\t\t\t\texecutableHelper,</span><br><span class=\"line\">\t\t\t\t\t\ttypeResolutionHelper,</span><br><span class=\"line\">\t\t\t\t\t\tvalidatorFactoryScopedContext.getParameterNameProvider(),</span><br><span class=\"line\">\t\t\t\t\t\tvalueExtractorManager,</span><br><span class=\"line\">\t\t\t\t\t\tvalidationOrderGenerator,</span><br><span class=\"line\">\t\t\t\t\t\tbuildDataProviders(),</span><br><span class=\"line\">\t\t\t\t\t\tmethodValidationConfiguration</span><br><span class=\"line\">\t\t\t\t)</span><br><span class=\"line\">\t\t );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ValidatorImpl</span>(</span><br><span class=\"line\">\t\t\t\tconstraintValidatorFactory,</span><br><span class=\"line\">\t\t\t\tbeanMetaDataManager,</span><br><span class=\"line\">\t\t\t\tvalueExtractorManager,</span><br><span class=\"line\">\t\t\t\tconstraintValidatorManager,</span><br><span class=\"line\">\t\t\t\tvalidationOrderGenerator,</span><br><span class=\"line\">\t\t\t\tvalidatorFactoryScopedContext</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-ValidatorImpl\"><a href=\"#2-2-2-ValidatorImpl\" class=\"headerlink\" title=\"2.2.2 ValidatorImpl\"></a>2.2.2 ValidatorImpl</h3><p><code>ValidatorImpl</code>是<strong>Hibernate Validator</strong>提供的唯一校验器实现，校验过程很复杂，了解是哪个类就行，感兴趣可以深度剖析</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ValidatorImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Validator</span>, ExecutableValidator &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Collection&lt;Class&lt;?&gt;&gt; DEFAULT_GROUPS = Collections.&lt;Class&lt;?&gt;&gt;singletonList( Default.class );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 分组Group校验的顺序问题</span></span><br><span class=\"line\">\t<span class=\"comment\">// 若依赖于校验顺序，可用使用@GroupSequence注解来控制Group顺序</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> ValidationOrderGenerator validationOrderGenerator;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConstraintValidatorFactory constraintValidatorFactory;</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; <span class=\"title function_\">validate</span><span class=\"params\">(T object, Class&lt;?&gt;... groups)</span> &#123;</span><br><span class=\"line\">\t\tContracts.assertNotNull( object, MESSAGES.validatedObjectMustNotBeNull() );</span><br><span class=\"line\">        <span class=\"comment\">// groups里面的内容不能有null</span></span><br><span class=\"line\">\t\tsanityCheckGroups( groups );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">\t\tClass&lt;T&gt; rootBeanClass = (Class&lt;T&gt;) object.getClass();</span><br><span class=\"line\">\t\tBeanMetaData&lt;T&gt; rootBeanMetaData = beanMetaDataManager.getBeanMetaData( rootBeanClass );</span><br><span class=\"line\">        <span class=\"comment\">//没有约束直接返回</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ( !rootBeanMetaData.hasConstraints() ) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Collections.emptySet();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">\t\tBaseBeanValidationContext&lt;T&gt; validationContext = getValidationContextBuilder().forValidate( rootBeanClass, rootBeanMetaData, object );</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">ValidationOrder</span> <span class=\"variable\">validationOrder</span> <span class=\"operator\">=</span> determineGroupValidationOrder( groups );</span><br><span class=\"line\">         <span class=\"comment\">// ValueContext一个实例用于收集所有相关信息，以验证单个类、属性或方法调用。</span></span><br><span class=\"line\">\t\tBeanValueContext&lt;?, Object&gt; valueContext = ValueContexts.getLocalExecutionContextForBean(</span><br><span class=\"line\">\t\t\t\tvalidatorScopedContext.getParameterNameProvider(),</span><br><span class=\"line\">\t\t\t\tobject,</span><br><span class=\"line\">\t\t\t\tvalidationContext.getRootBeanMetaData(),</span><br><span class=\"line\">\t\t\t\tPathImpl.createRootPath()</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">        <span class=\"comment\">// 返回的是失败的消息对象：ConstraintViolation  它是被存储在ValidationContext里的</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> validateInContext( validationContext, valueContext, validationOrder );</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-异常信息\"><a href=\"#3-异常信息\" class=\"headerlink\" title=\"3. 异常信息\"></a>3. 异常信息</h1><h2 id=\"3-1-说明\"><a href=\"#3-1-说明\" class=\"headerlink\" title=\"3.1 说明\"></a>3.1 说明</h2><p>参数校验失败抛出的异常时<code>MethodArgumentNotValidException</code>，不过建议捕获<code>BindException</code>，因为<code>MethodArgumentNotValidException</code>是对<code>BindResult</code>的封装，只能通过<code>getMessage()</code>获取封装好的信息，不够灵活</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//看的出来，确实很简单</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MethodArgumentNotValidException</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">BindException</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MethodParameter parameter;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MethodArgumentNotValidException</span><span class=\"params\">(MethodParameter parameter, BindingResult bindingResult)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(bindingResult);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.parameter = parameter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> MethodParameter <span class=\"title function_\">getParameter</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.parameter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getMessage</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> (<span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>(<span class=\"string\">&quot;Validation failed for argument [&quot;</span>)).append(<span class=\"built_in\">this</span>.parameter.getParameterIndex()).append(<span class=\"string\">&quot;] in &quot;</span>).append(<span class=\"built_in\">this</span>.parameter.getExecutable().toGenericString());</span><br><span class=\"line\">        <span class=\"type\">BindingResult</span> <span class=\"variable\">bindingResult</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.getBindingResult();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bindingResult.getErrorCount() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            sb.append(<span class=\"string\">&quot; with &quot;</span>).append(bindingResult.getErrorCount()).append(<span class=\"string\">&quot; errors&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;: &quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Iterator</span> <span class=\"variable\">var3</span> <span class=\"operator\">=</span> bindingResult.getAllErrors().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(var3.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">ObjectError</span> <span class=\"variable\">error</span> <span class=\"operator\">=</span> (ObjectError)var3.next();</span><br><span class=\"line\">            sb.append(<span class=\"string\">&#x27;[&#x27;</span>).append(error).append(<span class=\"string\">&quot;] &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-BindException\"><a href=\"#3-2-BindException\" class=\"headerlink\" title=\"3.2 BindException\"></a>3.2 BindException</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//BindException里面主要是封装了一个BindResult</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BindException</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Exception</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BindingResult</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BindingResult bindingResult;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BindException</span><span class=\"params\">(BindingResult bindingResult)</span> &#123;</span><br><span class=\"line\">        Assert.notNull(bindingResult, <span class=\"string\">&quot;BindingResult must not be null&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.bindingResult = bindingResult;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">BindException</span><span class=\"params\">(Object target, String objectName)</span> &#123;</span><br><span class=\"line\">        Assert.notNull(target, <span class=\"string\">&quot;Target object must not be null&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.bindingResult = <span class=\"keyword\">new</span> <span class=\"title class_\">BeanPropertyBindingResult</span>(target, objectName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-1-BindResult\"><a href=\"#3-2-1-BindResult\" class=\"headerlink\" title=\"3.2.1 BindResult\"></a>3.2.1 BindResult</h3><p>BindResult是一个接口，里面没有什么特别的东西。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">BindingResult</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Errors</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">MODEL_KEY_PREFIX</span> <span class=\"operator\">=</span> BindingResult.class.getName() + <span class=\"string\">&quot;.&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    Object <span class=\"title function_\">getTarget</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, Object&gt; <span class=\"title function_\">getModel</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    Object <span class=\"title function_\">getRawFieldValue</span><span class=\"params\">(String field)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    PropertyEditor <span class=\"title function_\">findEditor</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> String field, <span class=\"meta\">@Nullable</span> Class&lt;?&gt; valueType)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    PropertyEditorRegistry <span class=\"title function_\">getPropertyEditorRegistry</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] resolveMessageCodes(String errorCode);</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] resolveMessageCodes(String errorCode, String field);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">addError</span><span class=\"params\">(ObjectError error)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recordFieldValue</span><span class=\"params\">(String field, Class&lt;?&gt; type, <span class=\"meta\">@Nullable</span> Object value)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recordSuppressedField</span><span class=\"params\">(String field)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">default</span> String[] getSuppressedFields() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2-AbstractBindingResult\"><a href=\"#3-2-2-AbstractBindingResult\" class=\"headerlink\" title=\"3.2.2 AbstractBindingResult\"></a>3.2.2 AbstractBindingResult</h3><p>一般来说抽象类都是接口的基本实现，BindingResult也不例外</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractBindingResult</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractErrors</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">BindingResult</span>, Serializable &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String objectName;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">MessageCodesResolver</span> <span class=\"variable\">messageCodesResolver</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultMessageCodesResolver</span>();</span><br><span class=\"line\">    <span class=\"comment\">//储存错误信息</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;ObjectError&gt; errors = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Class&lt;?&gt;&gt; fieldTypes = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Object&gt; fieldValues = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Set&lt;String&gt; suppressedFields = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ObjectError\"><a href=\"#ObjectError\" class=\"headerlink\" title=\"ObjectError\"></a>ObjectError</h4><ol>\n<li><p>本体</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObjectError</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">DefaultMessageSourceResolvable</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//校验失败的对象名，比如shoppingCart</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String objectName;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Object source;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t...       </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>子类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ObjectError的子类，获取ObjectError可以强转为该类 (具体实现是FieldError的子类ViolationFieldError）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FieldError</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ObjectError</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//校验失败的地方，比如itemList[1].name</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String field;</span><br><span class=\"line\">    <span class=\"comment\">//校验失败的值，比如-1</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object rejectedValue;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> bindingFailure;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>父类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ObjectError的父类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DefaultMessageSourceResolvable</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MessageSourceResolvable</span>, Serializable &#123;</span><br><span class=\"line\">    <span class=\"comment\">//存放详细的校验类型信息</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String[] codes;</span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object[] arguments;</span><br><span class=\"line\">    <span class=\"comment\">//注解里面传的Message到这了</span></span><br><span class=\"line\">    <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String defaultMessage;</span><br><span class=\"line\">    </span><br><span class=\"line\"> \t...   </span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>Tips</strong>：可以自行打印观察值，推测存放信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ExceptionHandler(BindException.class)</span></span><br><span class=\"line\">   <span class=\"keyword\">public</span> ResponseResult <span class=\"title function_\">bindExceptionHandler</span><span class=\"params\">(BindException e)</span> &#123;</span><br><span class=\"line\">       List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">       <span class=\"type\">BindingResult</span> <span class=\"variable\">bindingResult</span> <span class=\"operator\">=</span> e.getBindingResult();</span><br><span class=\"line\">       <span class=\"keyword\">for</span> (ObjectError objectError : bindingResult.getAllErrors()) &#123;</span><br><span class=\"line\">           <span class=\"type\">FieldError</span> <span class=\"variable\">fieldError</span> <span class=\"operator\">=</span> (FieldError) objectError;</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;--------------&quot;</span>);</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;codes&quot;</span>);</span><br><span class=\"line\">           Arrays.stream(fieldError.getCodes()).forEach(System.out::println);</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;--------------&quot;</span>);</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;code&quot;</span>);</span><br><span class=\"line\">           System.out.println(fieldError.getCode());</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;--------------&quot;</span>);</span><br><span class=\"line\">           System.out.println(<span class=\"string\">&quot;ObjectName&quot;</span>);</span><br><span class=\"line\">           System.out.println(fieldError.getObjectName());</span><br><span class=\"line\">           logger.error(<span class=\"string\">&quot;参数 &#123;&#125; ,&#123;&#125; 校验错误：&#123;&#125;&quot;</span>, fieldError.getField(), fieldError.getRejectedValue(), fieldError.getDefaultMessage());</span><br><span class=\"line\">           list.add(fieldError.getDefaultMessage());</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> ResponseResult.error(AppHttpCodeEnum.SYSTEM_ERROR.getCode(),list.toString());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>"},{"title":"SpringBoot自动装配原理","date":"2024-04-22T13:25:01.000Z","_content":"\nSpringBoot自动装配 = 模块装配 + 条件装配\n\n`@SpringBootApplication`上标注了`@EnableAutoConfiguration`，这自动装配的起点。\n\n1. 导入starter及Spring运行需要的类\n\n   - `@EnableAutoConfiguration `上标注了`@Import(AutoConfigurationImportSelector.class)`\n\n   - 根据模块装配规则`AutoConfigurationImportSelector`的父类实现了`ImportSelector`接口，重写了`selectImports()`方法。\n   - Spring内部通过层层过滤，最终委托给`SpringFactoriesLoader`中`loadFactoryNames()`方法来调用`loadSpringFactories()`，并过滤返回值key是`EnableAutoConfiguration`的value\n   - `loadSpringFactories()`方法会解析资源目录下\"META-INF/spring.factories\"文件，并将数据封装成Map类型\n   - 之后将得到的数据层层返回上去，在selectImports()返回要加载的类名（也就是META-INF/spring.factories文件中定义的EnableAutoConfiguration的类）\n\n2. 导入自己编写的Bean\n   - `@AutoConfigurationPackage`上标注了`@Import(AutoConfigurationPackages.Registrar.class)`\n   - 根据模块装配规则``AutoConfigurationPackages.Registrar`实现了`ImportBeanDefinitionRegistrar`接口，重写了`registerBeanDefinitions()`方法。\n   - `registerBeanDefinitions()`会调用`register()`方法来注册`PackageImports`中封装的包名\n   - `PackageImports`会解析是否配置需要扫描的包名，默认是启动类所在包\n\n<!-- more -->\n\n# 1. Spring中的装配\n\nTips：框架源码类文章建议自己打开IDEA跟着看看类之间的关系\n\n## 1.1 模块装配\n\n模块装配主要是通过`@Import`注解来实现的，听名字就知道是用来导入类的。\n\n```java\n//Spring中著名的EnableAutoConfiguration注解\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n//不是导入类吗？这导入了个什么玩意儿?\n@Import({AutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration {\n    String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\n    Class<?>[] exclude() default {};\n\n    String[] excludeName() default {};\n}\n```\n\nImport注解源码\n\n```java\n/* @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.0\n * @see Configuration\n * @see ImportSelector\n * @see ImportBeanDefinitionRegistrar\n * @see ImportResource\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Import {\n\t/**\n\t * {@link Configuration @Configuration}, {@link ImportSelector},\n\t * {@link ImportBeanDefinitionRegistrar}, or regular component classes to import.\n\t */\n\tClass<?>[] value();\n\n}\n```\n\n很清楚的看到了四种导入方式`Configuration`，`ImportSelector`、`ImportBeanDefinitionRegistrar`、`ImportResource`\n\n### 1. ImportResource（导入普通类）\n\n需要导入的User类\n\n```java\n@Getter\n@Setter\n@NoArgsConstructor\n@AllArgsConstructor\nclass User{\n    private Long id;\n    private String name;\n}\n```\n\n自定义的注解\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Import(User.class)\npublic @interface EnableUser {\n\n}\n```\n\n启动类\n\n```java\n@SpringBootApplication\n//标注自定义注解，也可以标注在配置类等地方\n@EnableUser\npublic class WebTestApplication {\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = SpringApplication.run(WebTestApplication.class, args);\n        String[] beanNamesForType = context.getBeanNamesForType(User.class);\n        System.out.println(beanNamesForType[0]);\n    }\n}\n```\n\n成功打印出了User\n\n![模块装配方式一](Spring自动装配原理/模块装配方式一.png)\n\n### 2. Configuration (导入配置类)\n\n建立配置类，将配置类放到启动类包扫描不到的地方（默认会扫描主启动类所在包下的所有类，我这里就直接放在主启动类包上）\n\n```java\n@Configuration\npublic class ImportConfiguration {\n    @Bean\n    public User getUser(){\n        User user = new User();\n        user.setId(36L);\n        user.setName(\"ruizhi\");\n        return user;\n    }\n}\n```\n\n修改注解\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Import(User.class)\npublic @interface EnableUser {\n\n}\n```\n\n测试，依旧可以打印出信息（具体对象注入名称问题，自行查阅）\n\n```java\n@SpringBootApplication\n@EnableUser\npublic class WebTestApplication {\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = SpringApplication.run(WebTestApplication.class, args);\n        String[] beanNamesForType = context.getBeanNamesForType(User.class);\n        System.out.println(beanNamesForType[0]);\n    }\n}\n```\n\n![模块装配二](Spring自动装配原理/模块装配二.png)\n\n### 3. ImportSelector（导入Selector）\n\nImportSelector接口\n\n```java\npublic interface ImportSelector {\n\n    /**\n     * Select and return the names of which class(es) should be imported based on\n     * the {@link AnnotationMetadata} of the importing @{@link Configuration} class.\n     * @return the class names, or an empty array if none\n     */\n    //返回要导入的类的全限定类名\n    String[] selectImports(AnnotationMetadata importingClassMetadata);\n}\n```\n\n自定义Selector类实现ImportSelector接口\n\n```java\npublic class UserSelector implements ImportSelector {\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n        //导入User类\n        return new String[]{User.class.getName()};\n    }\n}\n```\n\n注解更改，主启动类不需要更改\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Import(UserSelector.class)\npublic @interface EnableUser {\n\n}\n```\n\n测试结果和方式1相同\n\n### 4. ImportBeanDefinitionRegistrar（导入BeanDefinition）\n\n修改Selector类\n\n```java\npublic class UserSelector implements ImportBeanDefinitionRegistrar {\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n        //传入Bean id和BeanDefinition, 这里直接new了一个\n        registry.registerBeanDefinition(\"ruizhi\", new RootBeanDefinition(User.class));\n    }\n}\n```\n\n结果打印名称就是上面类注册的名称（我这打印的是\"ruizhi\")\n\n## 1.2 条件装配\n\n### 1. Conditional\n\n稍微深入了解过Spring的老哥可能就会很清楚，Spring里面有一套`@Conditional`注解，最常见的就是`@ConditionalOnMissingBean(String[] BeanName)`（没有相应Bean就注入），`@ConditionalOnClass`（有相应Class就注入），有Bean就注入、没有class就注入等一堆注解。\n\n**作用**：有了这些注解我们就可以很轻松的自定类来覆盖掉原本要自动装配的类\n\n```java\n//万恶之源，所有Conditional注解的根\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Conditional {\n\n\t/**\n\t * All {@link Condition} classes that must {@linkplain Condition#matches match}\n\t * in order for the component to be registered.\n\t */\n\tClass<? extends Condition>[] value();\n\n}\n```\n\nConditional会根据Condition来判断是否装配\n\n```java\n@FunctionalInterface\npublic interface Condition {\n\n    /**\n     * Determine if the condition matches.\n     * @param context the condition context\n     * @param metadata the metadata of the {@link org.springframework.core.type.AnnotationMetadata class}\n     * or {@link org.springframework.core.type.MethodMetadata method} being checked\n     * @return {@code true} if the condition matches and the component can be registered,\n     * or {@code false} to veto the annotated component's registration\n     */\n    //返回值为true，则注入相关Bean\n    boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);\n}\n```\n\n到这里我们可以想到，所有衍生出的注解都是根据匹配规则实现了自己`matches()`方法。\n\n看看`ConditionalOnMissingBean`验证下想法\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional({OnBeanCondition.class})\npublic @interface ConditionalOnMissingBean {\n    Class<?>[] value() default {};\n\n    String[] type() default {};\n\n    Class<?>[] ignored() default {};\n\n    String[] ignoredType() default {};\n\n    Class<? extends Annotation>[] annotation() default {};\n\n    String[] name() default {};\n\n    SearchStrategy search() default SearchStrategy.ALL;\n\n    Class<?>[] parameterizedContainer() default {};\n}\n\n```\n\n这时候你自信满满的打开IDEA看了下源码，在OnBeanCondition里面怎么都没找到matches()方法，只有一个 `getMatchOutcome()`？？？怎么回事？\n\n```java\n@Order(Ordered.LOWEST_PRECEDENCE)\nclass OnBeanCondition extends FilteringSpringBootCondition implements ConfigurationCondition {\n    @Override\n\tpublic ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\tConditionMessage matchMessage = ConditionMessage.empty();\n\t\tMergedAnnotations annotations = metadata.getAnnotations();\n\t\tif (annotations.isPresent(ConditionalOnBean.class)) {\n\t\t\tSpec<ConditionalOnBean> spec = new Spec<>(context, metadata, annotations, ConditionalOnBean.class);\n\t\t\tMatchResult matchResult = getMatchingBeans(context, spec);\n\t\t\tif (!matchResult.isAllMatched()) {\n\t\t\t\tString reason = createOnBeanNoMatchReason(matchResult);\n\t\t\t\treturn ConditionOutcome.noMatch(spec.message().because(reason));\n\t\t\t}\n\t\t\tmatchMessage = spec.message(matchMessage).found(\"bean\", \"beans\").items(Style.QUOTE,\n\t\t\t\t\tmatchResult.getNamesOfAllMatches());\n\t\t}\n\t\tif (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) {\n\t\t\tSpec<ConditionalOnSingleCandidate> spec = new SingleCandidateSpec(context, metadata, annotations);\n\t\t\tMatchResult matchResult = getMatchingBeans(context, spec);\n\t\t\tif (!matchResult.isAllMatched()) {\n\t\t\t\treturn ConditionOutcome.noMatch(spec.message().didNotFind(\"any beans\").atAll());\n\t\t\t}\n\t\t\telse if (!hasSingleAutowireCandidate(context.getBeanFactory(), matchResult.getNamesOfAllMatches(),\n\t\t\t\t\tspec.getStrategy() == SearchStrategy.ALL)) {\n\t\t\t\treturn ConditionOutcome.noMatch(spec.message().didNotFind(\"a primary bean from beans\")\n\t\t\t\t\t\t.items(Style.QUOTE, matchResult.getNamesOfAllMatches()));\n\t\t\t}\n\t\t\tmatchMessage = spec.message(matchMessage).found(\"a primary bean from beans\").items(Style.QUOTE,\n\t\t\t\t\tmatchResult.getNamesOfAllMatches());\n\t\t}\n\t\tif (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) {\n\t\t\tSpec<ConditionalOnMissingBean> spec = new Spec<>(context, metadata, annotations,\n\t\t\t\t\tConditionalOnMissingBean.class);\n\t\t\tMatchResult matchResult = getMatchingBeans(context, spec);\n\t\t\tif (matchResult.isAnyMatched()) {\n\t\t\t\tString reason = createOnMissingBeanNoMatchReason(matchResult);\n\t\t\t\treturn ConditionOutcome.noMatch(spec.message().because(reason));\n\t\t\t}\n\t\t\tmatchMessage = spec.message(matchMessage).didNotFind(\"any beans\").atAll();\n\t\t}\n\t\treturn ConditionOutcome.match(matchMessage);\n\t}\n}\n```\n\n那就去看看父类吧，果然最终在`FilteringSpringBootCondition`父类`SpringBootCondition`里找到了答案\n\n可以看到Spring对`matches()`方法进行了一层的封装，在`SpringBootCondition`里`matches()`方法会调用抽象的`getMatchOutcome`(有种模版模式的感觉)，子类只需要实现`getMatchOutcome()`就行了\n\n```java\npublic abstract class SpringBootCondition implements Condition {\n\tpublic final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\tString classOrMethodName = getClassOrMethodName(metadata);\n\t\ttry {\n\t\t\tConditionOutcome outcome = getMatchOutcome(context, metadata);\n\t\t\tlogOutcome(classOrMethodName, outcome);\n\t\t\trecordEvaluation(context, classOrMethodName, outcome);\n\t\t\treturn outcome.isMatch();\n\t\t}\n\t\tcatch (NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException(\"Could not evaluate condition on \" + classOrMethodName + \" due to \"\n\t\t\t\t\t+ ex.getMessage() + \" not found. Make sure your own configuration does not rely on \"\n\t\t\t\t\t+ \"that class. This can also happen if you are \"\n\t\t\t\t\t+ \"@ComponentScanning a springframework package (e.g. if you \"\n\t\t\t\t\t+ \"put a @ComponentScan in the default package by mistake)\", ex);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tthrow new IllegalStateException(\"Error processing condition on \" + getName(metadata), ex);\n\t\t}\n\t}\n}\n```\n\n### 2. Profile\n\n除了Conditional，Spring中还有`@profile`注解来根据环境来注入Bean。\n\n**Environment**（环境）:Spring会把一些信息封装到Environment对象中，比如application.properties中的内容\n\n```java\n//继承PropertyResolver来解析资源\npublic interface Environment extends PropertyResolver {\n    String[] getActiveProfiles();\n\n    String[] getDefaultProfiles();\n\n    /** @deprecated */\n    @Deprecated\n    boolean acceptsProfiles(String... var1);\n\n    boolean acceptsProfiles(Profiles var1);\n}\n```\n\n测试，别忘了把Configuration路径改回来\n\n```java\npublic class WebTestApplication {\n    public static void main(String[] args) {\n        /*需要再容器refresh()之前传入profile值，可以在启动前设置参数`-DSpring.profiles.active=ruizhi`，这里就直接new一个context了*/\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n        ctx.getEnvironment().setActiveProfiles(\"ruizhi\");\n        ctx.register(ImportConfiguration.class);\n        ctx.refresh();\n        String[] beanNamesForType = ctx.getBeanNamesForType(User.class);\n        System.out.println(beanNamesForType[0]);\n    }\n}\n```\n\n加上profile注解，(可以更改值，自行观察是否注入User)\n\n```java\n@Configuration\npublic class ImportConfiguration {\n\n    @Bean\n    @Profile(\"ruizhi\")\n    public User getUser(){\n        User user = new User();\n        user.setId(36L);\n        user.setName(\"ruizhi\");\n        return user;\n    }\n\n}\n```\n\n### 小结\n\n- `@Conditional`主要是用来让用户能根据具体业务场景自己配置或者自定义Bean来满足需求\n- `@Profile`主要是为了针对不同的环境提供不同的Bean（本地测试与线上生产环境的日志打印路径、数据库等组件使用肯定不同）\n\n# 2. SpringBoot自动装配\n\n点开注解`@SpringBootApplication`，你会发现上面标注了一个`@EnableAutoConfiguration`（允许自动装配）\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n\n\t/**\n\t * Environment property that can be used to override when auto-configuration is\n\t * enabled.\n\t */\n\tString ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\n\t/**\n\t * Exclude specific auto-configuration classes such that they will never be applied.\n\t * @return the classes to exclude\n\t */\n\tClass<?>[] exclude() default {};\n\n\t/**\n\t * Exclude specific auto-configuration class names such that they will never be\n\t * applied.\n\t * @return the class names to exclude\n\t * @since 1.3.0\n\t */\n\tString[] excludeName() default {};\n\n}\n```\n\n可以看到`EnableAutoConfiguration`导入了`AutoConfigurationImportSelector.class`，继续深入看看\n\n## 2.1 AutoConfigurationImportSelector\n\n```java\n//模块装配中导入Selector的方式\npublic class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,\n\t\tResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {\n    \n          ...    \n     //只要在这个方法返回类的全限定名就行了\n\t@Override\n\tpublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n\t\tif (!isEnabled(annotationMetadata)) {\n\t\t\treturn NO_IMPORTS;\n\t\t}\n         //加载自动配置类，拿到类的全限定名\n\t\tAutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);\n\t\treturn StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());\n\t}\n            \n     protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {\n\t\tif (!isEnabled(annotationMetadata)) {\n\t\t\treturn EMPTY_ENTRY;\n\t\t}\n\t\tAnnotationAttributes attributes = getAttributes(annotationMetadata);\n         //加载候选类\n\t\tList<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);\n\t\tconfigurations = removeDuplicates(configurations);\n\t\tSet<String> exclusions = getExclusions(annotationMetadata, attributes);\n\t\tcheckExcludedClasses(configurations, exclusions);\n\t\tconfigurations.removeAll(exclusions);\n\t\tconfigurations = getConfigurationClassFilter().filter(configurations);\n\t\tfireAutoConfigurationImportEvents(configurations, exclusions);\n\t\treturn new AutoConfigurationEntry(configurations, exclusions);\n\t}\n            \n      protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n          //通过SpringFactoriesLoader加载类名\n\t\tList<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),\n\t\t\t\tgetBeanClassLoader());\n\t\tAssert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \"\n\t\t\t\t+ \"are using a custom packaging, make sure that file is correct.\");\n\t\treturn configurations;\n\t}return configurations;\n\t}\n            \n}\n```\n\n可以看到经过层层封装，Spring把具体加载的过程委托给了**SpringFactoriesLoader**类，（终于可以到具体的加载逻辑了。\n\n```java\npublic final class SpringFactoriesLoader {\n    public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n    \n\tpublic static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {\n        //factoryTypeName是EnableAutoConfiguration\n\t\tString factoryTypeName = factoryType.getName();\n        //封装成Map，返回key是EnableAutoConfiguration的类名\n\t\treturn loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());\n\t}\n\n\tprivate static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {\n\t\tMultiValueMap<String, String> result = cache.get(classLoader);\n\t\tif (result != null) {\n\t\t\treturn result;\n\t\t}\n\n\t\ttry {\n            //加载路径就是META-INF/spring.factories\n\t\t\tEnumeration<URL> urls = (classLoader != null ?\n\t\t\t\t\tclassLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n\t\t\t\t\tClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n\t\t\tresult = new LinkedMultiValueMap<>();\n            //遍历文件并把它放到缓存里\n\t\t\twhile (urls.hasMoreElements()) {\n\t\t\t\tURL url = urls.nextElement();\n\t\t\t\tUrlResource resource = new UrlResource(url);\n\t\t\t\tProperties properties = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t\tfor (Map.Entry<?, ?> entry : properties.entrySet()) {\n\t\t\t\t\tString factoryTypeName = ((String) entry.getKey()).trim();\n\t\t\t\t\tfor (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {\n\t\t\t\t\t\tresult.add(factoryTypeName, factoryImplementationName.trim());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcache.put(classLoader, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to load factories from location [\" +\n\t\t\t\t\tFACTORIES_RESOURCE_LOCATION + \"]\", ex);\n\t\t}\n\t}\n```\n\n通过上述过程我们也就可以想到Spring加载Starter，也是加载了starter资源目录下`META-INF/spring.factories`文件，当然自定义Starter也可以通过编写这一文件将需要的Bean导入到容器中。\n\n## 2.2 @AutoConfigurationPackage\n\n先点进去看看\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Import(AutoConfigurationPackages.Registrar.class)\npublic @interface AutoConfigurationPackage {\n\n\t/**\n\t * Base packages that should be registered with {@link AutoConfigurationPackages}.\n\t * <p>\n\t * Use {@link #basePackageClasses} for a type-safe alternative to String-based package\n\t * names.\n\t * @return the back package names\n\t * @since 2.3.0\n\t */\n\tString[] basePackages() default {};\n\n\t/**\n\t * Type-safe alternative to {@link #basePackages} for specifying the packages to be\n\t * registered with {@link AutoConfigurationPackages}.\n\t * <p>\n\t * Consider creating a special no-op marker class or interface in each package that\n\t * serves no purpose other than being referenced by this attribute.\n\t * @return the base package classes\n\t * @since 2.3.0\n\t */\n\tClass<?>[] basePackageClasses() default {};\n\n}\n```\n\n可以看到`AutoConfigurationPackage`上面还有一个Import注解，导入了`AutoConfigurationPackages.Registrar.class`，继续往下看看\n\n```java\n//模块装配中导入BeanDefinition的方式\nstatic class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {\n\n\t\t@Override\n\t\tpublic void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n            //调用外部的register方法，AnnotationMetadata是被标注注解的类的元信息（这里主要是为了获取主类包名）\n            //关于AnnotationMetadata以及BeanDefinitionRegistry的相关信息自行查阅\n\t\t\tregister(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));\n\t\t}\n\t\t@Override\n\t\tpublic Set<Object> determineImports(AnnotationMetadata metadata) {\n\t\t\treturn Collections.singleton(new PackageImports(metadata));\n\t\t}\n\n\t}\n```\n\n但是PackageImports是什么？点进去看看\n\n```java\nprivate static final class PackageImports {\n\n\t\tprivate final List<String> packageNames;\n\n\t\tPackageImports(AnnotationMetadata metadata) {\n\t\t\tAnnotationAttributes attributes = AnnotationAttributes\n\t\t\t\t\t.fromMap(metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), false));\n\t\t\tList<String> packageNames = new ArrayList<>();\n            //判断自己有没有配置basePackages\n\t\t\tfor (String basePackage : attributes.getStringArray(\"basePackages\")) {\n\t\t\t\tpackageNames.add(basePackage);\n\t\t\t}\n\t\t\tfor (Class<?> basePackageClass : attributes.getClassArray(\"basePackageClasses\")) {\n\t\t\t\tpackageNames.add(basePackageClass.getPackage().getName());\n\t\t\t}\n            //默认空的会自动添加类的包路径\n\t\t\tif (packageNames.isEmpty()) {\n\t\t\t\tpackageNames.add(ClassUtils.getPackageName(metadata.getClassName()));\n\t\t\t}\n\t\t\tthis.packageNames = Collections.unmodifiableList(packageNames);\n\t\t}\n\t}\n```\n\n# 3. 总结\n\n`@SpringBootApplication`上标注了`@EnableAutoConfiguration`，这自动装配的起点。\n\n1. 导入starter及Spring运行需要的类\n\n   - `@EnableAutoConfiguration `上标注了`@Import(AutoConfigurationImportSelector.class)`\n\n   - 根据模块装配规则`AutoConfigurationImportSelector`的父类实现了`ImportSelector`接口，重写了`selectImports()`方法。\n   - Spring内部通过层层过滤，最终委托给`SpringFactoriesLoader`中`loadFactoryNames()`方法来调用`loadSpringFactories()`，并过滤返回值key是`EnableAutoConfiguration`的value\n   - `loadSpringFactories()`方法会解析资源目录下\"META-INF/spring.factories\"文件，并将数据封装成Map类型\n   - 之后将得到的数据层层返回上去，在selectImports()返回要加载的类名（也就是META-INF/spring.factories文件中定义的EnableAutoConfiguration的类）\n\n2. 导入自己编写的Bean\n   - `@AutoConfigurationPackage`上标注了`@Import(AutoConfigurationPackages.Registrar.class)`\n   - 根据模块装配规则``AutoConfigurationPackages.Registrar`实现了`ImportBeanDefinitionRegistrar`接口，重写了`registerBeanDefinitions()`方法。\n   - `registerBeanDefinitions()`会调用`register()`方法来注册`PackageImports`中封装的包名\n   - `PackageImports`会解析是否配置需要扫描的包名，默认是启动类所在包\n\n","source":"_posts/Spring自动装配原理.md","raw":"---\ntitle: SpringBoot自动装配原理\ndate: 2024-04-22 21:25:01\ntags: SpringBoot\ncategories: 后端开发\n---\n\nSpringBoot自动装配 = 模块装配 + 条件装配\n\n`@SpringBootApplication`上标注了`@EnableAutoConfiguration`，这自动装配的起点。\n\n1. 导入starter及Spring运行需要的类\n\n   - `@EnableAutoConfiguration `上标注了`@Import(AutoConfigurationImportSelector.class)`\n\n   - 根据模块装配规则`AutoConfigurationImportSelector`的父类实现了`ImportSelector`接口，重写了`selectImports()`方法。\n   - Spring内部通过层层过滤，最终委托给`SpringFactoriesLoader`中`loadFactoryNames()`方法来调用`loadSpringFactories()`，并过滤返回值key是`EnableAutoConfiguration`的value\n   - `loadSpringFactories()`方法会解析资源目录下\"META-INF/spring.factories\"文件，并将数据封装成Map类型\n   - 之后将得到的数据层层返回上去，在selectImports()返回要加载的类名（也就是META-INF/spring.factories文件中定义的EnableAutoConfiguration的类）\n\n2. 导入自己编写的Bean\n   - `@AutoConfigurationPackage`上标注了`@Import(AutoConfigurationPackages.Registrar.class)`\n   - 根据模块装配规则``AutoConfigurationPackages.Registrar`实现了`ImportBeanDefinitionRegistrar`接口，重写了`registerBeanDefinitions()`方法。\n   - `registerBeanDefinitions()`会调用`register()`方法来注册`PackageImports`中封装的包名\n   - `PackageImports`会解析是否配置需要扫描的包名，默认是启动类所在包\n\n<!-- more -->\n\n# 1. Spring中的装配\n\nTips：框架源码类文章建议自己打开IDEA跟着看看类之间的关系\n\n## 1.1 模块装配\n\n模块装配主要是通过`@Import`注解来实现的，听名字就知道是用来导入类的。\n\n```java\n//Spring中著名的EnableAutoConfiguration注解\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n//不是导入类吗？这导入了个什么玩意儿?\n@Import({AutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration {\n    String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\n    Class<?>[] exclude() default {};\n\n    String[] excludeName() default {};\n}\n```\n\nImport注解源码\n\n```java\n/* @author Chris Beams\n * @author Juergen Hoeller\n * @since 3.0\n * @see Configuration\n * @see ImportSelector\n * @see ImportBeanDefinitionRegistrar\n * @see ImportResource\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Import {\n\t/**\n\t * {@link Configuration @Configuration}, {@link ImportSelector},\n\t * {@link ImportBeanDefinitionRegistrar}, or regular component classes to import.\n\t */\n\tClass<?>[] value();\n\n}\n```\n\n很清楚的看到了四种导入方式`Configuration`，`ImportSelector`、`ImportBeanDefinitionRegistrar`、`ImportResource`\n\n### 1. ImportResource（导入普通类）\n\n需要导入的User类\n\n```java\n@Getter\n@Setter\n@NoArgsConstructor\n@AllArgsConstructor\nclass User{\n    private Long id;\n    private String name;\n}\n```\n\n自定义的注解\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Import(User.class)\npublic @interface EnableUser {\n\n}\n```\n\n启动类\n\n```java\n@SpringBootApplication\n//标注自定义注解，也可以标注在配置类等地方\n@EnableUser\npublic class WebTestApplication {\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = SpringApplication.run(WebTestApplication.class, args);\n        String[] beanNamesForType = context.getBeanNamesForType(User.class);\n        System.out.println(beanNamesForType[0]);\n    }\n}\n```\n\n成功打印出了User\n\n![模块装配方式一](Spring自动装配原理/模块装配方式一.png)\n\n### 2. Configuration (导入配置类)\n\n建立配置类，将配置类放到启动类包扫描不到的地方（默认会扫描主启动类所在包下的所有类，我这里就直接放在主启动类包上）\n\n```java\n@Configuration\npublic class ImportConfiguration {\n    @Bean\n    public User getUser(){\n        User user = new User();\n        user.setId(36L);\n        user.setName(\"ruizhi\");\n        return user;\n    }\n}\n```\n\n修改注解\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Import(User.class)\npublic @interface EnableUser {\n\n}\n```\n\n测试，依旧可以打印出信息（具体对象注入名称问题，自行查阅）\n\n```java\n@SpringBootApplication\n@EnableUser\npublic class WebTestApplication {\n    public static void main(String[] args) {\n        ConfigurableApplicationContext context = SpringApplication.run(WebTestApplication.class, args);\n        String[] beanNamesForType = context.getBeanNamesForType(User.class);\n        System.out.println(beanNamesForType[0]);\n    }\n}\n```\n\n![模块装配二](Spring自动装配原理/模块装配二.png)\n\n### 3. ImportSelector（导入Selector）\n\nImportSelector接口\n\n```java\npublic interface ImportSelector {\n\n    /**\n     * Select and return the names of which class(es) should be imported based on\n     * the {@link AnnotationMetadata} of the importing @{@link Configuration} class.\n     * @return the class names, or an empty array if none\n     */\n    //返回要导入的类的全限定类名\n    String[] selectImports(AnnotationMetadata importingClassMetadata);\n}\n```\n\n自定义Selector类实现ImportSelector接口\n\n```java\npublic class UserSelector implements ImportSelector {\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n        //导入User类\n        return new String[]{User.class.getName()};\n    }\n}\n```\n\n注解更改，主启动类不需要更改\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Import(UserSelector.class)\npublic @interface EnableUser {\n\n}\n```\n\n测试结果和方式1相同\n\n### 4. ImportBeanDefinitionRegistrar（导入BeanDefinition）\n\n修改Selector类\n\n```java\npublic class UserSelector implements ImportBeanDefinitionRegistrar {\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n        //传入Bean id和BeanDefinition, 这里直接new了一个\n        registry.registerBeanDefinition(\"ruizhi\", new RootBeanDefinition(User.class));\n    }\n}\n```\n\n结果打印名称就是上面类注册的名称（我这打印的是\"ruizhi\")\n\n## 1.2 条件装配\n\n### 1. Conditional\n\n稍微深入了解过Spring的老哥可能就会很清楚，Spring里面有一套`@Conditional`注解，最常见的就是`@ConditionalOnMissingBean(String[] BeanName)`（没有相应Bean就注入），`@ConditionalOnClass`（有相应Class就注入），有Bean就注入、没有class就注入等一堆注解。\n\n**作用**：有了这些注解我们就可以很轻松的自定类来覆盖掉原本要自动装配的类\n\n```java\n//万恶之源，所有Conditional注解的根\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Conditional {\n\n\t/**\n\t * All {@link Condition} classes that must {@linkplain Condition#matches match}\n\t * in order for the component to be registered.\n\t */\n\tClass<? extends Condition>[] value();\n\n}\n```\n\nConditional会根据Condition来判断是否装配\n\n```java\n@FunctionalInterface\npublic interface Condition {\n\n    /**\n     * Determine if the condition matches.\n     * @param context the condition context\n     * @param metadata the metadata of the {@link org.springframework.core.type.AnnotationMetadata class}\n     * or {@link org.springframework.core.type.MethodMetadata method} being checked\n     * @return {@code true} if the condition matches and the component can be registered,\n     * or {@code false} to veto the annotated component's registration\n     */\n    //返回值为true，则注入相关Bean\n    boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);\n}\n```\n\n到这里我们可以想到，所有衍生出的注解都是根据匹配规则实现了自己`matches()`方法。\n\n看看`ConditionalOnMissingBean`验证下想法\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Conditional({OnBeanCondition.class})\npublic @interface ConditionalOnMissingBean {\n    Class<?>[] value() default {};\n\n    String[] type() default {};\n\n    Class<?>[] ignored() default {};\n\n    String[] ignoredType() default {};\n\n    Class<? extends Annotation>[] annotation() default {};\n\n    String[] name() default {};\n\n    SearchStrategy search() default SearchStrategy.ALL;\n\n    Class<?>[] parameterizedContainer() default {};\n}\n\n```\n\n这时候你自信满满的打开IDEA看了下源码，在OnBeanCondition里面怎么都没找到matches()方法，只有一个 `getMatchOutcome()`？？？怎么回事？\n\n```java\n@Order(Ordered.LOWEST_PRECEDENCE)\nclass OnBeanCondition extends FilteringSpringBootCondition implements ConfigurationCondition {\n    @Override\n\tpublic ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\tConditionMessage matchMessage = ConditionMessage.empty();\n\t\tMergedAnnotations annotations = metadata.getAnnotations();\n\t\tif (annotations.isPresent(ConditionalOnBean.class)) {\n\t\t\tSpec<ConditionalOnBean> spec = new Spec<>(context, metadata, annotations, ConditionalOnBean.class);\n\t\t\tMatchResult matchResult = getMatchingBeans(context, spec);\n\t\t\tif (!matchResult.isAllMatched()) {\n\t\t\t\tString reason = createOnBeanNoMatchReason(matchResult);\n\t\t\t\treturn ConditionOutcome.noMatch(spec.message().because(reason));\n\t\t\t}\n\t\t\tmatchMessage = spec.message(matchMessage).found(\"bean\", \"beans\").items(Style.QUOTE,\n\t\t\t\t\tmatchResult.getNamesOfAllMatches());\n\t\t}\n\t\tif (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) {\n\t\t\tSpec<ConditionalOnSingleCandidate> spec = new SingleCandidateSpec(context, metadata, annotations);\n\t\t\tMatchResult matchResult = getMatchingBeans(context, spec);\n\t\t\tif (!matchResult.isAllMatched()) {\n\t\t\t\treturn ConditionOutcome.noMatch(spec.message().didNotFind(\"any beans\").atAll());\n\t\t\t}\n\t\t\telse if (!hasSingleAutowireCandidate(context.getBeanFactory(), matchResult.getNamesOfAllMatches(),\n\t\t\t\t\tspec.getStrategy() == SearchStrategy.ALL)) {\n\t\t\t\treturn ConditionOutcome.noMatch(spec.message().didNotFind(\"a primary bean from beans\")\n\t\t\t\t\t\t.items(Style.QUOTE, matchResult.getNamesOfAllMatches()));\n\t\t\t}\n\t\t\tmatchMessage = spec.message(matchMessage).found(\"a primary bean from beans\").items(Style.QUOTE,\n\t\t\t\t\tmatchResult.getNamesOfAllMatches());\n\t\t}\n\t\tif (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) {\n\t\t\tSpec<ConditionalOnMissingBean> spec = new Spec<>(context, metadata, annotations,\n\t\t\t\t\tConditionalOnMissingBean.class);\n\t\t\tMatchResult matchResult = getMatchingBeans(context, spec);\n\t\t\tif (matchResult.isAnyMatched()) {\n\t\t\t\tString reason = createOnMissingBeanNoMatchReason(matchResult);\n\t\t\t\treturn ConditionOutcome.noMatch(spec.message().because(reason));\n\t\t\t}\n\t\t\tmatchMessage = spec.message(matchMessage).didNotFind(\"any beans\").atAll();\n\t\t}\n\t\treturn ConditionOutcome.match(matchMessage);\n\t}\n}\n```\n\n那就去看看父类吧，果然最终在`FilteringSpringBootCondition`父类`SpringBootCondition`里找到了答案\n\n可以看到Spring对`matches()`方法进行了一层的封装，在`SpringBootCondition`里`matches()`方法会调用抽象的`getMatchOutcome`(有种模版模式的感觉)，子类只需要实现`getMatchOutcome()`就行了\n\n```java\npublic abstract class SpringBootCondition implements Condition {\n\tpublic final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n\t\tString classOrMethodName = getClassOrMethodName(metadata);\n\t\ttry {\n\t\t\tConditionOutcome outcome = getMatchOutcome(context, metadata);\n\t\t\tlogOutcome(classOrMethodName, outcome);\n\t\t\trecordEvaluation(context, classOrMethodName, outcome);\n\t\t\treturn outcome.isMatch();\n\t\t}\n\t\tcatch (NoClassDefFoundError ex) {\n\t\t\tthrow new IllegalStateException(\"Could not evaluate condition on \" + classOrMethodName + \" due to \"\n\t\t\t\t\t+ ex.getMessage() + \" not found. Make sure your own configuration does not rely on \"\n\t\t\t\t\t+ \"that class. This can also happen if you are \"\n\t\t\t\t\t+ \"@ComponentScanning a springframework package (e.g. if you \"\n\t\t\t\t\t+ \"put a @ComponentScan in the default package by mistake)\", ex);\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tthrow new IllegalStateException(\"Error processing condition on \" + getName(metadata), ex);\n\t\t}\n\t}\n}\n```\n\n### 2. Profile\n\n除了Conditional，Spring中还有`@profile`注解来根据环境来注入Bean。\n\n**Environment**（环境）:Spring会把一些信息封装到Environment对象中，比如application.properties中的内容\n\n```java\n//继承PropertyResolver来解析资源\npublic interface Environment extends PropertyResolver {\n    String[] getActiveProfiles();\n\n    String[] getDefaultProfiles();\n\n    /** @deprecated */\n    @Deprecated\n    boolean acceptsProfiles(String... var1);\n\n    boolean acceptsProfiles(Profiles var1);\n}\n```\n\n测试，别忘了把Configuration路径改回来\n\n```java\npublic class WebTestApplication {\n    public static void main(String[] args) {\n        /*需要再容器refresh()之前传入profile值，可以在启动前设置参数`-DSpring.profiles.active=ruizhi`，这里就直接new一个context了*/\n        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n        ctx.getEnvironment().setActiveProfiles(\"ruizhi\");\n        ctx.register(ImportConfiguration.class);\n        ctx.refresh();\n        String[] beanNamesForType = ctx.getBeanNamesForType(User.class);\n        System.out.println(beanNamesForType[0]);\n    }\n}\n```\n\n加上profile注解，(可以更改值，自行观察是否注入User)\n\n```java\n@Configuration\npublic class ImportConfiguration {\n\n    @Bean\n    @Profile(\"ruizhi\")\n    public User getUser(){\n        User user = new User();\n        user.setId(36L);\n        user.setName(\"ruizhi\");\n        return user;\n    }\n\n}\n```\n\n### 小结\n\n- `@Conditional`主要是用来让用户能根据具体业务场景自己配置或者自定义Bean来满足需求\n- `@Profile`主要是为了针对不同的环境提供不同的Bean（本地测试与线上生产环境的日志打印路径、数据库等组件使用肯定不同）\n\n# 2. SpringBoot自动装配\n\n点开注解`@SpringBootApplication`，你会发现上面标注了一个`@EnableAutoConfiguration`（允许自动装配）\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n\n\t/**\n\t * Environment property that can be used to override when auto-configuration is\n\t * enabled.\n\t */\n\tString ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\n\t/**\n\t * Exclude specific auto-configuration classes such that they will never be applied.\n\t * @return the classes to exclude\n\t */\n\tClass<?>[] exclude() default {};\n\n\t/**\n\t * Exclude specific auto-configuration class names such that they will never be\n\t * applied.\n\t * @return the class names to exclude\n\t * @since 1.3.0\n\t */\n\tString[] excludeName() default {};\n\n}\n```\n\n可以看到`EnableAutoConfiguration`导入了`AutoConfigurationImportSelector.class`，继续深入看看\n\n## 2.1 AutoConfigurationImportSelector\n\n```java\n//模块装配中导入Selector的方式\npublic class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,\n\t\tResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {\n    \n          ...    \n     //只要在这个方法返回类的全限定名就行了\n\t@Override\n\tpublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n\t\tif (!isEnabled(annotationMetadata)) {\n\t\t\treturn NO_IMPORTS;\n\t\t}\n         //加载自动配置类，拿到类的全限定名\n\t\tAutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);\n\t\treturn StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());\n\t}\n            \n     protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {\n\t\tif (!isEnabled(annotationMetadata)) {\n\t\t\treturn EMPTY_ENTRY;\n\t\t}\n\t\tAnnotationAttributes attributes = getAttributes(annotationMetadata);\n         //加载候选类\n\t\tList<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);\n\t\tconfigurations = removeDuplicates(configurations);\n\t\tSet<String> exclusions = getExclusions(annotationMetadata, attributes);\n\t\tcheckExcludedClasses(configurations, exclusions);\n\t\tconfigurations.removeAll(exclusions);\n\t\tconfigurations = getConfigurationClassFilter().filter(configurations);\n\t\tfireAutoConfigurationImportEvents(configurations, exclusions);\n\t\treturn new AutoConfigurationEntry(configurations, exclusions);\n\t}\n            \n      protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n          //通过SpringFactoriesLoader加载类名\n\t\tList<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),\n\t\t\t\tgetBeanClassLoader());\n\t\tAssert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \"\n\t\t\t\t+ \"are using a custom packaging, make sure that file is correct.\");\n\t\treturn configurations;\n\t}return configurations;\n\t}\n            \n}\n```\n\n可以看到经过层层封装，Spring把具体加载的过程委托给了**SpringFactoriesLoader**类，（终于可以到具体的加载逻辑了。\n\n```java\npublic final class SpringFactoriesLoader {\n    public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\n    \n\tpublic static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {\n        //factoryTypeName是EnableAutoConfiguration\n\t\tString factoryTypeName = factoryType.getName();\n        //封装成Map，返回key是EnableAutoConfiguration的类名\n\t\treturn loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());\n\t}\n\n\tprivate static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {\n\t\tMultiValueMap<String, String> result = cache.get(classLoader);\n\t\tif (result != null) {\n\t\t\treturn result;\n\t\t}\n\n\t\ttry {\n            //加载路径就是META-INF/spring.factories\n\t\t\tEnumeration<URL> urls = (classLoader != null ?\n\t\t\t\t\tclassLoader.getResources(FACTORIES_RESOURCE_LOCATION) :\n\t\t\t\t\tClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\n\t\t\tresult = new LinkedMultiValueMap<>();\n            //遍历文件并把它放到缓存里\n\t\t\twhile (urls.hasMoreElements()) {\n\t\t\t\tURL url = urls.nextElement();\n\t\t\t\tUrlResource resource = new UrlResource(url);\n\t\t\t\tProperties properties = PropertiesLoaderUtils.loadProperties(resource);\n\t\t\t\tfor (Map.Entry<?, ?> entry : properties.entrySet()) {\n\t\t\t\t\tString factoryTypeName = ((String) entry.getKey()).trim();\n\t\t\t\t\tfor (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {\n\t\t\t\t\t\tresult.add(factoryTypeName, factoryImplementationName.trim());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcache.put(classLoader, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Unable to load factories from location [\" +\n\t\t\t\t\tFACTORIES_RESOURCE_LOCATION + \"]\", ex);\n\t\t}\n\t}\n```\n\n通过上述过程我们也就可以想到Spring加载Starter，也是加载了starter资源目录下`META-INF/spring.factories`文件，当然自定义Starter也可以通过编写这一文件将需要的Bean导入到容器中。\n\n## 2.2 @AutoConfigurationPackage\n\n先点进去看看\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Import(AutoConfigurationPackages.Registrar.class)\npublic @interface AutoConfigurationPackage {\n\n\t/**\n\t * Base packages that should be registered with {@link AutoConfigurationPackages}.\n\t * <p>\n\t * Use {@link #basePackageClasses} for a type-safe alternative to String-based package\n\t * names.\n\t * @return the back package names\n\t * @since 2.3.0\n\t */\n\tString[] basePackages() default {};\n\n\t/**\n\t * Type-safe alternative to {@link #basePackages} for specifying the packages to be\n\t * registered with {@link AutoConfigurationPackages}.\n\t * <p>\n\t * Consider creating a special no-op marker class or interface in each package that\n\t * serves no purpose other than being referenced by this attribute.\n\t * @return the base package classes\n\t * @since 2.3.0\n\t */\n\tClass<?>[] basePackageClasses() default {};\n\n}\n```\n\n可以看到`AutoConfigurationPackage`上面还有一个Import注解，导入了`AutoConfigurationPackages.Registrar.class`，继续往下看看\n\n```java\n//模块装配中导入BeanDefinition的方式\nstatic class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {\n\n\t\t@Override\n\t\tpublic void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {\n            //调用外部的register方法，AnnotationMetadata是被标注注解的类的元信息（这里主要是为了获取主类包名）\n            //关于AnnotationMetadata以及BeanDefinitionRegistry的相关信息自行查阅\n\t\t\tregister(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));\n\t\t}\n\t\t@Override\n\t\tpublic Set<Object> determineImports(AnnotationMetadata metadata) {\n\t\t\treturn Collections.singleton(new PackageImports(metadata));\n\t\t}\n\n\t}\n```\n\n但是PackageImports是什么？点进去看看\n\n```java\nprivate static final class PackageImports {\n\n\t\tprivate final List<String> packageNames;\n\n\t\tPackageImports(AnnotationMetadata metadata) {\n\t\t\tAnnotationAttributes attributes = AnnotationAttributes\n\t\t\t\t\t.fromMap(metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), false));\n\t\t\tList<String> packageNames = new ArrayList<>();\n            //判断自己有没有配置basePackages\n\t\t\tfor (String basePackage : attributes.getStringArray(\"basePackages\")) {\n\t\t\t\tpackageNames.add(basePackage);\n\t\t\t}\n\t\t\tfor (Class<?> basePackageClass : attributes.getClassArray(\"basePackageClasses\")) {\n\t\t\t\tpackageNames.add(basePackageClass.getPackage().getName());\n\t\t\t}\n            //默认空的会自动添加类的包路径\n\t\t\tif (packageNames.isEmpty()) {\n\t\t\t\tpackageNames.add(ClassUtils.getPackageName(metadata.getClassName()));\n\t\t\t}\n\t\t\tthis.packageNames = Collections.unmodifiableList(packageNames);\n\t\t}\n\t}\n```\n\n# 3. 总结\n\n`@SpringBootApplication`上标注了`@EnableAutoConfiguration`，这自动装配的起点。\n\n1. 导入starter及Spring运行需要的类\n\n   - `@EnableAutoConfiguration `上标注了`@Import(AutoConfigurationImportSelector.class)`\n\n   - 根据模块装配规则`AutoConfigurationImportSelector`的父类实现了`ImportSelector`接口，重写了`selectImports()`方法。\n   - Spring内部通过层层过滤，最终委托给`SpringFactoriesLoader`中`loadFactoryNames()`方法来调用`loadSpringFactories()`，并过滤返回值key是`EnableAutoConfiguration`的value\n   - `loadSpringFactories()`方法会解析资源目录下\"META-INF/spring.factories\"文件，并将数据封装成Map类型\n   - 之后将得到的数据层层返回上去，在selectImports()返回要加载的类名（也就是META-INF/spring.factories文件中定义的EnableAutoConfiguration的类）\n\n2. 导入自己编写的Bean\n   - `@AutoConfigurationPackage`上标注了`@Import(AutoConfigurationPackages.Registrar.class)`\n   - 根据模块装配规则``AutoConfigurationPackages.Registrar`实现了`ImportBeanDefinitionRegistrar`接口，重写了`registerBeanDefinitions()`方法。\n   - `registerBeanDefinitions()`会调用`register()`方法来注册`PackageImports`中封装的包名\n   - `PackageImports`会解析是否配置需要扫描的包名，默认是启动类所在包\n\n","slug":"Spring自动装配原理","published":1,"updated":"2024-09-03T02:46:47.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6bk0009skus91unbx5v","content":"<p>SpringBoot自动装配 &#x3D; 模块装配 + 条件装配</p>\n<p><code>@SpringBootApplication</code>上标注了<code>@EnableAutoConfiguration</code>，这自动装配的起点。</p>\n<ol>\n<li><p>导入starter及Spring运行需要的类</p>\n<ul>\n<li><p><code>@EnableAutoConfiguration </code>上标注了<code>@Import(AutoConfigurationImportSelector.class)</code></p>\n</li>\n<li><p>根据模块装配规则<code>AutoConfigurationImportSelector</code>的父类实现了<code>ImportSelector</code>接口，重写了<code>selectImports()</code>方法。</p>\n</li>\n<li><p>Spring内部通过层层过滤，最终委托给<code>SpringFactoriesLoader</code>中<code>loadFactoryNames()</code>方法来调用<code>loadSpringFactories()</code>，并过滤返回值key是<code>EnableAutoConfiguration</code>的value</p>\n</li>\n<li><p><code>loadSpringFactories()</code>方法会解析资源目录下”META-INF&#x2F;spring.factories”文件，并将数据封装成Map类型</p>\n</li>\n<li><p>之后将得到的数据层层返回上去，在selectImports()返回要加载的类名（也就是META-INF&#x2F;spring.factories文件中定义的EnableAutoConfiguration的类）</p>\n</li>\n</ul>\n</li>\n<li><p>导入自己编写的Bean</p>\n<ul>\n<li><code>@AutoConfigurationPackage</code>上标注了<code>@Import(AutoConfigurationPackages.Registrar.class)</code></li>\n<li>根据模块装配规则&#96;&#96;AutoConfigurationPackages.Registrar<code>实现了</code>ImportBeanDefinitionRegistrar<code>接口，重写了</code>registerBeanDefinitions()&#96;方法。</li>\n<li><code>registerBeanDefinitions()</code>会调用<code>register()</code>方法来注册<code>PackageImports</code>中封装的包名</li>\n<li><code>PackageImports</code>会解析是否配置需要扫描的包名，默认是启动类所在包</li>\n</ul>\n</li>\n</ol>\n<span id=\"more\"></span>\n\n<h1 id=\"1-Spring中的装配\"><a href=\"#1-Spring中的装配\" class=\"headerlink\" title=\"1. Spring中的装配\"></a>1. Spring中的装配</h1><p>Tips：框架源码类文章建议自己打开IDEA跟着看看类之间的关系</p>\n<h2 id=\"1-1-模块装配\"><a href=\"#1-1-模块装配\" class=\"headerlink\" title=\"1.1 模块装配\"></a>1.1 模块装配</h2><p>模块装配主要是通过<code>@Import</code>注解来实现的，听名字就知道是用来导入类的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Spring中著名的EnableAutoConfiguration注解</span></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"comment\">//不是导入类吗？这导入了个什么玩意儿?</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ENABLED_OVERRIDE_PROPERTY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Import注解源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* @author Chris Beams</span></span><br><span class=\"line\"><span class=\"comment\"> * @author Juergen Hoeller</span></span><br><span class=\"line\"><span class=\"comment\"> * @since 3.0</span></span><br><span class=\"line\"><span class=\"comment\"> * @see Configuration</span></span><br><span class=\"line\"><span class=\"comment\"> * @see ImportSelector</span></span><br><span class=\"line\"><span class=\"comment\"> * @see ImportBeanDefinitionRegistrar</span></span><br><span class=\"line\"><span class=\"comment\"> * @see ImportResource</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Import &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#123;<span class=\"doctag\">@link</span> Configuration <span class=\"doctag\">@Configuration</span>&#125;, &#123;<span class=\"doctag\">@link</span> ImportSelector&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#123;<span class=\"doctag\">@link</span> ImportBeanDefinitionRegistrar&#125;, or regular component classes to import.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tClass&lt;?&gt;[] value();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很清楚的看到了四种导入方式<code>Configuration</code>，<code>ImportSelector</code>、<code>ImportBeanDefinitionRegistrar</code>、<code>ImportResource</code></p>\n<h3 id=\"1-ImportResource（导入普通类）\"><a href=\"#1-ImportResource（导入普通类）\" class=\"headerlink\" title=\"1. ImportResource（导入普通类）\"></a>1. ImportResource（导入普通类）</h3><p>需要导入的User类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自定义的注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(User.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableUser &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">//标注自定义注解，也可以标注在配置类等地方</span></span><br><span class=\"line\"><span class=\"meta\">@EnableUser</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebTestApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> SpringApplication.run(WebTestApplication.class, args);</span><br><span class=\"line\">        String[] beanNamesForType = context.getBeanNamesForType(User.class);</span><br><span class=\"line\">        System.out.println(beanNamesForType[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>成功打印出了User</p>\n<p><img src=\"/2024/04/22/Spring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/%E6%A8%A1%E5%9D%97%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F%E4%B8%80.png\" alt=\"模块装配方式一\"></p>\n<h3 id=\"2-Configuration-导入配置类\"><a href=\"#2-Configuration-导入配置类\" class=\"headerlink\" title=\"2. Configuration (导入配置类)\"></a>2. Configuration (导入配置类)</h3><p>建立配置类，将配置类放到启动类包扫描不到的地方（默认会扫描主启动类所在包下的所有类，我这里就直接放在主启动类包上）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImportConfiguration</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">getUser</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">        user.setId(<span class=\"number\">36L</span>);</span><br><span class=\"line\">        user.setName(<span class=\"string\">&quot;ruizhi&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(User.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableUser &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试，依旧可以打印出信息（具体对象注入名称问题，自行查阅）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableUser</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebTestApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> SpringApplication.run(WebTestApplication.class, args);</span><br><span class=\"line\">        String[] beanNamesForType = context.getBeanNamesForType(User.class);</span><br><span class=\"line\">        System.out.println(beanNamesForType[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/22/Spring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/%E6%A8%A1%E5%9D%97%E8%A3%85%E9%85%8D%E4%BA%8C.png\" alt=\"模块装配二\"></p>\n<h3 id=\"3-ImportSelector（导入Selector）\"><a href=\"#3-ImportSelector（导入Selector）\" class=\"headerlink\" title=\"3. ImportSelector（导入Selector）\"></a>3. ImportSelector（导入Selector）</h3><p>ImportSelector接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ImportSelector</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Select and return the names of which class(es) should be imported based on</span></span><br><span class=\"line\"><span class=\"comment\">     * the &#123;<span class=\"doctag\">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class=\"doctag\">@link</span> Configuration&#125; class.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the class names, or an empty array if none</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">//返回要导入的类的全限定类名</span></span><br><span class=\"line\">    String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自定义Selector类实现ImportSelector接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserSelector</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImportSelector</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//导入User类</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;User.class.getName()&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注解更改，主启动类不需要更改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(UserSelector.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableUser &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试结果和方式1相同</p>\n<h3 id=\"4-ImportBeanDefinitionRegistrar（导入BeanDefinition）\"><a href=\"#4-ImportBeanDefinitionRegistrar（导入BeanDefinition）\" class=\"headerlink\" title=\"4. ImportBeanDefinitionRegistrar（导入BeanDefinition）\"></a>4. ImportBeanDefinitionRegistrar（导入BeanDefinition）</h3><p>修改Selector类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserSelector</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//传入Bean id和BeanDefinition, 这里直接new了一个</span></span><br><span class=\"line\">        registry.registerBeanDefinition(<span class=\"string\">&quot;ruizhi&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">RootBeanDefinition</span>(User.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果打印名称就是上面类注册的名称（我这打印的是”ruizhi”)</p>\n<h2 id=\"1-2-条件装配\"><a href=\"#1-2-条件装配\" class=\"headerlink\" title=\"1.2 条件装配\"></a>1.2 条件装配</h2><h3 id=\"1-Conditional\"><a href=\"#1-Conditional\" class=\"headerlink\" title=\"1. Conditional\"></a>1. Conditional</h3><p>稍微深入了解过Spring的老哥可能就会很清楚，Spring里面有一套<code>@Conditional</code>注解，最常见的就是<code>@ConditionalOnMissingBean(String[] BeanName)</code>（没有相应Bean就注入），<code>@ConditionalOnClass</code>（有相应Class就注入），有Bean就注入、没有class就注入等一堆注解。</p>\n<p><strong>作用</strong>：有了这些注解我们就可以很轻松的自定类来覆盖掉原本要自动装配的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//万恶之源，所有Conditional注解的根</span></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Conditional &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * All &#123;<span class=\"doctag\">@link</span> Condition&#125; classes that must &#123;<span class=\"doctag\">@linkplain</span> Condition#matches match&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * in order for the component to be registered.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tClass&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Condition</span>&gt;[] value();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Conditional会根据Condition来判断是否装配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Condition</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Determine if the condition matches.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context the condition context</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> metadata the metadata of the &#123;<span class=\"doctag\">@link</span> org.springframework.core.type.AnnotationMetadata class&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * or &#123;<span class=\"doctag\">@link</span> org.springframework.core.type.MethodMetadata method&#125; being checked</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; if the condition matches and the component can be registered,</span></span><br><span class=\"line\"><span class=\"comment\">     * or &#123;<span class=\"doctag\">@code</span> false&#125; to veto the annotated component&#x27;s registration</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">//返回值为true，则注入相关Bean</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里我们可以想到，所有衍生出的注解都是根据匹配规则实现了自己<code>matches()</code>方法。</p>\n<p>看看<code>ConditionalOnMissingBean</code>验证下想法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Conditional(&#123;OnBeanCondition.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ConditionalOnMissingBean &#123;</span><br><span class=\"line\">    Class&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] type() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt;[] ignored() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] ignoredType() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Annotation</span>&gt;[] annotation() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] name() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    SearchStrategy <span class=\"title function_\">search</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> SearchStrategy.ALL;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt;[] parameterizedContainer() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这时候你自信满满的打开IDEA看了下源码，在OnBeanCondition里面怎么都没找到matches()方法，只有一个 <code>getMatchOutcome()</code>？？？怎么回事？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Order(Ordered.LOWEST_PRECEDENCE)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OnBeanCondition</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">FilteringSpringBootCondition</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ConfigurationCondition</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> ConditionOutcome <span class=\"title function_\">getMatchOutcome</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">ConditionMessage</span> <span class=\"variable\">matchMessage</span> <span class=\"operator\">=</span> ConditionMessage.empty();</span><br><span class=\"line\">\t\t<span class=\"type\">MergedAnnotations</span> <span class=\"variable\">annotations</span> <span class=\"operator\">=</span> metadata.getAnnotations();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (annotations.isPresent(ConditionalOnBean.class)) &#123;</span><br><span class=\"line\">\t\t\tSpec&lt;ConditionalOnBean&gt; spec = <span class=\"keyword\">new</span> <span class=\"title class_\">Spec</span>&lt;&gt;(context, metadata, annotations, ConditionalOnBean.class);</span><br><span class=\"line\">\t\t\t<span class=\"type\">MatchResult</span> <span class=\"variable\">matchResult</span> <span class=\"operator\">=</span> getMatchingBeans(context, spec);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!matchResult.isAllMatched()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">String</span> <span class=\"variable\">reason</span> <span class=\"operator\">=</span> createOnBeanNoMatchReason(matchResult);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ConditionOutcome.noMatch(spec.message().because(reason));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmatchMessage = spec.message(matchMessage).found(<span class=\"string\">&quot;bean&quot;</span>, <span class=\"string\">&quot;beans&quot;</span>).items(Style.QUOTE,</span><br><span class=\"line\">\t\t\t\t\tmatchResult.getNamesOfAllMatches());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) &#123;</span><br><span class=\"line\">\t\t\tSpec&lt;ConditionalOnSingleCandidate&gt; spec = <span class=\"keyword\">new</span> <span class=\"title class_\">SingleCandidateSpec</span>(context, metadata, annotations);</span><br><span class=\"line\">\t\t\t<span class=\"type\">MatchResult</span> <span class=\"variable\">matchResult</span> <span class=\"operator\">=</span> getMatchingBeans(context, spec);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!matchResult.isAllMatched()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ConditionOutcome.noMatch(spec.message().didNotFind(<span class=\"string\">&quot;any beans&quot;</span>).atAll());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasSingleAutowireCandidate(context.getBeanFactory(), matchResult.getNamesOfAllMatches(),</span><br><span class=\"line\">\t\t\t\t\tspec.getStrategy() == SearchStrategy.ALL)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ConditionOutcome.noMatch(spec.message().didNotFind(<span class=\"string\">&quot;a primary bean from beans&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t\t.items(Style.QUOTE, matchResult.getNamesOfAllMatches()));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmatchMessage = spec.message(matchMessage).found(<span class=\"string\">&quot;a primary bean from beans&quot;</span>).items(Style.QUOTE,</span><br><span class=\"line\">\t\t\t\t\tmatchResult.getNamesOfAllMatches());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) &#123;</span><br><span class=\"line\">\t\t\tSpec&lt;ConditionalOnMissingBean&gt; spec = <span class=\"keyword\">new</span> <span class=\"title class_\">Spec</span>&lt;&gt;(context, metadata, annotations,</span><br><span class=\"line\">\t\t\t\t\tConditionalOnMissingBean.class);</span><br><span class=\"line\">\t\t\t<span class=\"type\">MatchResult</span> <span class=\"variable\">matchResult</span> <span class=\"operator\">=</span> getMatchingBeans(context, spec);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (matchResult.isAnyMatched()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">String</span> <span class=\"variable\">reason</span> <span class=\"operator\">=</span> createOnMissingBeanNoMatchReason(matchResult);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ConditionOutcome.noMatch(spec.message().because(reason));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmatchMessage = spec.message(matchMessage).didNotFind(<span class=\"string\">&quot;any beans&quot;</span>).atAll();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ConditionOutcome.match(matchMessage);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那就去看看父类吧，果然最终在<code>FilteringSpringBootCondition</code>父类<code>SpringBootCondition</code>里找到了答案</p>\n<p>可以看到Spring对<code>matches()</code>方法进行了一层的封装，在<code>SpringBootCondition</code>里<code>matches()</code>方法会调用抽象的<code>getMatchOutcome</code>(有种模版模式的感觉)，子类只需要实现<code>getMatchOutcome()</code>就行了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringBootCondition</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Condition</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">classOrMethodName</span> <span class=\"operator\">=</span> getClassOrMethodName(metadata);</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">ConditionOutcome</span> <span class=\"variable\">outcome</span> <span class=\"operator\">=</span> getMatchOutcome(context, metadata);</span><br><span class=\"line\">\t\t\tlogOutcome(classOrMethodName, outcome);</span><br><span class=\"line\">\t\t\trecordEvaluation(context, classOrMethodName, outcome);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> outcome.isMatch();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (NoClassDefFoundError ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Could not evaluate condition on &quot;</span> + classOrMethodName + <span class=\"string\">&quot; due to &quot;</span></span><br><span class=\"line\">\t\t\t\t\t+ ex.getMessage() + <span class=\"string\">&quot; not found. Make sure your own configuration does not rely on &quot;</span></span><br><span class=\"line\">\t\t\t\t\t+ <span class=\"string\">&quot;that class. This can also happen if you are &quot;</span></span><br><span class=\"line\">\t\t\t\t\t+ <span class=\"string\">&quot;@ComponentScanning a springframework package (e.g. if you &quot;</span></span><br><span class=\"line\">\t\t\t\t\t+ <span class=\"string\">&quot;put a @ComponentScan in the default package by mistake)&quot;</span>, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (RuntimeException ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Error processing condition on &quot;</span> + getName(metadata), ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Profile\"><a href=\"#2-Profile\" class=\"headerlink\" title=\"2. Profile\"></a>2. Profile</h3><p>除了Conditional，Spring中还有<code>@profile</code>注解来根据环境来注入Bean。</p>\n<p><strong>Environment</strong>（环境）:Spring会把一些信息封装到Environment对象中，比如application.properties中的内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//继承PropertyResolver来解析资源</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Environment</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">PropertyResolver</span> &#123;</span><br><span class=\"line\">    String[] getActiveProfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] getDefaultProfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@deprecated</span> */</span></span><br><span class=\"line\">    <span class=\"meta\">@Deprecated</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">acceptsProfiles</span><span class=\"params\">(String... var1)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">acceptsProfiles</span><span class=\"params\">(Profiles var1)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试，别忘了把Configuration路径改回来</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebTestApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*需要再容器refresh()之前传入profile值，可以在启动前设置参数`-DSpring.profiles.active=ruizhi`，这里就直接new一个context了*/</span></span><br><span class=\"line\">        <span class=\"type\">AnnotationConfigApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>();</span><br><span class=\"line\">        ctx.getEnvironment().setActiveProfiles(<span class=\"string\">&quot;ruizhi&quot;</span>);</span><br><span class=\"line\">        ctx.register(ImportConfiguration.class);</span><br><span class=\"line\">        ctx.refresh();</span><br><span class=\"line\">        String[] beanNamesForType = ctx.getBeanNamesForType(User.class);</span><br><span class=\"line\">        System.out.println(beanNamesForType[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加上profile注解，(可以更改值，自行观察是否注入User)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImportConfiguration</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Profile(&quot;ruizhi&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">getUser</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">        user.setId(<span class=\"number\">36L</span>);</span><br><span class=\"line\">        user.setName(<span class=\"string\">&quot;ruizhi&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li><code>@Conditional</code>主要是用来让用户能根据具体业务场景自己配置或者自定义Bean来满足需求</li>\n<li><code>@Profile</code>主要是为了针对不同的环境提供不同的Bean（本地测试与线上生产环境的日志打印路径、数据库等组件使用肯定不同）</li>\n</ul>\n<h1 id=\"2-SpringBoot自动装配\"><a href=\"#2-SpringBoot自动装配\" class=\"headerlink\" title=\"2. SpringBoot自动装配\"></a>2. SpringBoot自动装配</h1><p>点开注解<code>@SpringBootApplication</code>，你会发现上面标注了一个<code>@EnableAutoConfiguration</code>（允许自动装配）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"meta\">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Environment property that can be used to override when auto-configuration is</span></span><br><span class=\"line\"><span class=\"comment\">\t * enabled.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">ENABLED_OVERRIDE_PROPERTY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the classes to exclude</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tClass&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class=\"line\"><span class=\"comment\">\t * applied.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the class names to exclude</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@since</span> 1.3.0</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tString[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到<code>EnableAutoConfiguration</code>导入了<code>AutoConfigurationImportSelector.class</code>，继续深入看看</p>\n<h2 id=\"2-1-AutoConfigurationImportSelector\"><a href=\"#2-1-AutoConfigurationImportSelector\" class=\"headerlink\" title=\"2.1 AutoConfigurationImportSelector\"></a>2.1 AutoConfigurationImportSelector</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模块装配中导入Selector的方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AutoConfigurationImportSelector</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DeferredImportSelector</span>, BeanClassLoaderAware,</span><br><span class=\"line\">\t\tResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">          ...    </span><br><span class=\"line\">     <span class=\"comment\">//只要在这个方法返回类的全限定名就行了</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> NO_IMPORTS;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">         <span class=\"comment\">//加载自动配置类，拿到类的全限定名</span></span><br><span class=\"line\">\t\t<span class=\"type\">AutoConfigurationEntry</span> <span class=\"variable\">autoConfigurationEntry</span> <span class=\"operator\">=</span> getAutoConfigurationEntry(annotationMetadata);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">     <span class=\"keyword\">protected</span> AutoConfigurationEntry <span class=\"title function_\">getAutoConfigurationEntry</span><span class=\"params\">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> EMPTY_ENTRY;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">AnnotationAttributes</span> <span class=\"variable\">attributes</span> <span class=\"operator\">=</span> getAttributes(annotationMetadata);</span><br><span class=\"line\">         <span class=\"comment\">//加载候选类</span></span><br><span class=\"line\">\t\tList&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class=\"line\">\t\tconfigurations = removeDuplicates(configurations);</span><br><span class=\"line\">\t\tSet&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class=\"line\">\t\tcheckExcludedClasses(configurations, exclusions);</span><br><span class=\"line\">\t\tconfigurations.removeAll(exclusions);</span><br><span class=\"line\">\t\tconfigurations = getConfigurationClassFilter().filter(configurations);</span><br><span class=\"line\">\t\tfireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">      <span class=\"keyword\">protected</span> List&lt;String&gt; <span class=\"title function_\">getCandidateConfigurations</span><span class=\"params\">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">//通过SpringFactoriesLoader加载类名</span></span><br><span class=\"line\">\t\tList&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class=\"line\">\t\t\t\tgetBeanClassLoader());</span><br><span class=\"line\">\t\tAssert.notEmpty(configurations, <span class=\"string\">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class=\"line\">\t\t\t\t+ <span class=\"string\">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> configurations;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">return</span> configurations;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到经过层层封装，Spring把具体加载的过程委托给了<strong>SpringFactoriesLoader</strong>类，（终于可以到具体的加载逻辑了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringFactoriesLoader</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">FACTORIES_RESOURCE_LOCATION</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title function_\">loadFactoryNames</span><span class=\"params\">(Class&lt;?&gt; factoryType, <span class=\"meta\">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//factoryTypeName是EnableAutoConfiguration</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">factoryTypeName</span> <span class=\"operator\">=</span> factoryType.getName();</span><br><span class=\"line\">        <span class=\"comment\">//封装成Map，返回key是EnableAutoConfiguration的类名</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class=\"title function_\">loadSpringFactories</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class=\"line\">\t\tMultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (result != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//加载路径就是META-INF/spring.factories</span></span><br><span class=\"line\">\t\t\tEnumeration&lt;URL&gt; urls = (classLoader != <span class=\"literal\">null</span> ?</span><br><span class=\"line\">\t\t\t\t\tclassLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class=\"line\">\t\t\t\t\tClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class=\"line\">\t\t\tresult = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class=\"line\">            <span class=\"comment\">//遍历文件并把它放到缓存里</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (urls.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">URL</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> urls.nextElement();</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">UrlResource</span> <span class=\"variable\">resource</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UrlResource</span>(url);</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">Properties</span> <span class=\"variable\">properties</span> <span class=\"operator\">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"type\">String</span> <span class=\"variable\">factoryTypeName</span> <span class=\"operator\">=</span> ((String) entry.getKey()).trim();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tresult.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcache.put(classLoader, result);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class=\"line\">\t\t\t\t\tFACTORIES_RESOURCE_LOCATION + <span class=\"string\">&quot;]&quot;</span>, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过上述过程我们也就可以想到Spring加载Starter，也是加载了starter资源目录下<code>META-INF/spring.factories</code>文件，当然自定义Starter也可以通过编写这一文件将需要的Bean导入到容器中。</p>\n<h2 id=\"2-2-AutoConfigurationPackage\"><a href=\"#2-2-AutoConfigurationPackage\" class=\"headerlink\" title=\"2.2 @AutoConfigurationPackage\"></a>2.2 @AutoConfigurationPackage</h2><p>先点进去看看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> AutoConfigurationPackage &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Base packages that should be registered with &#123;<span class=\"doctag\">@link</span> AutoConfigurationPackages&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">\t * Use &#123;<span class=\"doctag\">@link</span> #basePackageClasses&#125; for a type-safe alternative to String-based package</span></span><br><span class=\"line\"><span class=\"comment\">\t * names.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the back package names</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@since</span> 2.3.0</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tString[] basePackages() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Type-safe alternative to &#123;<span class=\"doctag\">@link</span> #basePackages&#125; for specifying the packages to be</span></span><br><span class=\"line\"><span class=\"comment\">\t * registered with &#123;<span class=\"doctag\">@link</span> AutoConfigurationPackages&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">\t * Consider creating a special no-op marker class or interface in each package that</span></span><br><span class=\"line\"><span class=\"comment\">\t * serves no purpose other than being referenced by this attribute.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the base package classes</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@since</span> 2.3.0</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tClass&lt;?&gt;[] basePackageClasses() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到<code>AutoConfigurationPackage</code>上面还有一个Import注解，导入了<code>AutoConfigurationPackages.Registrar.class</code>，继续往下看看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模块装配中导入BeanDefinition的方式</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Registrar</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImportBeanDefinitionRegistrar</span>, DeterminableImports &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//调用外部的register方法，AnnotationMetadata是被标注注解的类的元信息（这里主要是为了获取主类包名）</span></span><br><span class=\"line\">            <span class=\"comment\">//关于AnnotationMetadata以及BeanDefinitionRegistry的相关信息自行查阅</span></span><br><span class=\"line\">\t\t\tregister(registry, <span class=\"keyword\">new</span> <span class=\"title class_\">PackageImports</span>(metadata).getPackageNames().toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> Set&lt;Object&gt; <span class=\"title function_\">determineImports</span><span class=\"params\">(AnnotationMetadata metadata)</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Collections.singleton(<span class=\"keyword\">new</span> <span class=\"title class_\">PackageImports</span>(metadata));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是PackageImports是什么？点进去看看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PackageImports</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; packageNames;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tPackageImports(AnnotationMetadata metadata) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">AnnotationAttributes</span> <span class=\"variable\">attributes</span> <span class=\"operator\">=</span> AnnotationAttributes</span><br><span class=\"line\">\t\t\t\t\t.fromMap(metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), <span class=\"literal\">false</span>));</span><br><span class=\"line\">\t\t\tList&lt;String&gt; packageNames = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">            <span class=\"comment\">//判断自己有没有配置basePackages</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (String basePackage : attributes.getStringArray(<span class=\"string\">&quot;basePackages&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t\tpackageNames.add(basePackage);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (Class&lt;?&gt; basePackageClass : attributes.getClassArray(<span class=\"string\">&quot;basePackageClasses&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t\tpackageNames.add(basePackageClass.getPackage().getName());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">            <span class=\"comment\">//默认空的会自动添加类的包路径</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (packageNames.isEmpty()) &#123;</span><br><span class=\"line\">\t\t\t\tpackageNames.add(ClassUtils.getPackageName(metadata.getClassName()));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">this</span>.packageNames = Collections.unmodifiableList(packageNames);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h1><p><code>@SpringBootApplication</code>上标注了<code>@EnableAutoConfiguration</code>，这自动装配的起点。</p>\n<ol>\n<li><p>导入starter及Spring运行需要的类</p>\n<ul>\n<li><p><code>@EnableAutoConfiguration </code>上标注了<code>@Import(AutoConfigurationImportSelector.class)</code></p>\n</li>\n<li><p>根据模块装配规则<code>AutoConfigurationImportSelector</code>的父类实现了<code>ImportSelector</code>接口，重写了<code>selectImports()</code>方法。</p>\n</li>\n<li><p>Spring内部通过层层过滤，最终委托给<code>SpringFactoriesLoader</code>中<code>loadFactoryNames()</code>方法来调用<code>loadSpringFactories()</code>，并过滤返回值key是<code>EnableAutoConfiguration</code>的value</p>\n</li>\n<li><p><code>loadSpringFactories()</code>方法会解析资源目录下”META-INF&#x2F;spring.factories”文件，并将数据封装成Map类型</p>\n</li>\n<li><p>之后将得到的数据层层返回上去，在selectImports()返回要加载的类名（也就是META-INF&#x2F;spring.factories文件中定义的EnableAutoConfiguration的类）</p>\n</li>\n</ul>\n</li>\n<li><p>导入自己编写的Bean</p>\n<ul>\n<li><code>@AutoConfigurationPackage</code>上标注了<code>@Import(AutoConfigurationPackages.Registrar.class)</code></li>\n<li>根据模块装配规则&#96;&#96;AutoConfigurationPackages.Registrar<code>实现了</code>ImportBeanDefinitionRegistrar<code>接口，重写了</code>registerBeanDefinitions()&#96;方法。</li>\n<li><code>registerBeanDefinitions()</code>会调用<code>register()</code>方法来注册<code>PackageImports</code>中封装的包名</li>\n<li><code>PackageImports</code>会解析是否配置需要扫描的包名，默认是启动类所在包</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"length":2899,"excerpt":"<p>SpringBoot自动装配 &#x3D; 模块装配 + 条件装配</p>\n<p><code>@SpringBootApplication</code>上标注了<code>@EnableAutoConfiguration</code>，这自动装配的起点。</p>\n<ol>\n<li><p>导入starter及Spring运行需要的类</p>\n<ul>\n<li><p><code>@EnableAutoConfiguration </code>上标注了<code>@Import(AutoConfigurationImportSelector.class)</code></p>\n</li>\n<li><p>根据模块装配规则<code>AutoConfigurationImportSelector</code>的父类实现了<code>ImportSelector</code>接口，重写了<code>selectImports()</code>方法。</p>\n</li>\n<li><p>Spring内部通过层层过滤，最终委托给<code>SpringFactoriesLoader</code>中<code>loadFactoryNames()</code>方法来调用<code>loadSpringFactories()</code>，并过滤返回值key是<code>EnableAutoConfiguration</code>的value</p>\n</li>\n<li><p><code>loadSpringFactories()</code>方法会解析资源目录下”META-INF&#x2F;spring.factories”文件，并将数据封装成Map类型</p>\n</li>\n<li><p>之后将得到的数据层层返回上去，在selectImports()返回要加载的类名（也就是META-INF&#x2F;spring.factories文件中定义的EnableAutoConfiguration的类）</p>\n</li>\n</ul>\n</li>\n<li><p>导入自己编写的Bean</p>\n<ul>\n<li><code>@AutoConfigurationPackage</code>上标注了<code>@Import(AutoConfigurationPackages.Registrar.class)</code></li>\n<li>根据模块装配规则&#96;&#96;AutoConfigurationPackages.Registrar<code>实现了</code>ImportBeanDefinitionRegistrar<code>接口，重写了</code>registerBeanDefinitions()&#96;方法。</li>\n<li><code>registerBeanDefinitions()</code>会调用<code>register()</code>方法来注册<code>PackageImports</code>中封装的包名</li>\n<li><code>PackageImports</code>会解析是否配置需要扫描的包名，默认是启动类所在包</li>\n</ul>\n</li>\n</ol>","more":"<h1 id=\"1-Spring中的装配\"><a href=\"#1-Spring中的装配\" class=\"headerlink\" title=\"1. Spring中的装配\"></a>1. Spring中的装配</h1><p>Tips：框架源码类文章建议自己打开IDEA跟着看看类之间的关系</p>\n<h2 id=\"1-1-模块装配\"><a href=\"#1-1-模块装配\" class=\"headerlink\" title=\"1.1 模块装配\"></a>1.1 模块装配</h2><p>模块装配主要是通过<code>@Import</code>注解来实现的，听名字就知道是用来导入类的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Spring中著名的EnableAutoConfiguration注解</span></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"comment\">//不是导入类吗？这导入了个什么玩意儿?</span></span><br><span class=\"line\"><span class=\"meta\">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">ENABLED_OVERRIDE_PROPERTY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Import注解源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* @author Chris Beams</span></span><br><span class=\"line\"><span class=\"comment\"> * @author Juergen Hoeller</span></span><br><span class=\"line\"><span class=\"comment\"> * @since 3.0</span></span><br><span class=\"line\"><span class=\"comment\"> * @see Configuration</span></span><br><span class=\"line\"><span class=\"comment\"> * @see ImportSelector</span></span><br><span class=\"line\"><span class=\"comment\"> * @see ImportBeanDefinitionRegistrar</span></span><br><span class=\"line\"><span class=\"comment\"> * @see ImportResource</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Import &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#123;<span class=\"doctag\">@link</span> Configuration <span class=\"doctag\">@Configuration</span>&#125;, &#123;<span class=\"doctag\">@link</span> ImportSelector&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">\t * &#123;<span class=\"doctag\">@link</span> ImportBeanDefinitionRegistrar&#125;, or regular component classes to import.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tClass&lt;?&gt;[] value();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很清楚的看到了四种导入方式<code>Configuration</code>，<code>ImportSelector</code>、<code>ImportBeanDefinitionRegistrar</code>、<code>ImportResource</code></p>\n<h3 id=\"1-ImportResource（导入普通类）\"><a href=\"#1-ImportResource（导入普通类）\" class=\"headerlink\" title=\"1. ImportResource（导入普通类）\"></a>1. ImportResource（导入普通类）</h3><p>需要导入的User类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自定义的注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(User.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableUser &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>启动类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">//标注自定义注解，也可以标注在配置类等地方</span></span><br><span class=\"line\"><span class=\"meta\">@EnableUser</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebTestApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> SpringApplication.run(WebTestApplication.class, args);</span><br><span class=\"line\">        String[] beanNamesForType = context.getBeanNamesForType(User.class);</span><br><span class=\"line\">        System.out.println(beanNamesForType[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>成功打印出了User</p>\n<p><img src=\"/2024/04/22/Spring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/%E6%A8%A1%E5%9D%97%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F%E4%B8%80.png\" alt=\"模块装配方式一\"></p>\n<h3 id=\"2-Configuration-导入配置类\"><a href=\"#2-Configuration-导入配置类\" class=\"headerlink\" title=\"2. Configuration (导入配置类)\"></a>2. Configuration (导入配置类)</h3><p>建立配置类，将配置类放到启动类包扫描不到的地方（默认会扫描主启动类所在包下的所有类，我这里就直接放在主启动类包上）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImportConfiguration</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">getUser</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">        user.setId(<span class=\"number\">36L</span>);</span><br><span class=\"line\">        user.setName(<span class=\"string\">&quot;ruizhi&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>修改注解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(User.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableUser &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试，依旧可以打印出信息（具体对象注入名称问题，自行查阅）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableUser</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebTestApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ConfigurableApplicationContext</span> <span class=\"variable\">context</span> <span class=\"operator\">=</span> SpringApplication.run(WebTestApplication.class, args);</span><br><span class=\"line\">        String[] beanNamesForType = context.getBeanNamesForType(User.class);</span><br><span class=\"line\">        System.out.println(beanNamesForType[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/04/22/Spring%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/%E6%A8%A1%E5%9D%97%E8%A3%85%E9%85%8D%E4%BA%8C.png\" alt=\"模块装配二\"></p>\n<h3 id=\"3-ImportSelector（导入Selector）\"><a href=\"#3-ImportSelector（导入Selector）\" class=\"headerlink\" title=\"3. ImportSelector（导入Selector）\"></a>3. ImportSelector（导入Selector）</h3><p>ImportSelector接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ImportSelector</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Select and return the names of which class(es) should be imported based on</span></span><br><span class=\"line\"><span class=\"comment\">     * the &#123;<span class=\"doctag\">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class=\"doctag\">@link</span> Configuration&#125; class.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the class names, or an empty array if none</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">//返回要导入的类的全限定类名</span></span><br><span class=\"line\">    String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自定义Selector类实现ImportSelector接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserSelector</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImportSelector</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//导入User类</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[]&#123;User.class.getName()&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注解更改，主启动类不需要更改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Import(UserSelector.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableUser &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试结果和方式1相同</p>\n<h3 id=\"4-ImportBeanDefinitionRegistrar（导入BeanDefinition）\"><a href=\"#4-ImportBeanDefinitionRegistrar（导入BeanDefinition）\" class=\"headerlink\" title=\"4. ImportBeanDefinitionRegistrar（导入BeanDefinition）\"></a>4. ImportBeanDefinitionRegistrar（导入BeanDefinition）</h3><p>修改Selector类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserSelector</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//传入Bean id和BeanDefinition, 这里直接new了一个</span></span><br><span class=\"line\">        registry.registerBeanDefinition(<span class=\"string\">&quot;ruizhi&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">RootBeanDefinition</span>(User.class));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果打印名称就是上面类注册的名称（我这打印的是”ruizhi”)</p>\n<h2 id=\"1-2-条件装配\"><a href=\"#1-2-条件装配\" class=\"headerlink\" title=\"1.2 条件装配\"></a>1.2 条件装配</h2><h3 id=\"1-Conditional\"><a href=\"#1-Conditional\" class=\"headerlink\" title=\"1. Conditional\"></a>1. Conditional</h3><p>稍微深入了解过Spring的老哥可能就会很清楚，Spring里面有一套<code>@Conditional</code>注解，最常见的就是<code>@ConditionalOnMissingBean(String[] BeanName)</code>（没有相应Bean就注入），<code>@ConditionalOnClass</code>（有相应Class就注入），有Bean就注入、没有class就注入等一堆注解。</p>\n<p><strong>作用</strong>：有了这些注解我们就可以很轻松的自定类来覆盖掉原本要自动装配的类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//万恶之源，所有Conditional注解的根</span></span><br><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Conditional &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * All &#123;<span class=\"doctag\">@link</span> Condition&#125; classes that must &#123;<span class=\"doctag\">@linkplain</span> Condition#matches match&#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t * in order for the component to be registered.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tClass&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Condition</span>&gt;[] value();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Conditional会根据Condition来判断是否装配</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Condition</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Determine if the condition matches.</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context the condition context</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> metadata the metadata of the &#123;<span class=\"doctag\">@link</span> org.springframework.core.type.AnnotationMetadata class&#125;</span></span><br><span class=\"line\"><span class=\"comment\">     * or &#123;<span class=\"doctag\">@link</span> org.springframework.core.type.MethodMetadata method&#125; being checked</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> &#123;<span class=\"doctag\">@code</span> true&#125; if the condition matches and the component can be registered,</span></span><br><span class=\"line\"><span class=\"comment\">     * or &#123;<span class=\"doctag\">@code</span> false&#125; to veto the annotated component&#x27;s registration</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"comment\">//返回值为true，则注入相关Bean</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里我们可以想到，所有衍生出的注解都是根据匹配规则实现了自己<code>matches()</code>方法。</p>\n<p>看看<code>ConditionalOnMissingBean</code>验证下想法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Conditional(&#123;OnBeanCondition.class&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> ConditionalOnMissingBean &#123;</span><br><span class=\"line\">    Class&lt;?&gt;[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] type() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt;[] ignored() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] ignoredType() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;? <span class=\"keyword\">extends</span> <span class=\"title class_\">Annotation</span>&gt;[] annotation() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] name() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    SearchStrategy <span class=\"title function_\">search</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> SearchStrategy.ALL;</span><br><span class=\"line\"></span><br><span class=\"line\">    Class&lt;?&gt;[] parameterizedContainer() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这时候你自信满满的打开IDEA看了下源码，在OnBeanCondition里面怎么都没找到matches()方法，只有一个 <code>getMatchOutcome()</code>？？？怎么回事？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Order(Ordered.LOWEST_PRECEDENCE)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OnBeanCondition</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">FilteringSpringBootCondition</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ConfigurationCondition</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> ConditionOutcome <span class=\"title function_\">getMatchOutcome</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">ConditionMessage</span> <span class=\"variable\">matchMessage</span> <span class=\"operator\">=</span> ConditionMessage.empty();</span><br><span class=\"line\">\t\t<span class=\"type\">MergedAnnotations</span> <span class=\"variable\">annotations</span> <span class=\"operator\">=</span> metadata.getAnnotations();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (annotations.isPresent(ConditionalOnBean.class)) &#123;</span><br><span class=\"line\">\t\t\tSpec&lt;ConditionalOnBean&gt; spec = <span class=\"keyword\">new</span> <span class=\"title class_\">Spec</span>&lt;&gt;(context, metadata, annotations, ConditionalOnBean.class);</span><br><span class=\"line\">\t\t\t<span class=\"type\">MatchResult</span> <span class=\"variable\">matchResult</span> <span class=\"operator\">=</span> getMatchingBeans(context, spec);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!matchResult.isAllMatched()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">String</span> <span class=\"variable\">reason</span> <span class=\"operator\">=</span> createOnBeanNoMatchReason(matchResult);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ConditionOutcome.noMatch(spec.message().because(reason));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmatchMessage = spec.message(matchMessage).found(<span class=\"string\">&quot;bean&quot;</span>, <span class=\"string\">&quot;beans&quot;</span>).items(Style.QUOTE,</span><br><span class=\"line\">\t\t\t\t\tmatchResult.getNamesOfAllMatches());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) &#123;</span><br><span class=\"line\">\t\t\tSpec&lt;ConditionalOnSingleCandidate&gt; spec = <span class=\"keyword\">new</span> <span class=\"title class_\">SingleCandidateSpec</span>(context, metadata, annotations);</span><br><span class=\"line\">\t\t\t<span class=\"type\">MatchResult</span> <span class=\"variable\">matchResult</span> <span class=\"operator\">=</span> getMatchingBeans(context, spec);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!matchResult.isAllMatched()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ConditionOutcome.noMatch(spec.message().didNotFind(<span class=\"string\">&quot;any beans&quot;</span>).atAll());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasSingleAutowireCandidate(context.getBeanFactory(), matchResult.getNamesOfAllMatches(),</span><br><span class=\"line\">\t\t\t\t\tspec.getStrategy() == SearchStrategy.ALL)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ConditionOutcome.noMatch(spec.message().didNotFind(<span class=\"string\">&quot;a primary bean from beans&quot;</span>)</span><br><span class=\"line\">\t\t\t\t\t\t.items(Style.QUOTE, matchResult.getNamesOfAllMatches()));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmatchMessage = spec.message(matchMessage).found(<span class=\"string\">&quot;a primary bean from beans&quot;</span>).items(Style.QUOTE,</span><br><span class=\"line\">\t\t\t\t\tmatchResult.getNamesOfAllMatches());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) &#123;</span><br><span class=\"line\">\t\t\tSpec&lt;ConditionalOnMissingBean&gt; spec = <span class=\"keyword\">new</span> <span class=\"title class_\">Spec</span>&lt;&gt;(context, metadata, annotations,</span><br><span class=\"line\">\t\t\t\t\tConditionalOnMissingBean.class);</span><br><span class=\"line\">\t\t\t<span class=\"type\">MatchResult</span> <span class=\"variable\">matchResult</span> <span class=\"operator\">=</span> getMatchingBeans(context, spec);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (matchResult.isAnyMatched()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">String</span> <span class=\"variable\">reason</span> <span class=\"operator\">=</span> createOnMissingBeanNoMatchReason(matchResult);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ConditionOutcome.noMatch(spec.message().because(reason));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tmatchMessage = spec.message(matchMessage).didNotFind(<span class=\"string\">&quot;any beans&quot;</span>).atAll();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ConditionOutcome.match(matchMessage);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那就去看看父类吧，果然最终在<code>FilteringSpringBootCondition</code>父类<code>SpringBootCondition</code>里找到了答案</p>\n<p>可以看到Spring对<code>matches()</code>方法进行了一层的封装，在<code>SpringBootCondition</code>里<code>matches()</code>方法会调用抽象的<code>getMatchOutcome</code>(有种模版模式的感觉)，子类只需要实现<code>getMatchOutcome()</code>就行了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringBootCondition</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Condition</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">classOrMethodName</span> <span class=\"operator\">=</span> getClassOrMethodName(metadata);</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">ConditionOutcome</span> <span class=\"variable\">outcome</span> <span class=\"operator\">=</span> getMatchOutcome(context, metadata);</span><br><span class=\"line\">\t\t\tlogOutcome(classOrMethodName, outcome);</span><br><span class=\"line\">\t\t\trecordEvaluation(context, classOrMethodName, outcome);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> outcome.isMatch();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (NoClassDefFoundError ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Could not evaluate condition on &quot;</span> + classOrMethodName + <span class=\"string\">&quot; due to &quot;</span></span><br><span class=\"line\">\t\t\t\t\t+ ex.getMessage() + <span class=\"string\">&quot; not found. Make sure your own configuration does not rely on &quot;</span></span><br><span class=\"line\">\t\t\t\t\t+ <span class=\"string\">&quot;that class. This can also happen if you are &quot;</span></span><br><span class=\"line\">\t\t\t\t\t+ <span class=\"string\">&quot;@ComponentScanning a springframework package (e.g. if you &quot;</span></span><br><span class=\"line\">\t\t\t\t\t+ <span class=\"string\">&quot;put a @ComponentScan in the default package by mistake)&quot;</span>, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (RuntimeException ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Error processing condition on &quot;</span> + getName(metadata), ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-Profile\"><a href=\"#2-Profile\" class=\"headerlink\" title=\"2. Profile\"></a>2. Profile</h3><p>除了Conditional，Spring中还有<code>@profile</code>注解来根据环境来注入Bean。</p>\n<p><strong>Environment</strong>（环境）:Spring会把一些信息封装到Environment对象中，比如application.properties中的内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//继承PropertyResolver来解析资源</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Environment</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">PropertyResolver</span> &#123;</span><br><span class=\"line\">    String[] getActiveProfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">    String[] getDefaultProfiles();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@deprecated</span> */</span></span><br><span class=\"line\">    <span class=\"meta\">@Deprecated</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">acceptsProfiles</span><span class=\"params\">(String... var1)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">acceptsProfiles</span><span class=\"params\">(Profiles var1)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试，别忘了把Configuration路径改回来</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebTestApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*需要再容器refresh()之前传入profile值，可以在启动前设置参数`-DSpring.profiles.active=ruizhi`，这里就直接new一个context了*/</span></span><br><span class=\"line\">        <span class=\"type\">AnnotationConfigApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AnnotationConfigApplicationContext</span>();</span><br><span class=\"line\">        ctx.getEnvironment().setActiveProfiles(<span class=\"string\">&quot;ruizhi&quot;</span>);</span><br><span class=\"line\">        ctx.register(ImportConfiguration.class);</span><br><span class=\"line\">        ctx.refresh();</span><br><span class=\"line\">        String[] beanNamesForType = ctx.getBeanNamesForType(User.class);</span><br><span class=\"line\">        System.out.println(beanNamesForType[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加上profile注解，(可以更改值，自行观察是否注入User)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ImportConfiguration</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Profile(&quot;ruizhi&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"title function_\">getUser</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">        user.setId(<span class=\"number\">36L</span>);</span><br><span class=\"line\">        user.setName(<span class=\"string\">&quot;ruizhi&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><ul>\n<li><code>@Conditional</code>主要是用来让用户能根据具体业务场景自己配置或者自定义Bean来满足需求</li>\n<li><code>@Profile</code>主要是为了针对不同的环境提供不同的Bean（本地测试与线上生产环境的日志打印路径、数据库等组件使用肯定不同）</li>\n</ul>\n<h1 id=\"2-SpringBoot自动装配\"><a href=\"#2-SpringBoot自动装配\" class=\"headerlink\" title=\"2. SpringBoot自动装配\"></a>2. SpringBoot自动装配</h1><p>点开注解<code>@SpringBootApplication</code>，你会发现上面标注了一个<code>@EnableAutoConfiguration</code>（允许自动装配）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigurationPackage</span></span><br><span class=\"line\"><span class=\"meta\">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> EnableAutoConfiguration &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Environment property that can be used to override when auto-configuration is</span></span><br><span class=\"line\"><span class=\"comment\">\t * enabled.</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"type\">String</span> <span class=\"variable\">ENABLED_OVERRIDE_PROPERTY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the classes to exclude</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tClass&lt;?&gt;[] exclude() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class=\"line\"><span class=\"comment\">\t * applied.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the class names to exclude</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@since</span> 1.3.0</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tString[] excludeName() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到<code>EnableAutoConfiguration</code>导入了<code>AutoConfigurationImportSelector.class</code>，继续深入看看</p>\n<h2 id=\"2-1-AutoConfigurationImportSelector\"><a href=\"#2-1-AutoConfigurationImportSelector\" class=\"headerlink\" title=\"2.1 AutoConfigurationImportSelector\"></a>2.1 AutoConfigurationImportSelector</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模块装配中导入Selector的方式</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AutoConfigurationImportSelector</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">DeferredImportSelector</span>, BeanClassLoaderAware,</span><br><span class=\"line\">\t\tResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">          ...    </span><br><span class=\"line\">     <span class=\"comment\">//只要在这个方法返回类的全限定名就行了</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> NO_IMPORTS;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">         <span class=\"comment\">//加载自动配置类，拿到类的全限定名</span></span><br><span class=\"line\">\t\t<span class=\"type\">AutoConfigurationEntry</span> <span class=\"variable\">autoConfigurationEntry</span> <span class=\"operator\">=</span> getAutoConfigurationEntry(annotationMetadata);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">     <span class=\"keyword\">protected</span> AutoConfigurationEntry <span class=\"title function_\">getAutoConfigurationEntry</span><span class=\"params\">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> EMPTY_ENTRY;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"type\">AnnotationAttributes</span> <span class=\"variable\">attributes</span> <span class=\"operator\">=</span> getAttributes(annotationMetadata);</span><br><span class=\"line\">         <span class=\"comment\">//加载候选类</span></span><br><span class=\"line\">\t\tList&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class=\"line\">\t\tconfigurations = removeDuplicates(configurations);</span><br><span class=\"line\">\t\tSet&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class=\"line\">\t\tcheckExcludedClasses(configurations, exclusions);</span><br><span class=\"line\">\t\tconfigurations.removeAll(exclusions);</span><br><span class=\"line\">\t\tconfigurations = getConfigurationClassFilter().filter(configurations);</span><br><span class=\"line\">\t\tfireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">      <span class=\"keyword\">protected</span> List&lt;String&gt; <span class=\"title function_\">getCandidateConfigurations</span><span class=\"params\">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">//通过SpringFactoriesLoader加载类名</span></span><br><span class=\"line\">\t\tList&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class=\"line\">\t\t\t\tgetBeanClassLoader());</span><br><span class=\"line\">\t\tAssert.notEmpty(configurations, <span class=\"string\">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class=\"line\">\t\t\t\t+ <span class=\"string\">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> configurations;</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">return</span> configurations;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到经过层层封装，Spring把具体加载的过程委托给了<strong>SpringFactoriesLoader</strong>类，（终于可以到具体的加载逻辑了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SpringFactoriesLoader</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">FACTORIES_RESOURCE_LOCATION</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title function_\">loadFactoryNames</span><span class=\"params\">(Class&lt;?&gt; factoryType, <span class=\"meta\">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//factoryTypeName是EnableAutoConfiguration</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">factoryTypeName</span> <span class=\"operator\">=</span> factoryType.getName();</span><br><span class=\"line\">        <span class=\"comment\">//封装成Map，返回key是EnableAutoConfiguration的类名</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class=\"title function_\">loadSpringFactories</span><span class=\"params\">(<span class=\"meta\">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class=\"line\">\t\tMultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (result != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//加载路径就是META-INF/spring.factories</span></span><br><span class=\"line\">\t\t\tEnumeration&lt;URL&gt; urls = (classLoader != <span class=\"literal\">null</span> ?</span><br><span class=\"line\">\t\t\t\t\tclassLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class=\"line\">\t\t\t\t\tClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class=\"line\">\t\t\tresult = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class=\"line\">            <span class=\"comment\">//遍历文件并把它放到缓存里</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (urls.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">URL</span> <span class=\"variable\">url</span> <span class=\"operator\">=</span> urls.nextElement();</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">UrlResource</span> <span class=\"variable\">resource</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UrlResource</span>(url);</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">Properties</span> <span class=\"variable\">properties</span> <span class=\"operator\">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"type\">String</span> <span class=\"variable\">factoryTypeName</span> <span class=\"operator\">=</span> ((String) entry.getKey()).trim();</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tresult.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcache.put(classLoader, result);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class=\"line\">\t\t\t\t\tFACTORIES_RESOURCE_LOCATION + <span class=\"string\">&quot;]&quot;</span>, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过上述过程我们也就可以想到Spring加载Starter，也是加载了starter资源目录下<code>META-INF/spring.factories</code>文件，当然自定义Starter也可以通过编写这一文件将需要的Bean导入到容器中。</p>\n<h2 id=\"2-2-AutoConfigurationPackage\"><a href=\"#2-2-AutoConfigurationPackage\" class=\"headerlink\" title=\"2.2 @AutoConfigurationPackage\"></a>2.2 @AutoConfigurationPackage</h2><p>先点进去看看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Import(AutoConfigurationPackages.Registrar.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> AutoConfigurationPackage &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Base packages that should be registered with &#123;<span class=\"doctag\">@link</span> AutoConfigurationPackages&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">\t * Use &#123;<span class=\"doctag\">@link</span> #basePackageClasses&#125; for a type-safe alternative to String-based package</span></span><br><span class=\"line\"><span class=\"comment\">\t * names.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the back package names</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@since</span> 2.3.0</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tString[] basePackages() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Type-safe alternative to &#123;<span class=\"doctag\">@link</span> #basePackages&#125; for specifying the packages to be</span></span><br><span class=\"line\"><span class=\"comment\">\t * registered with &#123;<span class=\"doctag\">@link</span> AutoConfigurationPackages&#125;.</span></span><br><span class=\"line\"><span class=\"comment\">\t * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">\t * Consider creating a special no-op marker class or interface in each package that</span></span><br><span class=\"line\"><span class=\"comment\">\t * serves no purpose other than being referenced by this attribute.</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span> the base package classes</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@since</span> 2.3.0</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\tClass&lt;?&gt;[] basePackageClasses() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到<code>AutoConfigurationPackage</code>上面还有一个Import注解，导入了<code>AutoConfigurationPackages.Registrar.class</code>，继续往下看看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模块装配中导入BeanDefinition的方式</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Registrar</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ImportBeanDefinitionRegistrar</span>, DeterminableImports &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">registerBeanDefinitions</span><span class=\"params\">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//调用外部的register方法，AnnotationMetadata是被标注注解的类的元信息（这里主要是为了获取主类包名）</span></span><br><span class=\"line\">            <span class=\"comment\">//关于AnnotationMetadata以及BeanDefinitionRegistry的相关信息自行查阅</span></span><br><span class=\"line\">\t\t\tregister(registry, <span class=\"keyword\">new</span> <span class=\"title class_\">PackageImports</span>(metadata).getPackageNames().toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[<span class=\"number\">0</span>]));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">public</span> Set&lt;Object&gt; <span class=\"title function_\">determineImports</span><span class=\"params\">(AnnotationMetadata metadata)</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Collections.singleton(<span class=\"keyword\">new</span> <span class=\"title class_\">PackageImports</span>(metadata));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是PackageImports是什么？点进去看看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PackageImports</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> List&lt;String&gt; packageNames;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tPackageImports(AnnotationMetadata metadata) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">AnnotationAttributes</span> <span class=\"variable\">attributes</span> <span class=\"operator\">=</span> AnnotationAttributes</span><br><span class=\"line\">\t\t\t\t\t.fromMap(metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), <span class=\"literal\">false</span>));</span><br><span class=\"line\">\t\t\tList&lt;String&gt; packageNames = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">            <span class=\"comment\">//判断自己有没有配置basePackages</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (String basePackage : attributes.getStringArray(<span class=\"string\">&quot;basePackages&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t\tpackageNames.add(basePackage);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (Class&lt;?&gt; basePackageClass : attributes.getClassArray(<span class=\"string\">&quot;basePackageClasses&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\t\tpackageNames.add(basePackageClass.getPackage().getName());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">            <span class=\"comment\">//默认空的会自动添加类的包路径</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (packageNames.isEmpty()) &#123;</span><br><span class=\"line\">\t\t\t\tpackageNames.add(ClassUtils.getPackageName(metadata.getClassName()));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">this</span>.packageNames = Collections.unmodifiableList(packageNames);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h1><p><code>@SpringBootApplication</code>上标注了<code>@EnableAutoConfiguration</code>，这自动装配的起点。</p>\n<ol>\n<li><p>导入starter及Spring运行需要的类</p>\n<ul>\n<li><p><code>@EnableAutoConfiguration </code>上标注了<code>@Import(AutoConfigurationImportSelector.class)</code></p>\n</li>\n<li><p>根据模块装配规则<code>AutoConfigurationImportSelector</code>的父类实现了<code>ImportSelector</code>接口，重写了<code>selectImports()</code>方法。</p>\n</li>\n<li><p>Spring内部通过层层过滤，最终委托给<code>SpringFactoriesLoader</code>中<code>loadFactoryNames()</code>方法来调用<code>loadSpringFactories()</code>，并过滤返回值key是<code>EnableAutoConfiguration</code>的value</p>\n</li>\n<li><p><code>loadSpringFactories()</code>方法会解析资源目录下”META-INF&#x2F;spring.factories”文件，并将数据封装成Map类型</p>\n</li>\n<li><p>之后将得到的数据层层返回上去，在selectImports()返回要加载的类名（也就是META-INF&#x2F;spring.factories文件中定义的EnableAutoConfiguration的类）</p>\n</li>\n</ul>\n</li>\n<li><p>导入自己编写的Bean</p>\n<ul>\n<li><code>@AutoConfigurationPackage</code>上标注了<code>@Import(AutoConfigurationPackages.Registrar.class)</code></li>\n<li>根据模块装配规则&#96;&#96;AutoConfigurationPackages.Registrar<code>实现了</code>ImportBeanDefinitionRegistrar<code>接口，重写了</code>registerBeanDefinitions()&#96;方法。</li>\n<li><code>registerBeanDefinitions()</code>会调用<code>register()</code>方法来注册<code>PackageImports</code>中封装的包名</li>\n<li><code>PackageImports</code>会解析是否配置需要扫描的包名，默认是启动类所在包</li>\n</ul>\n</li>\n</ol>"},{"title":"ThreadLocal小结","date":"2024-04-30T06:26:21.000Z","_content":"\n\n\n# ThreadLocal\n\nThreadLocal主要是为了解决多线程间信息隔离的问题（创建副本，用空间换时间）。\n\n```java\n//泛型为需要共享的数据的类型\npublic class ThreadLocal<T> {\n    ...\n}\n```\n\n<!-- more -->\n\n## 简单示例\n\n经典的数据源连接\n\n```java\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class DataSourceManager {\n    private static ThreadLocal<Connection> connectionHolder = ThreadLocal.withInitial(() -> {\n        try {\n            // 创建数据库连接\n            return DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"username\", \"password\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n            return null;\n        }\n    });\n\n    // 获取当前线程的数据库连接\n    public static Connection getConnection() {\n        return connectionHolder.get();\n    }\n\n    // 关闭当前线程的数据库连接\n    public static void closeConnection() {\n        Connection connection = connectionHolder.get();\n        if (connection != null) {\n            try {\n                connection.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        connectionHolder.remove();\n    }\n\n    public static void main(String[] args) {\n        // 在多个线程中使用数据源连接服务\n        Thread thread1 = new Thread(() -> {\n            Connection connection = DataSourceManager.getConnection();\n            // 执行数据库操作\n            DataSourceManager.closeConnection();\n        });\n\n        Thread thread2 = new Thread(() -> {\n            Connection connection = DataSourceManager.getConnection();\n            // 执行数据库操作\n            DataSourceManager.closeConnection();\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n**综述**：\n\n- 不进行信息隔离？那一个线程在进行操作时，另一个线程关闭连接怎么办？\n- 不创建副本？每次操作数据源都加锁？\n- 手动创建副本？有现成的ThreadLocal不用，ThreadLocal还使用弱引用在线程结束时自动释放副本。\n\n## ThreadLocal初始化\n\n```java\n//使用构造函数（对你没有看错，我也没有省略，构造函数是空的）\npublic ThreadLocal() {\n}\n//使用withInitial()，new有初值的ThreadLocal对象(Supplier返回值作为初值)\npublic static <S> ThreadLocal<S> withInitial(Supplier<? extends S> supplier) {\n        return new SuppliedThreadLocal<>(supplier);\n}\n```\n\n## ThreadLocal方法\n\n```java\n//常用的set()设置值和get()获取值,以及使用结束后remove()清除副本\n//new 创建ThreadLocal get之前需要先set，不然会抛空指针异常\n    public T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n\tpublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            map.set(this, value);\n        } else {\n            createMap(t, value);\n        }\n\t}\n \tpublic void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null) {\n             m.remove(this);\n         }\n     }\n\n```\n\n## ThreadLocal原理初探\n\n每个Thread对象里面都有ThreadLocalMap对象（有两个，感兴趣自行查阅），Thread通过ThreadLocalMap来存储每个线程的ThreadLocal对象副本\n\n```java\npublic class Thread implements Runnable {\n    ...\n\t/* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n\n    /*\n     * InheritableThreadLocal values pertaining to this thread. This map is\n     * maintained by the InheritableThreadLocal class.\n     */\n    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;\n \t...   \n}\n```\n\n### ThreadLocalMap对象\n\n```java\n//ThreadLocalMap里面的对象及属性\nstatic class ThreadLocalMap {\n\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as \"stale entries\" in the code that follows.\n         */\n        static class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n\n        /**\n         * The initial capacity -- MUST be a power of two.\n         */\n        private static final int INITIAL_CAPACITY = 16;\n\n        /**\n         * The table, resized as necessary.\n         * table.length MUST always be a power of two.\n         */\n        private Entry[] table;\n\n        /**\n         * The number of entries in the table.\n         */\n        private int size = 0;\n\n        /**\n         * The next size value at which to resize.\n         */\n        private int threshold; // Default to 0\n     ...\n }\n```\n\n可以看到ThreadLocalMap里面有一个Entry类型的数组，Entry则是内部一个静态的键值对的类。（Map的常见实现方式，数组存储键值对）\n\n### Entry类\n\n键值对的**key**是**ThreadLocal对象实例**，**value**是**ThreadLocal泛型数据实例**。所以ThreadLocal要隔离的数据其实是在使用时存放在线程中的，ThreadLocal主要是充当模版的作用。（有点类和对象的感觉）\n\n可能有人注意到Entry类继承了`WeakReference<ThreadLocal<?>>`，这是什么东西？\n\n（具体省略，感兴趣自行查阅）\n\n四种引用中的弱引用。\n\n```java\n//强引用和弱引用的对比\nstatic class Entry {\n    //作为属性来引用ThreadLocal对象，强引用\n    ThreadLocal<?> k;\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        value = v;\n    }\n}\n//弱引用\n static class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n```\n\n#### ThreadLocal引用关系\n\n使用ThreadLocal时，Thread会持有ThreadLocalMap强引用，ThreadLocalMap会持有Entry强引用，Entry会持有ThreadLocal弱引用。\n\n在ThreadLocal不使用时（线程依旧持有ThreadLocalMap），Entry中ThreadLocal对象的**key**会被回收掉，不过由于**value**是强引用，所以会出现**key为null，value有值的无效Entry**。虽然ThreadLocal在`get()`时会检查null值的key然后删除（具体查阅`getEntry()`中`getAfterMisss()`方法），不过如果不显示的调用remove()清除ThreadLocalMap，value的生命会与Thread线程实例绑定。\n\n#### ThreadLocal内存泄漏\n\n原本就算value与Thread生命绑定，在Thread示例销毁时value也会销毁。\n\n但是线程池为了资源的复用，里面的核心线程会一直跑着循环来判断是否有新任务，这就会造成value永远无法回收（也就是内存泄漏的问题），泄漏内存为**线程池核心线程数 × value对象大小**\n\n###  ThreaLocalMap的散列方式\n\nThreadLocal中map使用的是斐波那契散列法，详细见//todo\n\n\n\n\n\n\n\n\n\n","source":"_posts/ThreadLocal小结.md","raw":"---\ntitle: ThreadLocal小结\ndate: 2024-04-30 14:26:21\ntags: \n  - juc\ncategories:\t\n  - 后端开发\n---\n\n\n\n# ThreadLocal\n\nThreadLocal主要是为了解决多线程间信息隔离的问题（创建副本，用空间换时间）。\n\n```java\n//泛型为需要共享的数据的类型\npublic class ThreadLocal<T> {\n    ...\n}\n```\n\n<!-- more -->\n\n## 简单示例\n\n经典的数据源连接\n\n```java\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class DataSourceManager {\n    private static ThreadLocal<Connection> connectionHolder = ThreadLocal.withInitial(() -> {\n        try {\n            // 创建数据库连接\n            return DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydatabase\", \"username\", \"password\");\n        } catch (SQLException e) {\n            e.printStackTrace();\n            return null;\n        }\n    });\n\n    // 获取当前线程的数据库连接\n    public static Connection getConnection() {\n        return connectionHolder.get();\n    }\n\n    // 关闭当前线程的数据库连接\n    public static void closeConnection() {\n        Connection connection = connectionHolder.get();\n        if (connection != null) {\n            try {\n                connection.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n        connectionHolder.remove();\n    }\n\n    public static void main(String[] args) {\n        // 在多个线程中使用数据源连接服务\n        Thread thread1 = new Thread(() -> {\n            Connection connection = DataSourceManager.getConnection();\n            // 执行数据库操作\n            DataSourceManager.closeConnection();\n        });\n\n        Thread thread2 = new Thread(() -> {\n            Connection connection = DataSourceManager.getConnection();\n            // 执行数据库操作\n            DataSourceManager.closeConnection();\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n**综述**：\n\n- 不进行信息隔离？那一个线程在进行操作时，另一个线程关闭连接怎么办？\n- 不创建副本？每次操作数据源都加锁？\n- 手动创建副本？有现成的ThreadLocal不用，ThreadLocal还使用弱引用在线程结束时自动释放副本。\n\n## ThreadLocal初始化\n\n```java\n//使用构造函数（对你没有看错，我也没有省略，构造函数是空的）\npublic ThreadLocal() {\n}\n//使用withInitial()，new有初值的ThreadLocal对象(Supplier返回值作为初值)\npublic static <S> ThreadLocal<S> withInitial(Supplier<? extends S> supplier) {\n        return new SuppliedThreadLocal<>(supplier);\n}\n```\n\n## ThreadLocal方法\n\n```java\n//常用的set()设置值和get()获取值,以及使用结束后remove()清除副本\n//new 创建ThreadLocal get之前需要先set，不然会抛空指针异常\n    public T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n\tpublic void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            map.set(this, value);\n        } else {\n            createMap(t, value);\n        }\n\t}\n \tpublic void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null) {\n             m.remove(this);\n         }\n     }\n\n```\n\n## ThreadLocal原理初探\n\n每个Thread对象里面都有ThreadLocalMap对象（有两个，感兴趣自行查阅），Thread通过ThreadLocalMap来存储每个线程的ThreadLocal对象副本\n\n```java\npublic class Thread implements Runnable {\n    ...\n\t/* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n\n    /*\n     * InheritableThreadLocal values pertaining to this thread. This map is\n     * maintained by the InheritableThreadLocal class.\n     */\n    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;\n \t...   \n}\n```\n\n### ThreadLocalMap对象\n\n```java\n//ThreadLocalMap里面的对象及属性\nstatic class ThreadLocalMap {\n\n        /**\n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as \"stale entries\" in the code that follows.\n         */\n        static class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n\n        /**\n         * The initial capacity -- MUST be a power of two.\n         */\n        private static final int INITIAL_CAPACITY = 16;\n\n        /**\n         * The table, resized as necessary.\n         * table.length MUST always be a power of two.\n         */\n        private Entry[] table;\n\n        /**\n         * The number of entries in the table.\n         */\n        private int size = 0;\n\n        /**\n         * The next size value at which to resize.\n         */\n        private int threshold; // Default to 0\n     ...\n }\n```\n\n可以看到ThreadLocalMap里面有一个Entry类型的数组，Entry则是内部一个静态的键值对的类。（Map的常见实现方式，数组存储键值对）\n\n### Entry类\n\n键值对的**key**是**ThreadLocal对象实例**，**value**是**ThreadLocal泛型数据实例**。所以ThreadLocal要隔离的数据其实是在使用时存放在线程中的，ThreadLocal主要是充当模版的作用。（有点类和对象的感觉）\n\n可能有人注意到Entry类继承了`WeakReference<ThreadLocal<?>>`，这是什么东西？\n\n（具体省略，感兴趣自行查阅）\n\n四种引用中的弱引用。\n\n```java\n//强引用和弱引用的对比\nstatic class Entry {\n    //作为属性来引用ThreadLocal对象，强引用\n    ThreadLocal<?> k;\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        value = v;\n    }\n}\n//弱引用\n static class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n```\n\n#### ThreadLocal引用关系\n\n使用ThreadLocal时，Thread会持有ThreadLocalMap强引用，ThreadLocalMap会持有Entry强引用，Entry会持有ThreadLocal弱引用。\n\n在ThreadLocal不使用时（线程依旧持有ThreadLocalMap），Entry中ThreadLocal对象的**key**会被回收掉，不过由于**value**是强引用，所以会出现**key为null，value有值的无效Entry**。虽然ThreadLocal在`get()`时会检查null值的key然后删除（具体查阅`getEntry()`中`getAfterMisss()`方法），不过如果不显示的调用remove()清除ThreadLocalMap，value的生命会与Thread线程实例绑定。\n\n#### ThreadLocal内存泄漏\n\n原本就算value与Thread生命绑定，在Thread示例销毁时value也会销毁。\n\n但是线程池为了资源的复用，里面的核心线程会一直跑着循环来判断是否有新任务，这就会造成value永远无法回收（也就是内存泄漏的问题），泄漏内存为**线程池核心线程数 × value对象大小**\n\n###  ThreaLocalMap的散列方式\n\nThreadLocal中map使用的是斐波那契散列法，详细见//todo\n\n\n\n\n\n\n\n\n\n","slug":"ThreadLocal小结","published":1,"updated":"2024-05-09T07:08:55.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6bl000dskus4xih45xn","content":"<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><p>ThreadLocal主要是为了解决多线程间信息隔离的问题（创建副本，用空间换时间）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//泛型为需要共享的数据的类型</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h2 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h2><p>经典的数据源连接</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.sql.Connection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.sql.DriverManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.sql.SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataSourceManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建数据库连接</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> DriverManager.getConnection(<span class=\"string\">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>, <span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;password&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程的数据库连接</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connectionHolder.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关闭当前线程的数据库连接</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">closeConnection</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> connectionHolder.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                connection.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        connectionHolder.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在多个线程中使用数据源连接服务</span></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DataSourceManager.getConnection();</span><br><span class=\"line\">            <span class=\"comment\">// 执行数据库操作</span></span><br><span class=\"line\">            DataSourceManager.closeConnection();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DataSourceManager.getConnection();</span><br><span class=\"line\">            <span class=\"comment\">// 执行数据库操作</span></span><br><span class=\"line\">            DataSourceManager.closeConnection();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>综述</strong>：</p>\n<ul>\n<li>不进行信息隔离？那一个线程在进行操作时，另一个线程关闭连接怎么办？</li>\n<li>不创建副本？每次操作数据源都加锁？</li>\n<li>手动创建副本？有现成的ThreadLocal不用，ThreadLocal还使用弱引用在线程结束时自动释放副本。</li>\n</ul>\n<h2 id=\"ThreadLocal初始化\"><a href=\"#ThreadLocal初始化\" class=\"headerlink\" title=\"ThreadLocal初始化\"></a>ThreadLocal初始化</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用构造函数（对你没有看错，我也没有省略，构造函数是空的）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ThreadLocal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用withInitial()，new有初值的ThreadLocal对象(Supplier返回值作为初值)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class=\"title function_\">withInitial</span><span class=\"params\">(Supplier&lt;? extends S&gt; supplier)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SuppliedThreadLocal</span>&lt;&gt;(supplier);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ThreadLocal方法\"><a href=\"#ThreadLocal方法\" class=\"headerlink\" title=\"ThreadLocal方法\"></a>ThreadLocal方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//常用的set()设置值和get()获取值,以及使用结束后remove()清除副本</span></span><br><span class=\"line\"><span class=\"comment\">//new 创建ThreadLocal get之前需要先set，不然会抛空指针异常</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">        <span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocalMap.<span class=\"type\">Entry</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> map.getEntry(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                <span class=\"type\">T</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> (T)e.value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">set</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">        <span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            map.set(<span class=\"built_in\">this</span>, value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            createMap(t, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> \t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">remove</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">         <span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> getMap(Thread.currentThread());</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (m != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             m.remove(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ThreadLocal原理初探\"><a href=\"#ThreadLocal原理初探\" class=\"headerlink\" title=\"ThreadLocal原理初探\"></a>ThreadLocal原理初探</h2><p>每个Thread对象里面都有ThreadLocalMap对象（有两个，感兴趣自行查阅），Thread通过ThreadLocalMap来存储每个线程的ThreadLocal对象副本</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Thread</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"comment\">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class=\"line\"><span class=\"comment\">     * by the ThreadLocal class. */</span></span><br><span class=\"line\">    ThreadLocal.<span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">threadLocals</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class=\"line\"><span class=\"comment\">     * maintained by the InheritableThreadLocal class.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    ThreadLocal.<span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">inheritableThreadLocals</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"> \t...   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ThreadLocalMap对象\"><a href=\"#ThreadLocalMap对象\" class=\"headerlink\" title=\"ThreadLocalMap对象\"></a>ThreadLocalMap对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ThreadLocalMap里面的对象及属性</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadLocalMap</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * The entries in this hash map extend WeakReference, using</span></span><br><span class=\"line\"><span class=\"comment\">         * its main ref field as the key (which is always a</span></span><br><span class=\"line\"><span class=\"comment\">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class=\"line\"><span class=\"comment\">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class=\"line\"><span class=\"comment\">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class=\"line\"><span class=\"comment\">         * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">            Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">super</span>(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * The initial capacity -- MUST be a power of two.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">INITIAL_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * The table, resized as necessary.</span></span><br><span class=\"line\"><span class=\"comment\">         * table.length MUST always be a power of two.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Entry[] table;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * The number of entries in the table.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * The next size value at which to resize.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> threshold; <span class=\"comment\">// Default to 0</span></span><br><span class=\"line\">     ...</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到ThreadLocalMap里面有一个Entry类型的数组，Entry则是内部一个静态的键值对的类。（Map的常见实现方式，数组存储键值对）</p>\n<h3 id=\"Entry类\"><a href=\"#Entry类\" class=\"headerlink\" title=\"Entry类\"></a>Entry类</h3><p>键值对的<strong>key</strong>是<strong>ThreadLocal对象实例</strong>，<strong>value</strong>是<strong>ThreadLocal泛型数据实例</strong>。所以ThreadLocal要隔离的数据其实是在使用时存放在线程中的，ThreadLocal主要是充当模版的作用。（有点类和对象的感觉）</p>\n<p>可能有人注意到Entry类继承了<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，这是什么东西？</p>\n<p>（具体省略，感兴趣自行查阅）</p>\n<p>四种引用中的弱引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//强引用和弱引用的对比</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//作为属性来引用ThreadLocal对象，强引用</span></span><br><span class=\"line\">    ThreadLocal&lt;?&gt; k;</span><br><span class=\"line\">    Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//弱引用</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">            Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">super</span>(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ThreadLocal引用关系\"><a href=\"#ThreadLocal引用关系\" class=\"headerlink\" title=\"ThreadLocal引用关系\"></a>ThreadLocal引用关系</h4><p>使用ThreadLocal时，Thread会持有ThreadLocalMap强引用，ThreadLocalMap会持有Entry强引用，Entry会持有ThreadLocal弱引用。</p>\n<p>在ThreadLocal不使用时（线程依旧持有ThreadLocalMap），Entry中ThreadLocal对象的<strong>key</strong>会被回收掉，不过由于<strong>value</strong>是强引用，所以会出现<strong>key为null，value有值的无效Entry</strong>。虽然ThreadLocal在<code>get()</code>时会检查null值的key然后删除（具体查阅<code>getEntry()</code>中<code>getAfterMisss()</code>方法），不过如果不显示的调用remove()清除ThreadLocalMap，value的生命会与Thread线程实例绑定。</p>\n<h4 id=\"ThreadLocal内存泄漏\"><a href=\"#ThreadLocal内存泄漏\" class=\"headerlink\" title=\"ThreadLocal内存泄漏\"></a>ThreadLocal内存泄漏</h4><p>原本就算value与Thread生命绑定，在Thread示例销毁时value也会销毁。</p>\n<p>但是线程池为了资源的复用，里面的核心线程会一直跑着循环来判断是否有新任务，这就会造成value永远无法回收（也就是内存泄漏的问题），泄漏内存为<strong>线程池核心线程数 × value对象大小</strong></p>\n<h3 id=\"ThreaLocalMap的散列方式\"><a href=\"#ThreaLocalMap的散列方式\" class=\"headerlink\" title=\"ThreaLocalMap的散列方式\"></a>ThreaLocalMap的散列方式</h3><p>ThreadLocal中map使用的是斐波那契散列法，详细见&#x2F;&#x2F;todo</p>\n","site":{"data":{}},"length":1171,"excerpt":"<h1 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h1><p>ThreadLocal主要是为了解决多线程间信息隔离的问题（创建副本，用空间换时间）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//泛型为需要共享的数据的类型</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h2><p>经典的数据源连接</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.sql.Connection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.sql.DriverManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.sql.SQLException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataSourceManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建数据库连接</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> DriverManager.getConnection(<span class=\"string\">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>, <span class=\"string\">&quot;username&quot;</span>, <span class=\"string\">&quot;password&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程的数据库连接</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> connectionHolder.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关闭当前线程的数据库连接</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">closeConnection</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> connectionHolder.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                connection.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        connectionHolder.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在多个线程中使用数据源连接服务</span></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DataSourceManager.getConnection();</span><br><span class=\"line\">            <span class=\"comment\">// 执行数据库操作</span></span><br><span class=\"line\">            DataSourceManager.closeConnection();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DataSourceManager.getConnection();</span><br><span class=\"line\">            <span class=\"comment\">// 执行数据库操作</span></span><br><span class=\"line\">            DataSourceManager.closeConnection();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>综述</strong>：</p>\n<ul>\n<li>不进行信息隔离？那一个线程在进行操作时，另一个线程关闭连接怎么办？</li>\n<li>不创建副本？每次操作数据源都加锁？</li>\n<li>手动创建副本？有现成的ThreadLocal不用，ThreadLocal还使用弱引用在线程结束时自动释放副本。</li>\n</ul>\n<h2 id=\"ThreadLocal初始化\"><a href=\"#ThreadLocal初始化\" class=\"headerlink\" title=\"ThreadLocal初始化\"></a>ThreadLocal初始化</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用构造函数（对你没有看错，我也没有省略，构造函数是空的）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ThreadLocal</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用withInitial()，new有初值的ThreadLocal对象(Supplier返回值作为初值)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class=\"title function_\">withInitial</span><span class=\"params\">(Supplier&lt;? extends S&gt; supplier)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SuppliedThreadLocal</span>&lt;&gt;(supplier);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ThreadLocal方法\"><a href=\"#ThreadLocal方法\" class=\"headerlink\" title=\"ThreadLocal方法\"></a>ThreadLocal方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//常用的set()设置值和get()获取值,以及使用结束后remove()清除副本</span></span><br><span class=\"line\"><span class=\"comment\">//new 创建ThreadLocal get之前需要先set，不然会抛空指针异常</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">        <span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocalMap.<span class=\"type\">Entry</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> map.getEntry(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                <span class=\"type\">T</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> (T)e.value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">set</span><span class=\"params\">(T value)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">        <span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">map</span> <span class=\"operator\">=</span> getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            map.set(<span class=\"built_in\">this</span>, value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            createMap(t, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> \t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">remove</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">         <span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> getMap(Thread.currentThread());</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (m != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">             m.remove(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ThreadLocal原理初探\"><a href=\"#ThreadLocal原理初探\" class=\"headerlink\" title=\"ThreadLocal原理初探\"></a>ThreadLocal原理初探</h2><p>每个Thread对象里面都有ThreadLocalMap对象（有两个，感兴趣自行查阅），Thread通过ThreadLocalMap来存储每个线程的ThreadLocal对象副本</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Thread</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"comment\">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class=\"line\"><span class=\"comment\">     * by the ThreadLocal class. */</span></span><br><span class=\"line\">    ThreadLocal.<span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">threadLocals</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class=\"line\"><span class=\"comment\">     * maintained by the InheritableThreadLocal class.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    ThreadLocal.<span class=\"type\">ThreadLocalMap</span> <span class=\"variable\">inheritableThreadLocals</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"> \t...   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ThreadLocalMap对象\"><a href=\"#ThreadLocalMap对象\" class=\"headerlink\" title=\"ThreadLocalMap对象\"></a>ThreadLocalMap对象</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ThreadLocalMap里面的对象及属性</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThreadLocalMap</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * The entries in this hash map extend WeakReference, using</span></span><br><span class=\"line\"><span class=\"comment\">         * its main ref field as the key (which is always a</span></span><br><span class=\"line\"><span class=\"comment\">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class=\"line\"><span class=\"comment\">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class=\"line\"><span class=\"comment\">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class=\"line\"><span class=\"comment\">         * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">            Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">super</span>(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * The initial capacity -- MUST be a power of two.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">INITIAL_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * The table, resized as necessary.</span></span><br><span class=\"line\"><span class=\"comment\">         * table.length MUST always be a power of two.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Entry[] table;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * The number of entries in the table.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * The next size value at which to resize.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> threshold; <span class=\"comment\">// Default to 0</span></span><br><span class=\"line\">     ...</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到ThreadLocalMap里面有一个Entry类型的数组，Entry则是内部一个静态的键值对的类。（Map的常见实现方式，数组存储键值对）</p>\n<h3 id=\"Entry类\"><a href=\"#Entry类\" class=\"headerlink\" title=\"Entry类\"></a>Entry类</h3><p>键值对的<strong>key</strong>是<strong>ThreadLocal对象实例</strong>，<strong>value</strong>是<strong>ThreadLocal泛型数据实例</strong>。所以ThreadLocal要隔离的数据其实是在使用时存放在线程中的，ThreadLocal主要是充当模版的作用。（有点类和对象的感觉）</p>\n<p>可能有人注意到Entry类继承了<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，这是什么东西？</p>\n<p>（具体省略，感兴趣自行查阅）</p>\n<p>四种引用中的弱引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//强引用和弱引用的对比</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//作为属性来引用ThreadLocal对象，强引用</span></span><br><span class=\"line\">    ThreadLocal&lt;?&gt; k;</span><br><span class=\"line\">    Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//弱引用</span></span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">            Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">super</span>(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ThreadLocal引用关系\"><a href=\"#ThreadLocal引用关系\" class=\"headerlink\" title=\"ThreadLocal引用关系\"></a>ThreadLocal引用关系</h4><p>使用ThreadLocal时，Thread会持有ThreadLocalMap强引用，ThreadLocalMap会持有Entry强引用，Entry会持有ThreadLocal弱引用。</p>\n<p>在ThreadLocal不使用时（线程依旧持有ThreadLocalMap），Entry中ThreadLocal对象的<strong>key</strong>会被回收掉，不过由于<strong>value</strong>是强引用，所以会出现<strong>key为null，value有值的无效Entry</strong>。虽然ThreadLocal在<code>get()</code>时会检查null值的key然后删除（具体查阅<code>getEntry()</code>中<code>getAfterMisss()</code>方法），不过如果不显示的调用remove()清除ThreadLocalMap，value的生命会与Thread线程实例绑定。</p>\n<h4 id=\"ThreadLocal内存泄漏\"><a href=\"#ThreadLocal内存泄漏\" class=\"headerlink\" title=\"ThreadLocal内存泄漏\"></a>ThreadLocal内存泄漏</h4><p>原本就算value与Thread生命绑定，在Thread示例销毁时value也会销毁。</p>\n<p>但是线程池为了资源的复用，里面的核心线程会一直跑着循环来判断是否有新任务，这就会造成value永远无法回收（也就是内存泄漏的问题），泄漏内存为<strong>线程池核心线程数 × value对象大小</strong></p>\n<h3 id=\"ThreaLocalMap的散列方式\"><a href=\"#ThreaLocalMap的散列方式\" class=\"headerlink\" title=\"ThreaLocalMap的散列方式\"></a>ThreaLocalMap的散列方式</h3><p>ThreadLocal中map使用的是斐波那契散列法，详细见&#x2F;&#x2F;todo</p>"},{"title":"id生成","date":"2024-09-02T07:00:55.000Z","_content":"\n分布式场景下全局唯一id的生成方案，雪花算法、数据库自增、redis自增。\n\n<!--more-->\n\n# 1. 雪花算法\n\n## 1.1 结构\n\n![8542a7cdeca53f63c9ad4f4dfd05f61b](./id生成/雪花算法.webp)\n\n- 41bit时间戳：这里采用的就是当前系统的具体时间，单位为毫秒\n- 10bit工作机器ID（workerId）：每台机器分配一个id，这样可以标示不同的机器，但是上限为1024，标示一个集群某个业务最多部署的机器个数上限\n- 12bit序列号（自增域）：表示在某一毫秒下，这个自增域最大可以分配的bit个数，在当前这种配置下，每一毫秒可以分配2^12个数据，也就是说QPS可以到 409.6 w/s。\n\n## 1.2 代码实现\n\n可以用hutool中的工具类`IdUtil`来创建雪花算法生成的id\n\n1. 导入`hutool`\n\n   ```java\n   <dependency>\n      <groupId>cn.hutool</groupId>\n      <artifactId>hutool-all</artifactId>\n      <version>5.7.2</version>\n   </dependency>\n   ```\n\n2. 使用`IdUtil`\n\n   ```java\n   IdUtil.createSnowflake(0L,1L);\n   //传入参数是workerId和datacenterId\n    public static Snowflake createSnowflake(long workerId, long datacenterId) {\n           return new Snowflake(workerId, datacenterId);\n       }\n   ```\n\n**代码剖析：**\n\n1. **初始化**\n\n   ```java\n   //上方函数调用的构造参数，进行初始化\n   public Snowflake(long workerId, long dataCenterId) {\n           this(workerId, dataCenterId, false);\n       }\n   \n       public Snowflake(long workerId, long dataCenterId, boolean isUseSystemClock) {\n           this((Date)null, workerId, dataCenterId, isUseSystemClock);\n       }\n   \n       public Snowflake(Date epochDate, long workerId, long dataCenterId, boolean isUseSystemClock) {\n           this.workerIdBits = 5L;\n           //最大workerId，5位也就是2^5-1\n           this.maxWorkerId = 31L;\n           \n           this.dataCenterIdBits = 5L;\n           //最大dataCenterId，5位也就是2^5-1\n           this.maxDataCenterId = 31L;\n           \n           this.sequenceBits = 12L;\n           this.workerIdShift = 12L;\n           this.dataCenterIdShift = 17L;\n           this.timestampLeftShift = 22L;\n           //最大序列号，2^12 - 1\n           this.sequenceMask = 4095L;\n           this.sequence = 0L;\n           this.lastTimestamp = -1L;\n           \n           //使用工具类传的是null\n           if (null != epochDate) {\n               this.twepoch = epochDate.getTime();\n           } else {\n               this.twepoch = 1288834974657L;\n           }\n   \n           if (workerId <= 31L && workerId >= 0L) {\n               if (dataCenterId <= 31L && dataCenterId >= 0L) {\n                   this.workerId = workerId;\n                   this.dataCenterId = dataCenterId;\n                   this.useSystemClock = isUseSystemClock;\n               } else {\n                   throw new IllegalArgumentException(StrUtil.format(\"datacenter Id can't be greater than {} or less than 0\", new Object[]{31L}));\n               }\n           } else {\n               throw new IllegalArgumentException(StrUtil.format(\"worker Id can't be greater than {} or less than 0\", new Object[]{31L}));\n           }\n       }\n   \n   ```\n\n2. **具体创建逻辑**\n\n   ```java\n   public synchronized long nextId() {\n       //生成的时间戳13位，默认的twepoch也是13位\n           long timestamp = this.genTime();\n       //时间片回拨问题，时间差较小进行同步,时间差较大直接抛异常\n           if (timestamp < this.lastTimestamp) {\n               if (this.lastTimestamp - timestamp >= 2000L) {\n                   throw new IllegalStateException(StrUtil.format(\"Clock moved backwards. Refusing to generate id for {}ms\", new Object[]{this.lastTimestamp - timestamp}));\n               }\n               timestamp = this.lastTimestamp;\n           }\n       //序号自增,增到最大再次将时间戳更新(防止id重复)\n           if (timestamp == this.lastTimestamp) {\n               long sequence = this.sequence + 1L & 4095L;\n               if (sequence == 0L) {\n                   timestamp = this.tilNextMillis(this.lastTimestamp);\n               }\n   \n               this.sequence = sequence;\n           } else {\n               this.sequence = 0L;\n           }\n   \n           this.lastTimestamp = timestamp;\n       //创建Id，(时间戳 - 1288834974657L) + 五位的dtaCenterId + 五位的workerId + 12位序列号\n       //很符合雪花算法的结构 时间戳 + 10位机器Id + 12位序列号\n           return timestamp - this.twepoch << 22 | this.dataCenterId << 17 | this.workerId << 12 | this.sequence;\n       }\n   ```\n\n## 1.3 问题\n\n雪花算法可能出现以下问题\n\n- **时间片回拨**：由于机器的时间是动态的调整的，有可能会出现时间跑到之前几毫秒，如果这个时候获取到了这种时间，则会出现**id重复**\n- **机器id分配以及回收**：机器id需要每台机器不一样，这样的方式分配需要有方案进行处理，同时也要考虑，如果该机器宕机了，对应的workerId分配后的回收问题\n- **机器id上线**：机器id是固定的bit，那么也就是对应的机器个数是有上限的，在有些业务场景下，需要所有机器共享同一个业务空间，那么10bit表示的1024台机器是不够的。\n\n**解决方案**\n\n问题的处理没有完美的方案，只要选一个适合自身业务场景的就行\n\n1. **时间回拨问题**\n\n   - 出现回拨直接抛异常\n   - 采用等待跟上次时间的一段范围：这种算是简单解决，可以接受，但是如果等待一段时间后再出现回拨，则抛异常。（hutool工具包中就采用的这种方案）\n\n2. **机器id上限**\n\n   这个问题受限于雪花算法的结构，除非改一下雪花算法增加机器Id位数，不然没法解决\n\n### 机器id分配问题\n\n**机器id分配问题**比起雪花算法，它和业务的关联性更大，这里单独拿出来说一下。\n\n在上面代码中，我们使用hutool工具包随便传入了两个值作为workerId和datacenterId，但真实生产环境中这两个值是需要有一套分配策略来产生的（多个不同的Java程序使用相同的机器id可能会导致id重复生成）。\n\n**需求**：\n\n1. 机器id需要能够不重复的分配给所有JVM实例\n2. 机器id数量有限，需要对不使用的机器id进行回收复用\n\n#### 1.3.1 直接使用ip地址\n\n服务器的IP地址一般都是公司的内网IP，子网划分时同一子网IP的前几位基本是相同的，根据这一特性我们可以在IP地址中取10位作为机器id。\n\n```java\npublic class IDGenerator {\n    private long workerId;\n    private long datacenterId;\n    private Snowflake snowflake;\n\n    private IDGenerator(long workerId, long datacenterId) {\n        this.workerId = workerId;\n        this.datacenterId = datacenterId;\n        this.snowflake = IdUtil.createSnowflake(this.workerId, this.datacenterId);\n    }\n    /**\n     * @description 默认使用ip地址最后10位作为机器id\n     */\n    public IDGenerator() {\n        //取ip地址最后10位作为机器id\n        long machineId = NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()) & 1023;\n        //machineId低5位作为workerId\n        this.workerId = machineId & 31;\n        //machineId高5位作为datacenterId\n        this.datacenterId = machineId >> 5;\n        this.snowflake = IdUtil.createSnowflake(this.workerId, this.datacenterId);\n    }\n    \n    public static IDGenerator createWithWorkerId(long workerId) {\n        //取ip地址最后10位高五位作为默认datacenterId\n        long datacenterId = (NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()) >> 5) & 31;\n        return new IDGenerator(workerId, datacenterId);\n    }\n\n    public static IDGenerator createWithDatacenterId(long datacenterId) {\n        //取ip地址最后五位作为默认workerId\n        long workerId = NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()) & 31;\n        return new IDGenerator(workerId, datacenterId);\n    }\n\n    public static IDGenerator createWithWorkerIdAndDatacenterId(long workerId, long datacenterId) {\n        return new IDGenerator(workerId, datacenterId);\n    }\n\n    public static IDGenerator createWithMachineId(long machineId) {\n        return new IDGenerator(machineId & 31, machineId >> 5);\n    }\n    \n    public long nextId() {\n        return snowflake.nextId();\n    }\n}\n```\n\n一台机器多个JVM或者ip地址最后十位相同时会导致机器id重复\n\n#### 1.3.2 redis维护机器id\n\n参考[失败的面的文章](https://juejin.cn/post/7280747572695679036)\n\nredis不保证可用性，可能会导致机器id重复\n\n#### 1.3.3 zookeeper维护机器id\n\n通过创建分区来监控服务器的状态\n\n# 2. 数据库自增\n\n在数据库中创建一张表来维护全局唯一的自增id\n\n1. **建表**\n\n   数据库表中id可能供多个服务使用，加上`type`区分使用场景（ 用户表需要自增id，其它表可能也需要），代码实现中可以定义枚举类来记录type\n\n   ```sql\n   CREATE TABLE `serial_number` (\n     `number` bigint DEFAULT '0',\n     `type` varchar(255) NOT NULL COMMENT '自增id类型',\n     `create_time` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),\n     `update_time` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3),\n     PRIMARY KEY (`type`)\n   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 commit '全局自增id表'\n   ```\n\n2. **编写代码**\n\n   数据库操作\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <!DOCTYPE mapper\n           PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n           \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n   <mapper namespace=\"org.example.learn.mapper.SerialNumberMapper\">\n   \n       <resultMap id=\"BaseResultMap\" type=\"org.example.learn.entity.SerialNumber\">\n               <id property=\"type\" column=\"type\" jdbcType=\"VARCHAR\"/>\n               <result property=\"number\" column=\"number\" jdbcType=\"BIGINT\"/>\n               <result property=\"createTime\" column=\"create_time\" jdbcType=\"TIMESTAMP\"/>\n               <result property=\"updateTime\" column=\"update_time\" jdbcType=\"TIMESTAMP\"/>\n       </resultMap>\n       <select id=\"getId\" resultType=\"java.lang.Long\">\n           select number\n           from serial_number\n           where type = #{type} FOR UPDATE;\n       </select>\n       <insert id=\"insert\" >\n           insert into serial_number\n           ( type,number)\n           values (#{type},#{number});\n       </insert>\n       <update id=\"increment\" >\n           update serial_number\n           set number = number + 1\n           where type = #{type};\n       </update>\n   </mapper>\n   ```\n\n   ```java\n   package org.example.learn.mapper;\n   \n   import org.apache.ibatis.annotations.Param;\n   \n   public interface SerialNumberMapper {\n   \n       int insert(@Param(\"number\")Long number,@Param(\"type\")String type);\n   \n       Long getId(@Param(\"id\") Long id);\n   \n       int increment(@Param(\"type\")String type);\n   \n   }\n   ```\n\n   **id生成服务**\n\n   ```java\n   //id生成的具体逻辑\n   @Service\n   //加事务保证外层事务回滚时，id生成也跟着回滚\n   @Transactional(propagation = Propagation.REQUIRED)\n   public class SerialNumberServiceImpl implements SerialNumberService {\n       @Resource\n       private SerialNumberMapper serialNumberMapper;\n       public Long getId(){\n           Long num = serialNumberMapper.getId(\"test\");\n           if(num == null||num == 0){\n               serialNumberMapper.insert(1L,\"test\");\n               return 1L;\n           }else{\n               if(serialNumberMapper.increment(\"test\")==1){\n                   return num+1;\n               }else{\n                   throw new RuntimeException(\"data error\");\n               }\n           }\n       }\n   }\n   ```\n\n   \n\n# 3. redis生成ID\n\n可以用redis定义一个Hash类型或者多个key来表示要用的Id，每次使用的时候incr自增就行了。\n\nRedisson 中有AtmoicLong类型数据可以用作自增id，引用自 [修己xj](https://juejin.cn/post/7325642452819673100)\n\n```java\n@Service\n@Slf4j\npublic class SerialIdService {\n\n    private static final String ID_KEY = \"xiuji:\";\n    private static final int BASE_36 = 36;\n\n    private static final Integer SEQUENCE_LENGTH = 5;\n    @Resource\n    private RedissonClient redissonClient;\n\n    public String workSerialId() {\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyMM\");\n        String dateStr = LocalDate.now().format(formatter);\n        //使用了Redisson的AtomicLong对象生成唯一序列号\n        RAtomicLong atomicLong = redissonClient.getAtomicLong(ID_KEY+dateStr);\n        //设置过期时间为35天\n        if(atomicLong.get() == 0){\n            atomicLong.expire(Duration.ofDays(35));\n        }\n        //将唯一序列号转换为36进制的字符串，长度为4位，用于减少ID的长度\n        String sequenceStr = Long.toString(atomicLong.incrementAndGet(), BASE_36).toUpperCase();\n        //36进制的序列号若小于4位，则用0补齐高位\n        if (sequenceStr.length() < SEQUENCE_LENGTH) {\n            sequenceStr = String.format(\"%4s\", sequenceStr).replace(' ', '0');;\n        }\n        String serialId = dateStr+sequenceStr;\n\n        log.info(\"生成的工单号：{}\",dateStr+sequenceStr);\n        return dateStr+sequenceStr;\n    }\n\n}\n```\n\n**问题**：不过redis作为内存数据库，不保证可用性，它的数据不是一定能保证正确存储的。所以id可能会出现重复，这时需要进行一定的处理，比如抛异常，更新redis值等。\n\n# 4. 其他\n\nID的生成不拘泥于形式只要能满足业务的需求就行，除了这些常见的id生成策略还可以\n\n- UUID生成随机字符串\n\n- 自行拼接**日期**、**随机数**、**业务中值**等内容形成ID\n\n...\n\n","source":"_posts/id生成.md","raw":"---\ntitle: id生成\ndate: 2024-09-02 15:00:55\ntags: \n  - 分布式 \ncategories:\n   - 后端开发\n---\n\n分布式场景下全局唯一id的生成方案，雪花算法、数据库自增、redis自增。\n\n<!--more-->\n\n# 1. 雪花算法\n\n## 1.1 结构\n\n![8542a7cdeca53f63c9ad4f4dfd05f61b](./id生成/雪花算法.webp)\n\n- 41bit时间戳：这里采用的就是当前系统的具体时间，单位为毫秒\n- 10bit工作机器ID（workerId）：每台机器分配一个id，这样可以标示不同的机器，但是上限为1024，标示一个集群某个业务最多部署的机器个数上限\n- 12bit序列号（自增域）：表示在某一毫秒下，这个自增域最大可以分配的bit个数，在当前这种配置下，每一毫秒可以分配2^12个数据，也就是说QPS可以到 409.6 w/s。\n\n## 1.2 代码实现\n\n可以用hutool中的工具类`IdUtil`来创建雪花算法生成的id\n\n1. 导入`hutool`\n\n   ```java\n   <dependency>\n      <groupId>cn.hutool</groupId>\n      <artifactId>hutool-all</artifactId>\n      <version>5.7.2</version>\n   </dependency>\n   ```\n\n2. 使用`IdUtil`\n\n   ```java\n   IdUtil.createSnowflake(0L,1L);\n   //传入参数是workerId和datacenterId\n    public static Snowflake createSnowflake(long workerId, long datacenterId) {\n           return new Snowflake(workerId, datacenterId);\n       }\n   ```\n\n**代码剖析：**\n\n1. **初始化**\n\n   ```java\n   //上方函数调用的构造参数，进行初始化\n   public Snowflake(long workerId, long dataCenterId) {\n           this(workerId, dataCenterId, false);\n       }\n   \n       public Snowflake(long workerId, long dataCenterId, boolean isUseSystemClock) {\n           this((Date)null, workerId, dataCenterId, isUseSystemClock);\n       }\n   \n       public Snowflake(Date epochDate, long workerId, long dataCenterId, boolean isUseSystemClock) {\n           this.workerIdBits = 5L;\n           //最大workerId，5位也就是2^5-1\n           this.maxWorkerId = 31L;\n           \n           this.dataCenterIdBits = 5L;\n           //最大dataCenterId，5位也就是2^5-1\n           this.maxDataCenterId = 31L;\n           \n           this.sequenceBits = 12L;\n           this.workerIdShift = 12L;\n           this.dataCenterIdShift = 17L;\n           this.timestampLeftShift = 22L;\n           //最大序列号，2^12 - 1\n           this.sequenceMask = 4095L;\n           this.sequence = 0L;\n           this.lastTimestamp = -1L;\n           \n           //使用工具类传的是null\n           if (null != epochDate) {\n               this.twepoch = epochDate.getTime();\n           } else {\n               this.twepoch = 1288834974657L;\n           }\n   \n           if (workerId <= 31L && workerId >= 0L) {\n               if (dataCenterId <= 31L && dataCenterId >= 0L) {\n                   this.workerId = workerId;\n                   this.dataCenterId = dataCenterId;\n                   this.useSystemClock = isUseSystemClock;\n               } else {\n                   throw new IllegalArgumentException(StrUtil.format(\"datacenter Id can't be greater than {} or less than 0\", new Object[]{31L}));\n               }\n           } else {\n               throw new IllegalArgumentException(StrUtil.format(\"worker Id can't be greater than {} or less than 0\", new Object[]{31L}));\n           }\n       }\n   \n   ```\n\n2. **具体创建逻辑**\n\n   ```java\n   public synchronized long nextId() {\n       //生成的时间戳13位，默认的twepoch也是13位\n           long timestamp = this.genTime();\n       //时间片回拨问题，时间差较小进行同步,时间差较大直接抛异常\n           if (timestamp < this.lastTimestamp) {\n               if (this.lastTimestamp - timestamp >= 2000L) {\n                   throw new IllegalStateException(StrUtil.format(\"Clock moved backwards. Refusing to generate id for {}ms\", new Object[]{this.lastTimestamp - timestamp}));\n               }\n               timestamp = this.lastTimestamp;\n           }\n       //序号自增,增到最大再次将时间戳更新(防止id重复)\n           if (timestamp == this.lastTimestamp) {\n               long sequence = this.sequence + 1L & 4095L;\n               if (sequence == 0L) {\n                   timestamp = this.tilNextMillis(this.lastTimestamp);\n               }\n   \n               this.sequence = sequence;\n           } else {\n               this.sequence = 0L;\n           }\n   \n           this.lastTimestamp = timestamp;\n       //创建Id，(时间戳 - 1288834974657L) + 五位的dtaCenterId + 五位的workerId + 12位序列号\n       //很符合雪花算法的结构 时间戳 + 10位机器Id + 12位序列号\n           return timestamp - this.twepoch << 22 | this.dataCenterId << 17 | this.workerId << 12 | this.sequence;\n       }\n   ```\n\n## 1.3 问题\n\n雪花算法可能出现以下问题\n\n- **时间片回拨**：由于机器的时间是动态的调整的，有可能会出现时间跑到之前几毫秒，如果这个时候获取到了这种时间，则会出现**id重复**\n- **机器id分配以及回收**：机器id需要每台机器不一样，这样的方式分配需要有方案进行处理，同时也要考虑，如果该机器宕机了，对应的workerId分配后的回收问题\n- **机器id上线**：机器id是固定的bit，那么也就是对应的机器个数是有上限的，在有些业务场景下，需要所有机器共享同一个业务空间，那么10bit表示的1024台机器是不够的。\n\n**解决方案**\n\n问题的处理没有完美的方案，只要选一个适合自身业务场景的就行\n\n1. **时间回拨问题**\n\n   - 出现回拨直接抛异常\n   - 采用等待跟上次时间的一段范围：这种算是简单解决，可以接受，但是如果等待一段时间后再出现回拨，则抛异常。（hutool工具包中就采用的这种方案）\n\n2. **机器id上限**\n\n   这个问题受限于雪花算法的结构，除非改一下雪花算法增加机器Id位数，不然没法解决\n\n### 机器id分配问题\n\n**机器id分配问题**比起雪花算法，它和业务的关联性更大，这里单独拿出来说一下。\n\n在上面代码中，我们使用hutool工具包随便传入了两个值作为workerId和datacenterId，但真实生产环境中这两个值是需要有一套分配策略来产生的（多个不同的Java程序使用相同的机器id可能会导致id重复生成）。\n\n**需求**：\n\n1. 机器id需要能够不重复的分配给所有JVM实例\n2. 机器id数量有限，需要对不使用的机器id进行回收复用\n\n#### 1.3.1 直接使用ip地址\n\n服务器的IP地址一般都是公司的内网IP，子网划分时同一子网IP的前几位基本是相同的，根据这一特性我们可以在IP地址中取10位作为机器id。\n\n```java\npublic class IDGenerator {\n    private long workerId;\n    private long datacenterId;\n    private Snowflake snowflake;\n\n    private IDGenerator(long workerId, long datacenterId) {\n        this.workerId = workerId;\n        this.datacenterId = datacenterId;\n        this.snowflake = IdUtil.createSnowflake(this.workerId, this.datacenterId);\n    }\n    /**\n     * @description 默认使用ip地址最后10位作为机器id\n     */\n    public IDGenerator() {\n        //取ip地址最后10位作为机器id\n        long machineId = NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()) & 1023;\n        //machineId低5位作为workerId\n        this.workerId = machineId & 31;\n        //machineId高5位作为datacenterId\n        this.datacenterId = machineId >> 5;\n        this.snowflake = IdUtil.createSnowflake(this.workerId, this.datacenterId);\n    }\n    \n    public static IDGenerator createWithWorkerId(long workerId) {\n        //取ip地址最后10位高五位作为默认datacenterId\n        long datacenterId = (NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()) >> 5) & 31;\n        return new IDGenerator(workerId, datacenterId);\n    }\n\n    public static IDGenerator createWithDatacenterId(long datacenterId) {\n        //取ip地址最后五位作为默认workerId\n        long workerId = NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()) & 31;\n        return new IDGenerator(workerId, datacenterId);\n    }\n\n    public static IDGenerator createWithWorkerIdAndDatacenterId(long workerId, long datacenterId) {\n        return new IDGenerator(workerId, datacenterId);\n    }\n\n    public static IDGenerator createWithMachineId(long machineId) {\n        return new IDGenerator(machineId & 31, machineId >> 5);\n    }\n    \n    public long nextId() {\n        return snowflake.nextId();\n    }\n}\n```\n\n一台机器多个JVM或者ip地址最后十位相同时会导致机器id重复\n\n#### 1.3.2 redis维护机器id\n\n参考[失败的面的文章](https://juejin.cn/post/7280747572695679036)\n\nredis不保证可用性，可能会导致机器id重复\n\n#### 1.3.3 zookeeper维护机器id\n\n通过创建分区来监控服务器的状态\n\n# 2. 数据库自增\n\n在数据库中创建一张表来维护全局唯一的自增id\n\n1. **建表**\n\n   数据库表中id可能供多个服务使用，加上`type`区分使用场景（ 用户表需要自增id，其它表可能也需要），代码实现中可以定义枚举类来记录type\n\n   ```sql\n   CREATE TABLE `serial_number` (\n     `number` bigint DEFAULT '0',\n     `type` varchar(255) NOT NULL COMMENT '自增id类型',\n     `create_time` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),\n     `update_time` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3),\n     PRIMARY KEY (`type`)\n   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 commit '全局自增id表'\n   ```\n\n2. **编写代码**\n\n   数据库操作\n\n   ```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <!DOCTYPE mapper\n           PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n           \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n   <mapper namespace=\"org.example.learn.mapper.SerialNumberMapper\">\n   \n       <resultMap id=\"BaseResultMap\" type=\"org.example.learn.entity.SerialNumber\">\n               <id property=\"type\" column=\"type\" jdbcType=\"VARCHAR\"/>\n               <result property=\"number\" column=\"number\" jdbcType=\"BIGINT\"/>\n               <result property=\"createTime\" column=\"create_time\" jdbcType=\"TIMESTAMP\"/>\n               <result property=\"updateTime\" column=\"update_time\" jdbcType=\"TIMESTAMP\"/>\n       </resultMap>\n       <select id=\"getId\" resultType=\"java.lang.Long\">\n           select number\n           from serial_number\n           where type = #{type} FOR UPDATE;\n       </select>\n       <insert id=\"insert\" >\n           insert into serial_number\n           ( type,number)\n           values (#{type},#{number});\n       </insert>\n       <update id=\"increment\" >\n           update serial_number\n           set number = number + 1\n           where type = #{type};\n       </update>\n   </mapper>\n   ```\n\n   ```java\n   package org.example.learn.mapper;\n   \n   import org.apache.ibatis.annotations.Param;\n   \n   public interface SerialNumberMapper {\n   \n       int insert(@Param(\"number\")Long number,@Param(\"type\")String type);\n   \n       Long getId(@Param(\"id\") Long id);\n   \n       int increment(@Param(\"type\")String type);\n   \n   }\n   ```\n\n   **id生成服务**\n\n   ```java\n   //id生成的具体逻辑\n   @Service\n   //加事务保证外层事务回滚时，id生成也跟着回滚\n   @Transactional(propagation = Propagation.REQUIRED)\n   public class SerialNumberServiceImpl implements SerialNumberService {\n       @Resource\n       private SerialNumberMapper serialNumberMapper;\n       public Long getId(){\n           Long num = serialNumberMapper.getId(\"test\");\n           if(num == null||num == 0){\n               serialNumberMapper.insert(1L,\"test\");\n               return 1L;\n           }else{\n               if(serialNumberMapper.increment(\"test\")==1){\n                   return num+1;\n               }else{\n                   throw new RuntimeException(\"data error\");\n               }\n           }\n       }\n   }\n   ```\n\n   \n\n# 3. redis生成ID\n\n可以用redis定义一个Hash类型或者多个key来表示要用的Id，每次使用的时候incr自增就行了。\n\nRedisson 中有AtmoicLong类型数据可以用作自增id，引用自 [修己xj](https://juejin.cn/post/7325642452819673100)\n\n```java\n@Service\n@Slf4j\npublic class SerialIdService {\n\n    private static final String ID_KEY = \"xiuji:\";\n    private static final int BASE_36 = 36;\n\n    private static final Integer SEQUENCE_LENGTH = 5;\n    @Resource\n    private RedissonClient redissonClient;\n\n    public String workSerialId() {\n        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyMM\");\n        String dateStr = LocalDate.now().format(formatter);\n        //使用了Redisson的AtomicLong对象生成唯一序列号\n        RAtomicLong atomicLong = redissonClient.getAtomicLong(ID_KEY+dateStr);\n        //设置过期时间为35天\n        if(atomicLong.get() == 0){\n            atomicLong.expire(Duration.ofDays(35));\n        }\n        //将唯一序列号转换为36进制的字符串，长度为4位，用于减少ID的长度\n        String sequenceStr = Long.toString(atomicLong.incrementAndGet(), BASE_36).toUpperCase();\n        //36进制的序列号若小于4位，则用0补齐高位\n        if (sequenceStr.length() < SEQUENCE_LENGTH) {\n            sequenceStr = String.format(\"%4s\", sequenceStr).replace(' ', '0');;\n        }\n        String serialId = dateStr+sequenceStr;\n\n        log.info(\"生成的工单号：{}\",dateStr+sequenceStr);\n        return dateStr+sequenceStr;\n    }\n\n}\n```\n\n**问题**：不过redis作为内存数据库，不保证可用性，它的数据不是一定能保证正确存储的。所以id可能会出现重复，这时需要进行一定的处理，比如抛异常，更新redis值等。\n\n# 4. 其他\n\nID的生成不拘泥于形式只要能满足业务的需求就行，除了这些常见的id生成策略还可以\n\n- UUID生成随机字符串\n\n- 自行拼接**日期**、**随机数**、**业务中值**等内容形成ID\n\n...\n\n","slug":"id生成","published":1,"updated":"2024-10-24T12:09:56.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6bm000eskusgntfbn1m","content":"<p>分布式场景下全局唯一id的生成方案，雪花算法、数据库自增、redis自增。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"1-雪花算法\"><a href=\"#1-雪花算法\" class=\"headerlink\" title=\"1. 雪花算法\"></a>1. 雪花算法</h1><h2 id=\"1-1-结构\"><a href=\"#1-1-结构\" class=\"headerlink\" title=\"1.1 结构\"></a>1.1 结构</h2><p><img src=\"/2024/09/02/id%E7%94%9F%E6%88%90/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.webp\" alt=\"8542a7cdeca53f63c9ad4f4dfd05f61b\"></p>\n<ul>\n<li>41bit时间戳：这里采用的就是当前系统的具体时间，单位为毫秒</li>\n<li>10bit工作机器ID（workerId）：每台机器分配一个id，这样可以标示不同的机器，但是上限为1024，标示一个集群某个业务最多部署的机器个数上限</li>\n<li>12bit序列号（自增域）：表示在某一毫秒下，这个自增域最大可以分配的bit个数，在当前这种配置下，每一毫秒可以分配2^12个数据，也就是说QPS可以到 409.6 w&#x2F;s。</li>\n</ul>\n<h2 id=\"1-2-代码实现\"><a href=\"#1-2-代码实现\" class=\"headerlink\" title=\"1.2 代码实现\"></a>1.2 代码实现</h2><p>可以用hutool中的工具类<code>IdUtil</code>来创建雪花算法生成的id</p>\n<ol>\n<li><p>导入<code>hutool</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">   &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class=\"line\">   &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class=\"line\">   &lt;version&gt;<span class=\"number\">5.7</span><span class=\"number\">.2</span>&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>IdUtil</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IdUtil.createSnowflake(<span class=\"number\">0L</span>,<span class=\"number\">1L</span>);</span><br><span class=\"line\"><span class=\"comment\">//传入参数是workerId和datacenterId</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Snowflake <span class=\"title function_\">createSnowflake</span><span class=\"params\">(<span class=\"type\">long</span> workerId, <span class=\"type\">long</span> datacenterId)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Snowflake</span>(workerId, datacenterId);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>代码剖析：</strong></p>\n<ol>\n<li><p><strong>初始化</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//上方函数调用的构造参数，进行初始化</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Snowflake</span><span class=\"params\">(<span class=\"type\">long</span> workerId, <span class=\"type\">long</span> dataCenterId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(workerId, dataCenterId, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Snowflake</span><span class=\"params\">(<span class=\"type\">long</span> workerId, <span class=\"type\">long</span> dataCenterId, <span class=\"type\">boolean</span> isUseSystemClock)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>((Date)<span class=\"literal\">null</span>, workerId, dataCenterId, isUseSystemClock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Snowflake</span><span class=\"params\">(Date epochDate, <span class=\"type\">long</span> workerId, <span class=\"type\">long</span> dataCenterId, <span class=\"type\">boolean</span> isUseSystemClock)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.workerIdBits = <span class=\"number\">5L</span>;</span><br><span class=\"line\">        <span class=\"comment\">//最大workerId，5位也就是2^5-1</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.maxWorkerId = <span class=\"number\">31L</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dataCenterIdBits = <span class=\"number\">5L</span>;</span><br><span class=\"line\">        <span class=\"comment\">//最大dataCenterId，5位也就是2^5-1</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.maxDataCenterId = <span class=\"number\">31L</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sequenceBits = <span class=\"number\">12L</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.workerIdShift = <span class=\"number\">12L</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dataCenterIdShift = <span class=\"number\">17L</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.timestampLeftShift = <span class=\"number\">22L</span>;</span><br><span class=\"line\">        <span class=\"comment\">//最大序列号，2^12 - 1</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sequenceMask = <span class=\"number\">4095L</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sequence = <span class=\"number\">0L</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.lastTimestamp = -<span class=\"number\">1L</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//使用工具类传的是null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != epochDate) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.twepoch = epochDate.getTime();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.twepoch = <span class=\"number\">1288834974657L</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerId &lt;= <span class=\"number\">31L</span> &amp;&amp; workerId &gt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dataCenterId &lt;= <span class=\"number\">31L</span> &amp;&amp; dataCenterId &gt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.workerId = workerId;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.dataCenterId = dataCenterId;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.useSystemClock = isUseSystemClock;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(StrUtil.format(<span class=\"string\">&quot;datacenter Id can&#x27;t be greater than &#123;&#125; or less than 0&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;<span class=\"number\">31L</span>&#125;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(StrUtil.format(<span class=\"string\">&quot;worker Id can&#x27;t be greater than &#123;&#125; or less than 0&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;<span class=\"number\">31L</span>&#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>具体创建逻辑</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"type\">long</span> <span class=\"title function_\">nextId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//生成的时间戳13位，默认的twepoch也是13位</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">timestamp</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.genTime();</span><br><span class=\"line\">    <span class=\"comment\">//时间片回拨问题，时间差较小进行同步,时间差较大直接抛异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestamp &lt; <span class=\"built_in\">this</span>.lastTimestamp) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.lastTimestamp - timestamp &gt;= <span class=\"number\">2000L</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(StrUtil.format(<span class=\"string\">&quot;Clock moved backwards. Refusing to generate id for &#123;&#125;ms&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;<span class=\"built_in\">this</span>.lastTimestamp - timestamp&#125;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            timestamp = <span class=\"built_in\">this</span>.lastTimestamp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">//序号自增,增到最大再次将时间戳更新(防止id重复)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestamp == <span class=\"built_in\">this</span>.lastTimestamp) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">sequence</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.sequence + <span class=\"number\">1L</span> &amp; <span class=\"number\">4095L</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sequence == <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                timestamp = <span class=\"built_in\">this</span>.tilNextMillis(<span class=\"built_in\">this</span>.lastTimestamp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.sequence = sequence;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.sequence = <span class=\"number\">0L</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.lastTimestamp = timestamp;</span><br><span class=\"line\">    <span class=\"comment\">//创建Id，(时间戳 - 1288834974657L) + 五位的dtaCenterId + 五位的workerId + 12位序列号</span></span><br><span class=\"line\">    <span class=\"comment\">//很符合雪花算法的结构 时间戳 + 10位机器Id + 12位序列号</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> timestamp - <span class=\"built_in\">this</span>.twepoch &lt;&lt; <span class=\"number\">22</span> | <span class=\"built_in\">this</span>.dataCenterId &lt;&lt; <span class=\"number\">17</span> | <span class=\"built_in\">this</span>.workerId &lt;&lt; <span class=\"number\">12</span> | <span class=\"built_in\">this</span>.sequence;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"1-3-问题\"><a href=\"#1-3-问题\" class=\"headerlink\" title=\"1.3 问题\"></a>1.3 问题</h2><p>雪花算法可能出现以下问题</p>\n<ul>\n<li><strong>时间片回拨</strong>：由于机器的时间是动态的调整的，有可能会出现时间跑到之前几毫秒，如果这个时候获取到了这种时间，则会出现<strong>id重复</strong></li>\n<li><strong>机器id分配以及回收</strong>：机器id需要每台机器不一样，这样的方式分配需要有方案进行处理，同时也要考虑，如果该机器宕机了，对应的workerId分配后的回收问题</li>\n<li><strong>机器id上线</strong>：机器id是固定的bit，那么也就是对应的机器个数是有上限的，在有些业务场景下，需要所有机器共享同一个业务空间，那么10bit表示的1024台机器是不够的。</li>\n</ul>\n<p><strong>解决方案</strong></p>\n<p>问题的处理没有完美的方案，只要选一个适合自身业务场景的就行</p>\n<ol>\n<li><p><strong>时间回拨问题</strong></p>\n<ul>\n<li>出现回拨直接抛异常</li>\n<li>采用等待跟上次时间的一段范围：这种算是简单解决，可以接受，但是如果等待一段时间后再出现回拨，则抛异常。（hutool工具包中就采用的这种方案）</li>\n</ul>\n</li>\n<li><p><strong>机器id上限</strong></p>\n<p>这个问题受限于雪花算法的结构，除非改一下雪花算法增加机器Id位数，不然没法解决</p>\n</li>\n</ol>\n<h3 id=\"机器id分配问题\"><a href=\"#机器id分配问题\" class=\"headerlink\" title=\"机器id分配问题\"></a>机器id分配问题</h3><p><strong>机器id分配问题</strong>比起雪花算法，它和业务的关联性更大，这里单独拿出来说一下。</p>\n<p>在上面代码中，我们使用hutool工具包随便传入了两个值作为workerId和datacenterId，但真实生产环境中这两个值是需要有一套分配策略来产生的（多个不同的Java程序使用相同的机器id可能会导致id重复生成）。</p>\n<p><strong>需求</strong>：</p>\n<ol>\n<li>机器id需要能够不重复的分配给所有JVM实例</li>\n<li>机器id数量有限，需要对不使用的机器id进行回收复用</li>\n</ol>\n<h4 id=\"1-3-1-直接使用ip地址\"><a href=\"#1-3-1-直接使用ip地址\" class=\"headerlink\" title=\"1.3.1 直接使用ip地址\"></a>1.3.1 直接使用ip地址</h4><p>服务器的IP地址一般都是公司的内网IP，子网划分时同一子网IP的前几位基本是相同的，根据这一特性我们可以在IP地址中取10位作为机器id。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IDGenerator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> workerId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> datacenterId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Snowflake snowflake;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">IDGenerator</span><span class=\"params\">(<span class=\"type\">long</span> workerId, <span class=\"type\">long</span> datacenterId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.workerId = workerId;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.datacenterId = datacenterId;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.snowflake = IdUtil.createSnowflake(<span class=\"built_in\">this</span>.workerId, <span class=\"built_in\">this</span>.datacenterId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@description</span> 默认使用ip地址最后10位作为机器id</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">IDGenerator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//取ip地址最后10位作为机器id</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">machineId</span> <span class=\"operator\">=</span> NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()) &amp; <span class=\"number\">1023</span>;</span><br><span class=\"line\">        <span class=\"comment\">//machineId低5位作为workerId</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.workerId = machineId &amp; <span class=\"number\">31</span>;</span><br><span class=\"line\">        <span class=\"comment\">//machineId高5位作为datacenterId</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.datacenterId = machineId &gt;&gt; <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.snowflake = IdUtil.createSnowflake(<span class=\"built_in\">this</span>.workerId, <span class=\"built_in\">this</span>.datacenterId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IDGenerator <span class=\"title function_\">createWithWorkerId</span><span class=\"params\">(<span class=\"type\">long</span> workerId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//取ip地址最后10位高五位作为默认datacenterId</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">datacenterId</span> <span class=\"operator\">=</span> (NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()) &gt;&gt; <span class=\"number\">5</span>) &amp; <span class=\"number\">31</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IDGenerator</span>(workerId, datacenterId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IDGenerator <span class=\"title function_\">createWithDatacenterId</span><span class=\"params\">(<span class=\"type\">long</span> datacenterId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//取ip地址最后五位作为默认workerId</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">workerId</span> <span class=\"operator\">=</span> NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()) &amp; <span class=\"number\">31</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IDGenerator</span>(workerId, datacenterId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IDGenerator <span class=\"title function_\">createWithWorkerIdAndDatacenterId</span><span class=\"params\">(<span class=\"type\">long</span> workerId, <span class=\"type\">long</span> datacenterId)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IDGenerator</span>(workerId, datacenterId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IDGenerator <span class=\"title function_\">createWithMachineId</span><span class=\"params\">(<span class=\"type\">long</span> machineId)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IDGenerator</span>(machineId &amp; <span class=\"number\">31</span>, machineId &gt;&gt; <span class=\"number\">5</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">nextId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> snowflake.nextId();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一台机器多个JVM或者ip地址最后十位相同时会导致机器id重复</p>\n<h4 id=\"1-3-2-redis维护机器id\"><a href=\"#1-3-2-redis维护机器id\" class=\"headerlink\" title=\"1.3.2 redis维护机器id\"></a>1.3.2 redis维护机器id</h4><p>参考<a href=\"https://juejin.cn/post/7280747572695679036\">失败的面的文章</a></p>\n<p>redis不保证可用性，可能会导致机器id重复</p>\n<h4 id=\"1-3-3-zookeeper维护机器id\"><a href=\"#1-3-3-zookeeper维护机器id\" class=\"headerlink\" title=\"1.3.3 zookeeper维护机器id\"></a>1.3.3 zookeeper维护机器id</h4><p>通过创建分区来监控服务器的状态</p>\n<h1 id=\"2-数据库自增\"><a href=\"#2-数据库自增\" class=\"headerlink\" title=\"2. 数据库自增\"></a>2. 数据库自增</h1><p>在数据库中创建一张表来维护全局唯一的自增id</p>\n<ol>\n<li><p><strong>建表</strong></p>\n<p>数据库表中id可能供多个服务使用，加上<code>type</code>区分使用场景（ 用户表需要自增id，其它表可能也需要），代码实现中可以定义枚举类来记录type</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `serial_number` (</span><br><span class=\"line\">  `number` <span class=\"type\">bigint</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span>,</span><br><span class=\"line\">  `type` <span class=\"type\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;自增id类型&#x27;</span>,</span><br><span class=\"line\">  `create_time` datetime(<span class=\"number\">3</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"built_in\">CURRENT_TIMESTAMP</span>(<span class=\"number\">3</span>),</span><br><span class=\"line\">  `update_time` datetime(<span class=\"number\">3</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"built_in\">CURRENT_TIMESTAMP</span>(<span class=\"number\">3</span>) <span class=\"keyword\">ON</span> <span class=\"keyword\">UPDATE</span> <span class=\"built_in\">CURRENT_TIMESTAMP</span>(<span class=\"number\">3</span>),</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`type`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4 <span class=\"keyword\">commit</span> <span class=\"string\">&#x27;全局自增id表&#x27;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>编写代码</strong></p>\n<p>数据库操作</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">mapper</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"keyword\">PUBLIC</span> <span class=\"string\">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"string\">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">&quot;org.example.learn.mapper.SerialNumberMapper&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;BaseResultMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;org.example.learn.entity.SerialNumber&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;type&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;type&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;number&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;number&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;createTime&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;create_time&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;TIMESTAMP&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;updateTime&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;update_time&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;TIMESTAMP&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;getId&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class=\"line\">        select number</span><br><span class=\"line\">        from serial_number</span><br><span class=\"line\">        where type = #&#123;type&#125; FOR UPDATE;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">insert</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;insert&quot;</span> &gt;</span></span><br><span class=\"line\">        insert into serial_number</span><br><span class=\"line\">        ( type,number)</span><br><span class=\"line\">        values (#&#123;type&#125;,#&#123;number&#125;);</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">insert</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">update</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;increment&quot;</span> &gt;</span></span><br><span class=\"line\">        update serial_number</span><br><span class=\"line\">        set number = number + 1</span><br><span class=\"line\">        where type = #&#123;type&#125;;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">update</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.example.learn.mapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.annotations.Param;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">SerialNumberMapper</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">insert</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;number&quot;)</span>Long number,<span class=\"meta\">@Param(&quot;type&quot;)</span>String type)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Long <span class=\"title function_\">getId</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">increment</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;type&quot;)</span>String type)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>id生成服务</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//id生成的具体逻辑</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"comment\">//加事务保证外层事务回滚时，id生成也跟着回滚</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SerialNumberServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">SerialNumberService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SerialNumberMapper serialNumberMapper;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">getId</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> serialNumberMapper.getId(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num == <span class=\"literal\">null</span>||num == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            serialNumberMapper.insert(<span class=\"number\">1L</span>,<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(serialNumberMapper.increment(<span class=\"string\">&quot;test&quot;</span>)==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> num+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;data error&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"3-redis生成ID\"><a href=\"#3-redis生成ID\" class=\"headerlink\" title=\"3. redis生成ID\"></a>3. redis生成ID</h1><p>可以用redis定义一个Hash类型或者多个key来表示要用的Id，每次使用的时候incr自增就行了。</p>\n<p>Redisson 中有AtmoicLong类型数据可以用作自增id，引用自 <a href=\"https://juejin.cn/post/7325642452819673100\">修己xj</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SerialIdService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">ID_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;xiuji:&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">BASE_36</span> <span class=\"operator\">=</span> <span class=\"number\">36</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">SEQUENCE_LENGTH</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">workSerialId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">DateTimeFormatter</span> <span class=\"variable\">formatter</span> <span class=\"operator\">=</span> DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyMM&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">dateStr</span> <span class=\"operator\">=</span> LocalDate.now().format(formatter);</span><br><span class=\"line\">        <span class=\"comment\">//使用了Redisson的AtomicLong对象生成唯一序列号</span></span><br><span class=\"line\">        <span class=\"type\">RAtomicLong</span> <span class=\"variable\">atomicLong</span> <span class=\"operator\">=</span> redissonClient.getAtomicLong(ID_KEY+dateStr);</span><br><span class=\"line\">        <span class=\"comment\">//设置过期时间为35天</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(atomicLong.get() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            atomicLong.expire(Duration.ofDays(<span class=\"number\">35</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//将唯一序列号转换为36进制的字符串，长度为4位，用于减少ID的长度</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sequenceStr</span> <span class=\"operator\">=</span> Long.toString(atomicLong.incrementAndGet(), BASE_36).toUpperCase();</span><br><span class=\"line\">        <span class=\"comment\">//36进制的序列号若小于4位，则用0补齐高位</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sequenceStr.length() &lt; SEQUENCE_LENGTH) &#123;</span><br><span class=\"line\">            sequenceStr = String.format(<span class=\"string\">&quot;%4s&quot;</span>, sequenceStr).replace(<span class=\"string\">&#x27; &#x27;</span>, <span class=\"string\">&#x27;0&#x27;</span>);;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">serialId</span> <span class=\"operator\">=</span> dateStr+sequenceStr;</span><br><span class=\"line\"></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;生成的工单号：&#123;&#125;&quot;</span>,dateStr+sequenceStr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dateStr+sequenceStr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>问题</strong>：不过redis作为内存数据库，不保证可用性，它的数据不是一定能保证正确存储的。所以id可能会出现重复，这时需要进行一定的处理，比如抛异常，更新redis值等。</p>\n<h1 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4. 其他\"></a>4. 其他</h1><p>ID的生成不拘泥于形式只要能满足业务的需求就行，除了这些常见的id生成策略还可以</p>\n<ul>\n<li><p>UUID生成随机字符串</p>\n</li>\n<li><p>自行拼接<strong>日期</strong>、<strong>随机数</strong>、<strong>业务中值</strong>等内容形成ID</p>\n</li>\n</ul>\n<p>…</p>\n","site":{"data":{}},"length":2158,"excerpt":"<p>分布式场景下全局唯一id的生成方案，雪花算法、数据库自增、redis自增。</p>","more":"<h1 id=\"1-雪花算法\"><a href=\"#1-雪花算法\" class=\"headerlink\" title=\"1. 雪花算法\"></a>1. 雪花算法</h1><h2 id=\"1-1-结构\"><a href=\"#1-1-结构\" class=\"headerlink\" title=\"1.1 结构\"></a>1.1 结构</h2><p><img src=\"/2024/09/02/id%E7%94%9F%E6%88%90/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.webp\" alt=\"8542a7cdeca53f63c9ad4f4dfd05f61b\"></p>\n<ul>\n<li>41bit时间戳：这里采用的就是当前系统的具体时间，单位为毫秒</li>\n<li>10bit工作机器ID（workerId）：每台机器分配一个id，这样可以标示不同的机器，但是上限为1024，标示一个集群某个业务最多部署的机器个数上限</li>\n<li>12bit序列号（自增域）：表示在某一毫秒下，这个自增域最大可以分配的bit个数，在当前这种配置下，每一毫秒可以分配2^12个数据，也就是说QPS可以到 409.6 w&#x2F;s。</li>\n</ul>\n<h2 id=\"1-2-代码实现\"><a href=\"#1-2-代码实现\" class=\"headerlink\" title=\"1.2 代码实现\"></a>1.2 代码实现</h2><p>可以用hutool中的工具类<code>IdUtil</code>来创建雪花算法生成的id</p>\n<ol>\n<li><p>导入<code>hutool</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">   &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class=\"line\">   &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class=\"line\">   &lt;version&gt;<span class=\"number\">5.7</span><span class=\"number\">.2</span>&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用<code>IdUtil</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IdUtil.createSnowflake(<span class=\"number\">0L</span>,<span class=\"number\">1L</span>);</span><br><span class=\"line\"><span class=\"comment\">//传入参数是workerId和datacenterId</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Snowflake <span class=\"title function_\">createSnowflake</span><span class=\"params\">(<span class=\"type\">long</span> workerId, <span class=\"type\">long</span> datacenterId)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Snowflake</span>(workerId, datacenterId);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>代码剖析：</strong></p>\n<ol>\n<li><p><strong>初始化</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//上方函数调用的构造参数，进行初始化</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Snowflake</span><span class=\"params\">(<span class=\"type\">long</span> workerId, <span class=\"type\">long</span> dataCenterId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(workerId, dataCenterId, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Snowflake</span><span class=\"params\">(<span class=\"type\">long</span> workerId, <span class=\"type\">long</span> dataCenterId, <span class=\"type\">boolean</span> isUseSystemClock)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>((Date)<span class=\"literal\">null</span>, workerId, dataCenterId, isUseSystemClock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Snowflake</span><span class=\"params\">(Date epochDate, <span class=\"type\">long</span> workerId, <span class=\"type\">long</span> dataCenterId, <span class=\"type\">boolean</span> isUseSystemClock)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.workerIdBits = <span class=\"number\">5L</span>;</span><br><span class=\"line\">        <span class=\"comment\">//最大workerId，5位也就是2^5-1</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.maxWorkerId = <span class=\"number\">31L</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dataCenterIdBits = <span class=\"number\">5L</span>;</span><br><span class=\"line\">        <span class=\"comment\">//最大dataCenterId，5位也就是2^5-1</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.maxDataCenterId = <span class=\"number\">31L</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sequenceBits = <span class=\"number\">12L</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.workerIdShift = <span class=\"number\">12L</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.dataCenterIdShift = <span class=\"number\">17L</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.timestampLeftShift = <span class=\"number\">22L</span>;</span><br><span class=\"line\">        <span class=\"comment\">//最大序列号，2^12 - 1</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sequenceMask = <span class=\"number\">4095L</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.sequence = <span class=\"number\">0L</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.lastTimestamp = -<span class=\"number\">1L</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//使用工具类传的是null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> != epochDate) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.twepoch = epochDate.getTime();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.twepoch = <span class=\"number\">1288834974657L</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerId &lt;= <span class=\"number\">31L</span> &amp;&amp; workerId &gt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dataCenterId &lt;= <span class=\"number\">31L</span> &amp;&amp; dataCenterId &gt;= <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.workerId = workerId;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.dataCenterId = dataCenterId;</span><br><span class=\"line\">                <span class=\"built_in\">this</span>.useSystemClock = isUseSystemClock;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(StrUtil.format(<span class=\"string\">&quot;datacenter Id can&#x27;t be greater than &#123;&#125; or less than 0&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;<span class=\"number\">31L</span>&#125;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(StrUtil.format(<span class=\"string\">&quot;worker Id can&#x27;t be greater than &#123;&#125; or less than 0&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;<span class=\"number\">31L</span>&#125;));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>具体创建逻辑</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"type\">long</span> <span class=\"title function_\">nextId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//生成的时间戳13位，默认的twepoch也是13位</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">timestamp</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.genTime();</span><br><span class=\"line\">    <span class=\"comment\">//时间片回拨问题，时间差较小进行同步,时间差较大直接抛异常</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestamp &lt; <span class=\"built_in\">this</span>.lastTimestamp) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.lastTimestamp - timestamp &gt;= <span class=\"number\">2000L</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(StrUtil.format(<span class=\"string\">&quot;Clock moved backwards. Refusing to generate id for &#123;&#125;ms&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>[]&#123;<span class=\"built_in\">this</span>.lastTimestamp - timestamp&#125;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            timestamp = <span class=\"built_in\">this</span>.lastTimestamp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">//序号自增,增到最大再次将时间戳更新(防止id重复)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timestamp == <span class=\"built_in\">this</span>.lastTimestamp) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">sequence</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.sequence + <span class=\"number\">1L</span> &amp; <span class=\"number\">4095L</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sequence == <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                timestamp = <span class=\"built_in\">this</span>.tilNextMillis(<span class=\"built_in\">this</span>.lastTimestamp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.sequence = sequence;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.sequence = <span class=\"number\">0L</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.lastTimestamp = timestamp;</span><br><span class=\"line\">    <span class=\"comment\">//创建Id，(时间戳 - 1288834974657L) + 五位的dtaCenterId + 五位的workerId + 12位序列号</span></span><br><span class=\"line\">    <span class=\"comment\">//很符合雪花算法的结构 时间戳 + 10位机器Id + 12位序列号</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> timestamp - <span class=\"built_in\">this</span>.twepoch &lt;&lt; <span class=\"number\">22</span> | <span class=\"built_in\">this</span>.dataCenterId &lt;&lt; <span class=\"number\">17</span> | <span class=\"built_in\">this</span>.workerId &lt;&lt; <span class=\"number\">12</span> | <span class=\"built_in\">this</span>.sequence;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"1-3-问题\"><a href=\"#1-3-问题\" class=\"headerlink\" title=\"1.3 问题\"></a>1.3 问题</h2><p>雪花算法可能出现以下问题</p>\n<ul>\n<li><strong>时间片回拨</strong>：由于机器的时间是动态的调整的，有可能会出现时间跑到之前几毫秒，如果这个时候获取到了这种时间，则会出现<strong>id重复</strong></li>\n<li><strong>机器id分配以及回收</strong>：机器id需要每台机器不一样，这样的方式分配需要有方案进行处理，同时也要考虑，如果该机器宕机了，对应的workerId分配后的回收问题</li>\n<li><strong>机器id上线</strong>：机器id是固定的bit，那么也就是对应的机器个数是有上限的，在有些业务场景下，需要所有机器共享同一个业务空间，那么10bit表示的1024台机器是不够的。</li>\n</ul>\n<p><strong>解决方案</strong></p>\n<p>问题的处理没有完美的方案，只要选一个适合自身业务场景的就行</p>\n<ol>\n<li><p><strong>时间回拨问题</strong></p>\n<ul>\n<li>出现回拨直接抛异常</li>\n<li>采用等待跟上次时间的一段范围：这种算是简单解决，可以接受，但是如果等待一段时间后再出现回拨，则抛异常。（hutool工具包中就采用的这种方案）</li>\n</ul>\n</li>\n<li><p><strong>机器id上限</strong></p>\n<p>这个问题受限于雪花算法的结构，除非改一下雪花算法增加机器Id位数，不然没法解决</p>\n</li>\n</ol>\n<h3 id=\"机器id分配问题\"><a href=\"#机器id分配问题\" class=\"headerlink\" title=\"机器id分配问题\"></a>机器id分配问题</h3><p><strong>机器id分配问题</strong>比起雪花算法，它和业务的关联性更大，这里单独拿出来说一下。</p>\n<p>在上面代码中，我们使用hutool工具包随便传入了两个值作为workerId和datacenterId，但真实生产环境中这两个值是需要有一套分配策略来产生的（多个不同的Java程序使用相同的机器id可能会导致id重复生成）。</p>\n<p><strong>需求</strong>：</p>\n<ol>\n<li>机器id需要能够不重复的分配给所有JVM实例</li>\n<li>机器id数量有限，需要对不使用的机器id进行回收复用</li>\n</ol>\n<h4 id=\"1-3-1-直接使用ip地址\"><a href=\"#1-3-1-直接使用ip地址\" class=\"headerlink\" title=\"1.3.1 直接使用ip地址\"></a>1.3.1 直接使用ip地址</h4><p>服务器的IP地址一般都是公司的内网IP，子网划分时同一子网IP的前几位基本是相同的，根据这一特性我们可以在IP地址中取10位作为机器id。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IDGenerator</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> workerId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">long</span> datacenterId;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Snowflake snowflake;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">IDGenerator</span><span class=\"params\">(<span class=\"type\">long</span> workerId, <span class=\"type\">long</span> datacenterId)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.workerId = workerId;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.datacenterId = datacenterId;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.snowflake = IdUtil.createSnowflake(<span class=\"built_in\">this</span>.workerId, <span class=\"built_in\">this</span>.datacenterId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@description</span> 默认使用ip地址最后10位作为机器id</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">IDGenerator</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//取ip地址最后10位作为机器id</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">machineId</span> <span class=\"operator\">=</span> NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()) &amp; <span class=\"number\">1023</span>;</span><br><span class=\"line\">        <span class=\"comment\">//machineId低5位作为workerId</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.workerId = machineId &amp; <span class=\"number\">31</span>;</span><br><span class=\"line\">        <span class=\"comment\">//machineId高5位作为datacenterId</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.datacenterId = machineId &gt;&gt; <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.snowflake = IdUtil.createSnowflake(<span class=\"built_in\">this</span>.workerId, <span class=\"built_in\">this</span>.datacenterId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IDGenerator <span class=\"title function_\">createWithWorkerId</span><span class=\"params\">(<span class=\"type\">long</span> workerId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//取ip地址最后10位高五位作为默认datacenterId</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">datacenterId</span> <span class=\"operator\">=</span> (NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()) &gt;&gt; <span class=\"number\">5</span>) &amp; <span class=\"number\">31</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IDGenerator</span>(workerId, datacenterId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IDGenerator <span class=\"title function_\">createWithDatacenterId</span><span class=\"params\">(<span class=\"type\">long</span> datacenterId)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//取ip地址最后五位作为默认workerId</span></span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">workerId</span> <span class=\"operator\">=</span> NetUtil.ipv4ToLong(NetUtil.getLocalhostStr()) &amp; <span class=\"number\">31</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IDGenerator</span>(workerId, datacenterId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IDGenerator <span class=\"title function_\">createWithWorkerIdAndDatacenterId</span><span class=\"params\">(<span class=\"type\">long</span> workerId, <span class=\"type\">long</span> datacenterId)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IDGenerator</span>(workerId, datacenterId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> IDGenerator <span class=\"title function_\">createWithMachineId</span><span class=\"params\">(<span class=\"type\">long</span> machineId)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IDGenerator</span>(machineId &amp; <span class=\"number\">31</span>, machineId &gt;&gt; <span class=\"number\">5</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">nextId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> snowflake.nextId();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一台机器多个JVM或者ip地址最后十位相同时会导致机器id重复</p>\n<h4 id=\"1-3-2-redis维护机器id\"><a href=\"#1-3-2-redis维护机器id\" class=\"headerlink\" title=\"1.3.2 redis维护机器id\"></a>1.3.2 redis维护机器id</h4><p>参考<a href=\"https://juejin.cn/post/7280747572695679036\">失败的面的文章</a></p>\n<p>redis不保证可用性，可能会导致机器id重复</p>\n<h4 id=\"1-3-3-zookeeper维护机器id\"><a href=\"#1-3-3-zookeeper维护机器id\" class=\"headerlink\" title=\"1.3.3 zookeeper维护机器id\"></a>1.3.3 zookeeper维护机器id</h4><p>通过创建分区来监控服务器的状态</p>\n<h1 id=\"2-数据库自增\"><a href=\"#2-数据库自增\" class=\"headerlink\" title=\"2. 数据库自增\"></a>2. 数据库自增</h1><p>在数据库中创建一张表来维护全局唯一的自增id</p>\n<ol>\n<li><p><strong>建表</strong></p>\n<p>数据库表中id可能供多个服务使用，加上<code>type</code>区分使用场景（ 用户表需要自增id，其它表可能也需要），代码实现中可以定义枚举类来记录type</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `serial_number` (</span><br><span class=\"line\">  `number` <span class=\"type\">bigint</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span>,</span><br><span class=\"line\">  `type` <span class=\"type\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;自增id类型&#x27;</span>,</span><br><span class=\"line\">  `create_time` datetime(<span class=\"number\">3</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"built_in\">CURRENT_TIMESTAMP</span>(<span class=\"number\">3</span>),</span><br><span class=\"line\">  `update_time` datetime(<span class=\"number\">3</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"built_in\">CURRENT_TIMESTAMP</span>(<span class=\"number\">3</span>) <span class=\"keyword\">ON</span> <span class=\"keyword\">UPDATE</span> <span class=\"built_in\">CURRENT_TIMESTAMP</span>(<span class=\"number\">3</span>),</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`type`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4 <span class=\"keyword\">commit</span> <span class=\"string\">&#x27;全局自增id表&#x27;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>编写代码</strong></p>\n<p>数据库操作</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">mapper</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"keyword\">PUBLIC</span> <span class=\"string\">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"string\">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mapper</span> <span class=\"attr\">namespace</span>=<span class=\"string\">&quot;org.example.learn.mapper.SerialNumberMapper&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">resultMap</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;BaseResultMap&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;org.example.learn.entity.SerialNumber&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;type&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;type&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;number&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;number&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;createTime&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;create_time&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;TIMESTAMP&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">result</span> <span class=\"attr\">property</span>=<span class=\"string\">&quot;updateTime&quot;</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;update_time&quot;</span> <span class=\"attr\">jdbcType</span>=<span class=\"string\">&quot;TIMESTAMP&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">resultMap</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;getId&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class=\"line\">        select number</span><br><span class=\"line\">        from serial_number</span><br><span class=\"line\">        where type = #&#123;type&#125; FOR UPDATE;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">insert</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;insert&quot;</span> &gt;</span></span><br><span class=\"line\">        insert into serial_number</span><br><span class=\"line\">        ( type,number)</span><br><span class=\"line\">        values (#&#123;type&#125;,#&#123;number&#125;);</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">insert</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">update</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;increment&quot;</span> &gt;</span></span><br><span class=\"line\">        update serial_number</span><br><span class=\"line\">        set number = number + 1</span><br><span class=\"line\">        where type = #&#123;type&#125;;</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">update</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.example.learn.mapper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.ibatis.annotations.Param;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">SerialNumberMapper</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">insert</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;number&quot;)</span>Long number,<span class=\"meta\">@Param(&quot;type&quot;)</span>String type)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Long <span class=\"title function_\">getId</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;id&quot;)</span> Long id)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">increment</span><span class=\"params\">(<span class=\"meta\">@Param(&quot;type&quot;)</span>String type)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>id生成服务</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//id生成的具体逻辑</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"comment\">//加事务保证外层事务回滚时，id生成也跟着回滚</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SerialNumberServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">SerialNumberService</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SerialNumberMapper serialNumberMapper;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"title function_\">getId</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Long</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> serialNumberMapper.getId(<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num == <span class=\"literal\">null</span>||num == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            serialNumberMapper.insert(<span class=\"number\">1L</span>,<span class=\"string\">&quot;test&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1L</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(serialNumberMapper.increment(<span class=\"string\">&quot;test&quot;</span>)==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> num+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;data error&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"3-redis生成ID\"><a href=\"#3-redis生成ID\" class=\"headerlink\" title=\"3. redis生成ID\"></a>3. redis生成ID</h1><p>可以用redis定义一个Hash类型或者多个key来表示要用的Id，每次使用的时候incr自增就行了。</p>\n<p>Redisson 中有AtmoicLong类型数据可以用作自增id，引用自 <a href=\"https://juejin.cn/post/7325642452819673100\">修己xj</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@Slf4j</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SerialIdService</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">ID_KEY</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;xiuji:&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">BASE_36</span> <span class=\"operator\">=</span> <span class=\"number\">36</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Integer</span> <span class=\"variable\">SEQUENCE_LENGTH</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedissonClient redissonClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">workSerialId</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">DateTimeFormatter</span> <span class=\"variable\">formatter</span> <span class=\"operator\">=</span> DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyMM&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">dateStr</span> <span class=\"operator\">=</span> LocalDate.now().format(formatter);</span><br><span class=\"line\">        <span class=\"comment\">//使用了Redisson的AtomicLong对象生成唯一序列号</span></span><br><span class=\"line\">        <span class=\"type\">RAtomicLong</span> <span class=\"variable\">atomicLong</span> <span class=\"operator\">=</span> redissonClient.getAtomicLong(ID_KEY+dateStr);</span><br><span class=\"line\">        <span class=\"comment\">//设置过期时间为35天</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(atomicLong.get() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            atomicLong.expire(Duration.ofDays(<span class=\"number\">35</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//将唯一序列号转换为36进制的字符串，长度为4位，用于减少ID的长度</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">sequenceStr</span> <span class=\"operator\">=</span> Long.toString(atomicLong.incrementAndGet(), BASE_36).toUpperCase();</span><br><span class=\"line\">        <span class=\"comment\">//36进制的序列号若小于4位，则用0补齐高位</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sequenceStr.length() &lt; SEQUENCE_LENGTH) &#123;</span><br><span class=\"line\">            sequenceStr = String.format(<span class=\"string\">&quot;%4s&quot;</span>, sequenceStr).replace(<span class=\"string\">&#x27; &#x27;</span>, <span class=\"string\">&#x27;0&#x27;</span>);;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">serialId</span> <span class=\"operator\">=</span> dateStr+sequenceStr;</span><br><span class=\"line\"></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;生成的工单号：&#123;&#125;&quot;</span>,dateStr+sequenceStr);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dateStr+sequenceStr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>问题</strong>：不过redis作为内存数据库，不保证可用性，它的数据不是一定能保证正确存储的。所以id可能会出现重复，这时需要进行一定的处理，比如抛异常，更新redis值等。</p>\n<h1 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4. 其他\"></a>4. 其他</h1><p>ID的生成不拘泥于形式只要能满足业务的需求就行，除了这些常见的id生成策略还可以</p>\n<ul>\n<li><p>UUID生成随机字符串</p>\n</li>\n<li><p>自行拼接<strong>日期</strong>、<strong>随机数</strong>、<strong>业务中值</strong>等内容形成ID</p>\n</li>\n</ul>\n<p>…</p>"},{"title":"IO","date":"2024-09-10T08:18:00.000Z","_content":"\n本文主要关注于java中的IO\n\n<!--more-->\n\n# 1. 基础\n\n![java-io-overview2](./java_IO/java-io-overview2.png)\n\n## 1.1 分类\n\n1. 按数据的流向不同分为：**输入流和输出流**\n\n2. 按操作数据单位的不同分为：**字节流（8bit）和字符流（16bit）**\n\n   编码是将字符流转化为字节流，解码是将字节流转化为字节流，编码解码规则不一样会导致乱码\n\n   字节是给计算机看的，字符是给人看的。一个字符的大小和编码方式和字符类型有关。\n\n   java使用UTF-16be 编码，中文字符和英文字符都占 2 个字节，这样一个中文或者英文字符都可以通过一个单位char类型存放。\n\n3. 根据IO流的角色不同分为：**节点流和处理流**\n\n   - 节点流：直接从数据源或目的地读写数据\n   - 处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）上\n\n## 1.2 文件\n\n文件在java中对应的对象为`File`，文件在程序中是以流的形式来操作的\n\n<img src=\"./java_IO/image-20240225220137926.png\" alt=\"image-20240225220137926\" style=\"zoom:60%;\" />\n\n```java\n//常用构造方法\n    //父目录以及子目录\n\tpublic File(String parent, String child) {}\n\t//父文件下所在目录的子目录\n    private File(String child, File parent) {}\n   //正常的路径\n    public File(String pathname) {}\n```\n\n所有 `java.io` 中的类的**相对路径**默认都是从**用户工作目录**开始的，使用 `System.getProperty(\"user.dir\")` 可以获取你的用户工作目录。\n\n在 Windows 系统中的分隔符为 \"`\\\\`\"，在 Linux 系统中分隔符为 \"`/`\"，为了保证系统的可移植性，可以通过常量字符串 `java.io.File.separator` 获取。\n\n```java\n/**\n     * @param filename 文件名\n     * @param path 文件所在路径\n     *\n     */\n    public static void createNewFile(String filename,String path){\n        if(filename.isEmpty())\n            return ;\n        String pa = path+ File.separator+filename;\n        //可以使用其他方式创建File对象\n        File file = new File(pa);\n        try{\n            file.createNewFile();\n        }catch (IOException e){\n            e.printStackTrace();\n        }\n    }\n```\n\n\n\n| 返回值  | 方法名            | 描述             |\n| ------- | ----------------- | ---------------- |\n| String  | getName()         | 获取文件名       |\n| String  | getAbsolutePath() | 获取文件绝对路径 |\n| String  | getParent()       | 获取文件父级目录 |\n| long    | length()          | 返回文件字节大小 |\n| boolean | exists()          | 判断文件是否存在 |\n| boolean | isFile()          | 判断是否是文件   |\n| boolean | isDirectory()     | 判断是否是目录   |\n\n| 返回值  | 方法名   | 描述           |\n| ------- | -------- | -------------- |\n| boolean | mkdir()  | 创建一级目录   |\n| boolean | mkdirs() | 创建多级目录   |\n| boolean | delete() | 删除文件或目录 |\n\n```java\n public void tableOfContent(){\n        String parentPath = System.getProperty(\"user.dir\");\n        String fileName = \"testFile.txt\";\n        String directoryName = \"a\";\n        String mulDirectoryName = \"b/c/d\";\n        // 删除文件\n        File file = new File(parentPath, fileName);\n        file.delete();\n        // 创建一级目录\n        File directory = new File(parentPath, directoryName);\n        directory.mkdir();\n        // 创建多级目录\n        File mulDirectory = new File(parentPath, mulDirectoryName);\n        mulDirectory.mkdirs();\n        // 删除目录\n        directory.delete();\n    }\n```\n\n## 1.3 输入输出流\n\n**try-with-resources**\n\n这个语法糖的出现主要是为了减少关闭创建资源的工作\n\n详见https://zhuanlan.zhihu.com/p/27824934\n\n### 1.3.1 字节流\n\n<img src=\"./java_IO/image-20240226191911489.png\" alt=\"image-20240226191911489\" style=\"zoom:80%;\" />\n\n#### InputStream系\n\n\n\n| 返回值 | 方法                                   | 描述                                                         |\n| ------ | -------------------------------------- | ------------------------------------------------------------ |\n| int    | read()                                 | 返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 `-1` ，表示文件结束。 |\n| int    | read(byte b[ ])                        | 从输入流中读取一些字节存储到数组 `b` 中。如果数组 `b` 的长度为零，则不读取。如果没有可用字节读取，返回 `-1`。如果有可用字节读取，则最多读取的字节数最多等于 `b.length` ，返回读取的字节数。 |\n| int    | read(byte b[], int off, int len)       | 在`read(byte b[ ])` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字节数）。 |\n| long   | skip(long n)                           | 忽略输入流中的 `n` 个字节 ，返回实际忽略的字节数。           |\n| int    | available()                            | 返回输入流中可以读取的字节数。                               |\n| void   | close()                                | 关闭输入流释放相关的系统资源。                               |\n| byte[] | readAllBytes()                         | 读取输入流中的所有字节，返回字节数组。                       |\n| byte[] | readNBytes(byte[] b, int off, int len) | 阻塞直到读取 `len` 个字节。                                  |\n| long   | transferTo(OutputStream out)           | 将所有字节从一个输入流传递到一个输出流。                     |\n\n1. **FileInputStream**\n\n   <img src=\"./java_IO/image-20240226193441574.png\" alt=\"image-20240226193441574\" style=\"zoom:67%;\" />\n\n   可以把File类实例作为参数传入构造函数，以类似以下读取数据\n\n   ```java\n    FileInputStream in = new FileInputStream(new File(\"文件路径\"));\n    byte[] buf = new byte[8]; \n    int readLen;\n           // 返回值为 -1 时，表示读取完毕\n           while ((readLen = in.read(buf)) != -1) {\n               System.out.print(new String(buf, 0, readLen)); \n   ```\n\n2. **FilterInputStream**\n\n   该类是标准的装饰器模式的示例，FilterInputStream作为装饰器的根抽象类，可以接收InputStream对象实例作为参数以增强原有功能。\n\n   - **BufferedInputStream**\n\n     内置了缓冲，可以提升效率（尽量使用该类）\n\n     ```java\n     //再套一层就行了\n     BufferedInputStream in = new BufferedInputStream(new FileInputStream(new File(\"文件路径\")));\n             byte[] buf = new byte[8];\n             int readLen;\n             // 返回值为 -1 时，表示读取完毕\n             while ((readLen = in.read(buf)) != -1) {\n                 System.out.print(new String(buf, 0, readLen));\n             }\n     ```\n\n   - **DataInputStream**\n\n     用于读取指定类型的数据\n\n     ```java\n     @Test\n     public void testDataInputStream() throws IOException {\n         // 必须将一个 InputStream 的实现类作为构造参数才能使用\n         try(DataInputStream dis = new DataInputStream(new FileInputStream(\"mrpersimmon2.txt\"))) {\n             // 可以读取任意具体的类型数据\n             System.out.println(dis.readUTF()); // 读取已使用 modified UTF-8 格式编码的字符串。\n         } catch (IOException e) {\n             e.printStackTrace();\n         }\n     }\n     ```\n\n3. **ObjectInputStream**\n\n   该类是序列化相关的类（反序列化），也就是可以从流中读取对象\n\n\n#### OutputStream系\n\n| 返回值 | 方法名                            | 描述                                                         |\n| ------ | --------------------------------- | ------------------------------------------------------------ |\n| void   | write(int b)                      | 将特定字节写入输出流。                                       |\n| void   | write(byte[] b)                   | 将数组 `b` 写入到输出流，等价于 `write(b, 0, b.length)` 。   |\n| void   | write(byte[] b, int off, int len) | 在 `write(byte b[])` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字节数）。 |\n| void   | flush()                           | 刷新此输出流并强制写出所有缓冲的输出字节。                   |\n| void   | close()                           | 关闭输出流释放相关的系统资源。                               |\n\nOutputStream 下的子类`FileOutputStream` ，`DataOutputStream`，`ObjectOutputStream`与`InputStream`中的类似\n\n##### PrintStream\n\n经常使用的 `System.out` 就是用于获取一个 `PrintStream` 对象，`System.out.print` 方法实际调用的是 `PrintStream` 对象的 `write` 方法。默认情况下，`PrintStream` 输出数据的位置是标准输出，即显示器。\n\nprint(x)会先调用String.valueOf(x)将内容转换成字符串，在调用内部的write()方法。\n\n### 1.3.2 字符流\n\n#### Writer系\n\n| 返回值 | 方法名                               | 描述                                                         |\n| ------ | ------------------------------------ | ------------------------------------------------------------ |\n| void   | write(int c)                         | 写入单个字符。                                               |\n| void   | write(char[] cbuf)                   | 写入字符数组 `cbuf`，等价于`write(cbuf, 0, cbuf.length)`。   |\n| void   | write(char[] cbuf, int off, int len) | 在`write(char[] cbuf)` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字符数）。 |\n| void   | write(String str)                    | 写入字符串，等价于 `write(str, 0, str.length())` 。          |\n| void   | write(String str, int off, int len)  | 在`write(String str)` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字符数）。 |\n| Writer | append(CharSenquence csq)            | 将指定的字符序列附加到指定的 `Writer` 对象并返回该 `Writer` 对象。 |\n| Writer | append(char c)                       | 将指定的字符附加到指定的 `Writer` 对象并返回该 `Writer` 对象. |\n| void   | flush()                              | 刷新此输出流并强制写出所有缓冲的输出字符。                   |\n| void   | close()                              | 关闭输出流释放相关的系统资源。                               |\n\n \n\n#### Reader系\n\n| 返回值 | 方法名                              | 描述                                                         |\n| ------ | ----------------------------------- | ------------------------------------------------------------ |\n| int    | read()                              | 从输入流读取一个字符。                                       |\n| int    | read(char[] cbuf)                   | 从输入流中读取一些字符，并将它们存储到字符数组 `cbuf`中，等价于 `read(cbuf, 0, cbuf.length)` 。 |\n| int    | read(char[] cbuf, int off, int len) | 在`read(char[] cbuf)` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字符数）。 |\n| long   | skip(long n)                        | 忽略输入流中的 n 个字符，返回实际忽略的字符数。              |\n| void   | close()                             | 关闭输入流并释放相关的系统资源。                             |\n\n### 1.3.3 OutputStreamWriter与InputStreamReader\n\n这两个类是FileWriter/Reader的父类，主要作用是进行字符与字节之间的转化\n\n## 1.4 综合\n\n计算机只认字节，所以使用字节流效率要大于字符流（字符流也是通过字符与字节之间转化来实现流与文件交互的）.\n\nIO操作很耗时，所以一次尽量操作较多数据。\n\n## RandomAccessFile类\n\n**支持随意跳转到文件任意位置读写**\n\n```java\n// String name: 指定名称的文件\npublic RandomAccessFile(String name, String mode) throws FileNotFoundException{\n    this(name != null ? new File(name) : null, mode);\n}\n// String file: 指定文件\npublic RandomAccessFile(File file, String mode) throws FileNotFoundException{...}\n```\n\n| mode | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| r    | 只读                                                         |\n| rw   | 读写                                                         |\n| rwd  | 相较于 `rw`，还要求对「文件内容」的每次更新都同步写入底层存储设备。 |\n| rws  | 相较于 `rw`，还需要将对「文件内容」或「元数据」的每次更新同步写入底层存储设备； |\n\n**常用方法**\n\n| 返回值 | 方法                              | 描述                                                         |\n| ------ | --------------------------------- | ------------------------------------------------------------ |\n| long   | getFilePointer()                  | 获取文件指针当前位置                                         |\n| void   | set(long pos)                     | 设置文件指针的偏移量                                         |\n| long   | length()                          | 返回文件长度                                                 |\n| int    | read()                            | 读取一个字节                                                 |\n| int    | read(byte[] b)                    | 从该文件读取最多 `b.length`字节的数据到字节数组。            |\n| int    | read(byte[] b, int off, int len)  | 从该文件读取最多 `len`个字节的数据到字节数组。               |\n| String | readLine()                        | 读取下一行文本。                                             |\n| String | readUTF()                         | 从该文件读取字符串。                                         |\n| void   | write(byte[] b)                   | 从指定的字节数组写入 `b.length`个字节到该文件，从当前文件指针开始。 |\n| void   | write(byte[] b, int off, int len) | 从指定的字节数组写入 `len`个字节，从偏移量 `off`开始写入此文件。 |\n| void   | write(int b)                      | 将指定的字节写入此文件。                                     |\n| void   | writeUTF(String str)              | 以机器无关的方式使用 UTF-8 编码将字符串写入文件。            |\n| int    | skipBytes(int n)                  | 尝试跳过 `n `字节的输入，丢弃跳过的字节。                    |\n\n## RandomAccessFile实现断点续传\n\n //todo\n\n# 2. IO模型（Unix）\n\n## 2.1 简述\n\n一个输入操作通常包括两个阶段:\n\n1. 等待数据准备好（数据已经通过读取磁盘或者通过网络模块获取到内核缓冲区中）\n\n2. 从内核缓冲区向进程缓冲区复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\n### 阻塞式IO\n\n**在获取数据时应用进程被阻塞，直到数据到达进程缓冲区**\n\n应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。\n\n```c\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\n```\n\n![java-io-model-0](./java_IO/java-io-model-0.png)\n\n### 非阻塞式IO\n\n应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。\n\n由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。\n\n![java-io-model-1](./java_IO/java-io-model-1.png)\n\n### IO复用\n\n使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。\n\n它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。\n\n如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。\n\n![java-io-model-2](./java_IO/java-io-model-2.png)\n\n### 信号驱动IO\n\n应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n\n相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。\n\n![java-io-model-3](./java_IO/java-io-model-3.png)\n\n### 异步IO\n\n进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n\n异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。\n\n![java-io-model-4](./java_IO/java-io-model-4.png)\n\n## 2.2 区别\n\n前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的: 将数据从内核复制到应用进程过程中，应用进程会被阻塞。\n\n![1492928105791_3](./java_IO/1492928105791_3.png)\n\n## 2.3 IO多路复用\n\n### 工作模式\n\n1. **LT模式**（边缘触发）：\n\n   当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。\n\n2. **ET模式**（水平触发）：\n\n   和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。\n\n   很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n3. **select 应用场景**\n\n   select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持。\n\n   **只支持LT**\n\n   **缺点**：使用数组存文件描述符，fd_set会在用户空间和内核空间之间来回复制，监控的文件描述符数量有限\n\n4. **poll 应用场景**\n\n   poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。\n\n   **只支持LT**\n\n   **缺点**：使用链表存文件描述符，获得文件描述符信息还是要O(n)时间复杂度遍历链表\n\n5. **epoll 应用场景**\n\n   只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。\n\n   **支持LT和ET**\n\n   使用红黑树存文件描述符，将就绪文件描述符添加到队列中。\n\n# 3. IO模型（java）\n\n**同步与非同步：**这两个概念是`操作系统级别`的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。\n\n**阻塞与非阻塞：**这两个概念是`程序级别`的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)\n\n## 3.1 BIO\n\n传统从服务端获取连接`accept()`方法以及从从流中获取数据的`read()`都是阻塞的，这些方法的调用会导致该线程一直处于等待状态\n\n## 3.2 NIO\n\n#### 流和块\n\nI/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。\n\n面向流的 I/O 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。\n\n面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。\n\n#### 通道与缓冲区\n\n1. Channel（通道）\n\n   通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。但是通道是双向的，不同于只能单向传输数据的InputStream或OutputStream\n\n   **常用类**：\n\n   - FileChannel: 从文件中读写数据；\n\n   - DatagramChannel: 通过 UDP 读写网络中数据；\n\n   - SocketChannel: 通过 TCP 读写网络中数据；\n\n   - ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。\n\n2. Buffer（缓冲区）\n\n   使用通道交换数据时，会先经过缓冲区\n\n   **常见类型**：\n\n   + ByteBuffer\n   + CharBuffer\n   + ShortBuffer\n   + IntBuffer\n   + LongBuffer\n   + FloatBuffer\n   + DoubleBuffer\n\n#### Buffer详细分析 \n\n```java\n//Buffer中定义的四个成员变量\npublic abstract class Buffer {\n    // Invariants: mark <= position <= limit <= capacity\n    private int mark = -1;\n    private int position = 0;\n    private int limit;\n    private int capacity;\n}\n```\n\n1. **容量（`capacity`）**：`Buffer`可以存储的最大数据量，`Buffer`创建时设置且不可改变；\n2. **界限（`limit`）**：`Buffer` 中可以读/写数据的边界。写模式下，`limit` 代表最多能写入的数据，一般等于 `capacity`（可以通过`limit(int newLimit)`方法设置）；读模式下，`limit` 等于 Buffer 中实际写入的数据大小。\n3. **位置（`position`）**：下一个可以被读写的数据的位置（索引）。从写操作模式到读操作模式切换的时候（flip），`position` 都会归零，这样就可以从头开始读写了。\n4. **标记（`mark`）**：`Buffer`允许将位置直接定位到该标记处，这是一个可选属性；\n\n **两种模式**：\n\nBuffer有写和读两种模式。Buffer创建出来默认是写模式，调用 `flip()` 可以切换到读模式。如果要再次切换回写模式，可以调用 `clear()` 或者 `compact()` 方法。\n\n\n\n**读写模式下三个成员变量之间的关系：**\n\n<img src=\"./java_IO/JavaNIOBuffer.png\" alt=\"JavaNIOBuffer\" style=\"zoom:100%;\" />\n\n\n\n**创建方式**：\n\n不能直接通过`new`调用构造方法创建对象，只能通过静态方法实例化`Buffer`\n\n```java\n//以ByteBuffer为例，其他缓冲区都差不多\n// 分配堆内存\npublic static ByteBuffer allocate(int capacity);\n// 分配直接内存\npublic static ByteBuffer allocateDirect(int capacity);\n```\n\n**常用方法**：\n\n| 返回值    | 方法    | 描述                                                         |\n| --------- | ------- | ------------------------------------------------------------ |\n| xxx       | get()   | 读取缓冲区的数据                                             |\n| xxxBuffer | put()   | 向缓冲区写入数据                                             |\n| Buffer    | flip()  | 将缓冲区从写模式切换到读模式，它会将 `limit` 的值设置为当前 `position` 的值，将 `position` 的值设置为 0。 |\n| Buffer    | clear() | 清空缓冲区，将缓冲区从读模式切换到写模式，并将 `position` 的值设置为 0，将 `limit` 的值设置为 `capacity` 的值。 |\n\n#### 选择器\n\nSelector（选择器） 是 NIO 中的一个关键组件，它允许一个线程处理多个 Channel。Selector 是基于事件驱动的 I/O 多路复用模型，主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行响应的 I/O 操作。\n\n**Selector可以监听的四种数据类型**：\n\n```java\npublic static final int OP_READ = 1 << 0;    //表示通道准备好进行读取的事件，即有数据可读。\npublic static final int OP_WRITE = 1 << 2;   //表示通道准备好进行写入的事件，即可以写入数据。\npublic static final int OP_CONNECT = 1 << 3; //表示通道完成连接的事件，这通常用于 SocketChannel。\npublic static final int OP_ACCEPT = 1 << 4;  //表示通道接受连接的事件，这通常用于 ServerSocketChannel。\n```\n\n可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如:\n\n```java\nint interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n```\n\n一个Selector的三个Selection：\n\n1. 所有的 `SelectionKey` 集合：代表了注册在该 Selector 上的 `Channel`，这个集合可以通过 `keys()` 方法返回。\n\n2. 被选择的 `SelectionKey` 集合：代表了所有可通过 `select()` 方法获取的、需要进行 `IO` 处理的 Channel，这个集合可以通过 `selectedKeys()` 返回。\n\n3. 被取消的 `SelectionKey` 集合：代表了所有被取消注册关系的 `Channel`，在下一次执行 `select()` 方法时，这些 `Channel` 对应的 `SelectionKey` 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。\n\n```java\n//遍历选择的Channel\nSet<SelectionKey> selectedKeys = selector.selectedKeys();\nIterator<SelectionKey> keyIterator = selectedKeys.iterator();\nwhile (keyIterator.hasNext()) {\n    SelectionKey key = keyIterator.next();\n    if (key != null) {\n        if (key.isAcceptable()) {\n            // ServerSocketChannel 接收了一个新连接\n        } else if (key.isConnectable()) {\n            // 表示一个新连接建立\n        } else if (key.isReadable()) {\n            // Channel 有准备好的数据，可以读取\n        } else if (key.isWritable()) {\n            // Channel 有空闲的 Buffer，可以写入数据\n        }\n    }\n    keyIterator.remove();\n}\n```\n\n**`select()`相关方法**\n\n1. `int select()`：监控所有注册的 `Channel`，当它们中间有需要处理的 `IO` 操作时，该方法返回，并将对应的 `SelectionKey` 加入被选择的 `SelectionKey` 集合中，该方法返回这些 `Channel` 的数量。\n\n2. `int select(long timeout)`：可以设置超时时长的 `select()` 操作。\n\n3. `int selectNow()`：执行一个立即返回的 `select()` 操作，相对于无参数的 `select()` 方法而言，该方法不会阻塞线程。\n\n4. `Selector wakeup()`：使一个还未返回的 `select()` 方法立刻返回。\n\n```java\n//NIO实例\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NioSelectorExample {\n\n  public static void main(String[] args) {\n    try {\n      ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n      serverSocketChannel.configureBlocking(false);\n      serverSocketChannel.socket().bind(new InetSocketAddress(8080));\n\n      Selector selector = Selector.open();\n      // 将 ServerSocketChannel 注册到 Selector 并监听 OP_ACCEPT 事件\n      serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n      while (true) {\n        int readyChannels = selector.select();\n\n        if (readyChannels == 0) {\n          continue;\n        }\n\n        Set<SelectionKey> selectedKeys = selector.selectedKeys();\n        Iterator<SelectionKey> keyIterator = selectedKeys.iterator();\n\n        while (keyIterator.hasNext()) {\n          SelectionKey key = keyIterator.next();\n\n          if (key.isAcceptable()) {\n            // 处理连接事件\n            ServerSocketChannel server = (ServerSocketChannel) key.channel();\n            SocketChannel client = server.accept();\n            client.configureBlocking(false);\n\n            // 将客户端通道注册到 Selector 并监听 OP_READ 事件\n            client.register(selector, SelectionKey.OP_READ);\n          } else if (key.isReadable()) {\n            // 处理读事件\n            SocketChannel client = (SocketChannel) key.channel();\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            int bytesRead = client.read(buffer);\n\n            if (bytesRead > 0) {\n              buffer.flip();\n              System.out.println(\"收到数据：\" +new String(buffer.array(), 0, bytesRead));\n              // 将客户端通道注册到 Selector 并监听 OP_WRITE 事件\n              client.register(selector, SelectionKey.OP_WRITE);\n            } else if (bytesRead < 0) {\n              // 客户端断开连接\n              client.close();\n            }\n          } else if (key.isWritable()) {\n            // 处理写事件\n            SocketChannel client = (SocketChannel) key.channel();\n            ByteBuffer buffer = ByteBuffer.wrap(\"Hello, Client!\".getBytes());\n            client.write(buffer);\n            // 将客户端通道注册到 Selector 并监听 OP_READ 事件\n            client.register(selector, SelectionKey.OP_READ);\n          }\n\n          keyIterator.remove();\n        }\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n## 3.3 零拷贝\n\n零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。也就是说，零拷贝主主要解决操作系统在处理 I/O 操作时频繁复制数据的问题。\n\nJava 对零拷贝的支持：\n\n+ `MappedByteBuffer` 是 NIO 基于内存映射（`mmap`）这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 `mmap` 系统调用。它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以直接操作内存中的数据，而不需要通过系统调用来读写文件。\n+ `FileChannel` 的`transferTo()/transferFrom()`是 NIO 基于发送文件（`sendfile`）这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 `sendfile`系统调用。它可以直接将文件数据从内核发送到网络，而不需要经过用户空间的缓冲区。\n\n```java\nprivate void loadFileIntoMemory(File xmlFile) throws IOException {\n  FileInputStream fis = new FileInputStream(xmlFile);\n  // 创建 FileChannel 对象\n  FileChannel fc = fis.getChannel();\n  // FileChannel.map() 将文件映射到直接内存并返回 MappedByteBuffer 对象\n  MappedByteBuffer mmb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());\n  xmlFileBuffer = new byte[(int)fc.size()];\n  mmb.get(xmlFileBuffer);\n  fis.close();\n}\n```\n\n向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。\n\n## 3.4 AIO\n\n异步IO，Linux没有这种机制的支持，只能模拟AIO，使用效率提升不大。\n\n## 3.5 Reactor模型\n\n我们可以粗略的将网络IO过程分为以下几个部分\n\n1. 连接的建立\n2. 数据的接受\n3. 数据的处理（数据的编解码以及业务计算）\n4. 数据的发送\n\n### 传统IO模型\n\n<img src=\"./java_IO/java-io-reactor-1.png\" alt=\"java-io-reactor-1\" style=\"zoom:80%;\" />\n\n一个线程处理一个客户端请求的全过程。由于一次请求的部分过程是不需要消耗CPU资源的（时间占比可能还挺大），所以一个线程处理一个请求的方式效率不高。\n\n### 事件驱动模型\n\n<img src=\"./java_IO/java-io-reactor-4.png\" alt=\"java-io-reactor-4\" style=\"zoom:80%;\" />\n\nReactor部分分为mainReactor与subReactor\n\n1. **mainReactor**\n\n   mainReactor主要进行客户端连接的处理，处理完成之后将该连接交由subReactor以处理客户端的网络读写。\n\n2. **subReactor**\n\n   subReactor使用一个线程池作为支撑，用多线程来处理网络读写和数据处理\n\n","source":"_posts/java_IO.md","raw":"---\ntitle: IO\ndate: 2024-09-10 16:18:00\ntags: \n    - java_IO\ncategories:\n    - 后端开发\n---\n\n本文主要关注于java中的IO\n\n<!--more-->\n\n# 1. 基础\n\n![java-io-overview2](./java_IO/java-io-overview2.png)\n\n## 1.1 分类\n\n1. 按数据的流向不同分为：**输入流和输出流**\n\n2. 按操作数据单位的不同分为：**字节流（8bit）和字符流（16bit）**\n\n   编码是将字符流转化为字节流，解码是将字节流转化为字节流，编码解码规则不一样会导致乱码\n\n   字节是给计算机看的，字符是给人看的。一个字符的大小和编码方式和字符类型有关。\n\n   java使用UTF-16be 编码，中文字符和英文字符都占 2 个字节，这样一个中文或者英文字符都可以通过一个单位char类型存放。\n\n3. 根据IO流的角色不同分为：**节点流和处理流**\n\n   - 节点流：直接从数据源或目的地读写数据\n   - 处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）上\n\n## 1.2 文件\n\n文件在java中对应的对象为`File`，文件在程序中是以流的形式来操作的\n\n<img src=\"./java_IO/image-20240225220137926.png\" alt=\"image-20240225220137926\" style=\"zoom:60%;\" />\n\n```java\n//常用构造方法\n    //父目录以及子目录\n\tpublic File(String parent, String child) {}\n\t//父文件下所在目录的子目录\n    private File(String child, File parent) {}\n   //正常的路径\n    public File(String pathname) {}\n```\n\n所有 `java.io` 中的类的**相对路径**默认都是从**用户工作目录**开始的，使用 `System.getProperty(\"user.dir\")` 可以获取你的用户工作目录。\n\n在 Windows 系统中的分隔符为 \"`\\\\`\"，在 Linux 系统中分隔符为 \"`/`\"，为了保证系统的可移植性，可以通过常量字符串 `java.io.File.separator` 获取。\n\n```java\n/**\n     * @param filename 文件名\n     * @param path 文件所在路径\n     *\n     */\n    public static void createNewFile(String filename,String path){\n        if(filename.isEmpty())\n            return ;\n        String pa = path+ File.separator+filename;\n        //可以使用其他方式创建File对象\n        File file = new File(pa);\n        try{\n            file.createNewFile();\n        }catch (IOException e){\n            e.printStackTrace();\n        }\n    }\n```\n\n\n\n| 返回值  | 方法名            | 描述             |\n| ------- | ----------------- | ---------------- |\n| String  | getName()         | 获取文件名       |\n| String  | getAbsolutePath() | 获取文件绝对路径 |\n| String  | getParent()       | 获取文件父级目录 |\n| long    | length()          | 返回文件字节大小 |\n| boolean | exists()          | 判断文件是否存在 |\n| boolean | isFile()          | 判断是否是文件   |\n| boolean | isDirectory()     | 判断是否是目录   |\n\n| 返回值  | 方法名   | 描述           |\n| ------- | -------- | -------------- |\n| boolean | mkdir()  | 创建一级目录   |\n| boolean | mkdirs() | 创建多级目录   |\n| boolean | delete() | 删除文件或目录 |\n\n```java\n public void tableOfContent(){\n        String parentPath = System.getProperty(\"user.dir\");\n        String fileName = \"testFile.txt\";\n        String directoryName = \"a\";\n        String mulDirectoryName = \"b/c/d\";\n        // 删除文件\n        File file = new File(parentPath, fileName);\n        file.delete();\n        // 创建一级目录\n        File directory = new File(parentPath, directoryName);\n        directory.mkdir();\n        // 创建多级目录\n        File mulDirectory = new File(parentPath, mulDirectoryName);\n        mulDirectory.mkdirs();\n        // 删除目录\n        directory.delete();\n    }\n```\n\n## 1.3 输入输出流\n\n**try-with-resources**\n\n这个语法糖的出现主要是为了减少关闭创建资源的工作\n\n详见https://zhuanlan.zhihu.com/p/27824934\n\n### 1.3.1 字节流\n\n<img src=\"./java_IO/image-20240226191911489.png\" alt=\"image-20240226191911489\" style=\"zoom:80%;\" />\n\n#### InputStream系\n\n\n\n| 返回值 | 方法                                   | 描述                                                         |\n| ------ | -------------------------------------- | ------------------------------------------------------------ |\n| int    | read()                                 | 返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 `-1` ，表示文件结束。 |\n| int    | read(byte b[ ])                        | 从输入流中读取一些字节存储到数组 `b` 中。如果数组 `b` 的长度为零，则不读取。如果没有可用字节读取，返回 `-1`。如果有可用字节读取，则最多读取的字节数最多等于 `b.length` ，返回读取的字节数。 |\n| int    | read(byte b[], int off, int len)       | 在`read(byte b[ ])` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字节数）。 |\n| long   | skip(long n)                           | 忽略输入流中的 `n` 个字节 ，返回实际忽略的字节数。           |\n| int    | available()                            | 返回输入流中可以读取的字节数。                               |\n| void   | close()                                | 关闭输入流释放相关的系统资源。                               |\n| byte[] | readAllBytes()                         | 读取输入流中的所有字节，返回字节数组。                       |\n| byte[] | readNBytes(byte[] b, int off, int len) | 阻塞直到读取 `len` 个字节。                                  |\n| long   | transferTo(OutputStream out)           | 将所有字节从一个输入流传递到一个输出流。                     |\n\n1. **FileInputStream**\n\n   <img src=\"./java_IO/image-20240226193441574.png\" alt=\"image-20240226193441574\" style=\"zoom:67%;\" />\n\n   可以把File类实例作为参数传入构造函数，以类似以下读取数据\n\n   ```java\n    FileInputStream in = new FileInputStream(new File(\"文件路径\"));\n    byte[] buf = new byte[8]; \n    int readLen;\n           // 返回值为 -1 时，表示读取完毕\n           while ((readLen = in.read(buf)) != -1) {\n               System.out.print(new String(buf, 0, readLen)); \n   ```\n\n2. **FilterInputStream**\n\n   该类是标准的装饰器模式的示例，FilterInputStream作为装饰器的根抽象类，可以接收InputStream对象实例作为参数以增强原有功能。\n\n   - **BufferedInputStream**\n\n     内置了缓冲，可以提升效率（尽量使用该类）\n\n     ```java\n     //再套一层就行了\n     BufferedInputStream in = new BufferedInputStream(new FileInputStream(new File(\"文件路径\")));\n             byte[] buf = new byte[8];\n             int readLen;\n             // 返回值为 -1 时，表示读取完毕\n             while ((readLen = in.read(buf)) != -1) {\n                 System.out.print(new String(buf, 0, readLen));\n             }\n     ```\n\n   - **DataInputStream**\n\n     用于读取指定类型的数据\n\n     ```java\n     @Test\n     public void testDataInputStream() throws IOException {\n         // 必须将一个 InputStream 的实现类作为构造参数才能使用\n         try(DataInputStream dis = new DataInputStream(new FileInputStream(\"mrpersimmon2.txt\"))) {\n             // 可以读取任意具体的类型数据\n             System.out.println(dis.readUTF()); // 读取已使用 modified UTF-8 格式编码的字符串。\n         } catch (IOException e) {\n             e.printStackTrace();\n         }\n     }\n     ```\n\n3. **ObjectInputStream**\n\n   该类是序列化相关的类（反序列化），也就是可以从流中读取对象\n\n\n#### OutputStream系\n\n| 返回值 | 方法名                            | 描述                                                         |\n| ------ | --------------------------------- | ------------------------------------------------------------ |\n| void   | write(int b)                      | 将特定字节写入输出流。                                       |\n| void   | write(byte[] b)                   | 将数组 `b` 写入到输出流，等价于 `write(b, 0, b.length)` 。   |\n| void   | write(byte[] b, int off, int len) | 在 `write(byte b[])` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字节数）。 |\n| void   | flush()                           | 刷新此输出流并强制写出所有缓冲的输出字节。                   |\n| void   | close()                           | 关闭输出流释放相关的系统资源。                               |\n\nOutputStream 下的子类`FileOutputStream` ，`DataOutputStream`，`ObjectOutputStream`与`InputStream`中的类似\n\n##### PrintStream\n\n经常使用的 `System.out` 就是用于获取一个 `PrintStream` 对象，`System.out.print` 方法实际调用的是 `PrintStream` 对象的 `write` 方法。默认情况下，`PrintStream` 输出数据的位置是标准输出，即显示器。\n\nprint(x)会先调用String.valueOf(x)将内容转换成字符串，在调用内部的write()方法。\n\n### 1.3.2 字符流\n\n#### Writer系\n\n| 返回值 | 方法名                               | 描述                                                         |\n| ------ | ------------------------------------ | ------------------------------------------------------------ |\n| void   | write(int c)                         | 写入单个字符。                                               |\n| void   | write(char[] cbuf)                   | 写入字符数组 `cbuf`，等价于`write(cbuf, 0, cbuf.length)`。   |\n| void   | write(char[] cbuf, int off, int len) | 在`write(char[] cbuf)` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字符数）。 |\n| void   | write(String str)                    | 写入字符串，等价于 `write(str, 0, str.length())` 。          |\n| void   | write(String str, int off, int len)  | 在`write(String str)` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字符数）。 |\n| Writer | append(CharSenquence csq)            | 将指定的字符序列附加到指定的 `Writer` 对象并返回该 `Writer` 对象。 |\n| Writer | append(char c)                       | 将指定的字符附加到指定的 `Writer` 对象并返回该 `Writer` 对象. |\n| void   | flush()                              | 刷新此输出流并强制写出所有缓冲的输出字符。                   |\n| void   | close()                              | 关闭输出流释放相关的系统资源。                               |\n\n \n\n#### Reader系\n\n| 返回值 | 方法名                              | 描述                                                         |\n| ------ | ----------------------------------- | ------------------------------------------------------------ |\n| int    | read()                              | 从输入流读取一个字符。                                       |\n| int    | read(char[] cbuf)                   | 从输入流中读取一些字符，并将它们存储到字符数组 `cbuf`中，等价于 `read(cbuf, 0, cbuf.length)` 。 |\n| int    | read(char[] cbuf, int off, int len) | 在`read(char[] cbuf)` 方法的基础上增加了 `off` 参数（偏移量）和 `len` 参数（要读取的最大字符数）。 |\n| long   | skip(long n)                        | 忽略输入流中的 n 个字符，返回实际忽略的字符数。              |\n| void   | close()                             | 关闭输入流并释放相关的系统资源。                             |\n\n### 1.3.3 OutputStreamWriter与InputStreamReader\n\n这两个类是FileWriter/Reader的父类，主要作用是进行字符与字节之间的转化\n\n## 1.4 综合\n\n计算机只认字节，所以使用字节流效率要大于字符流（字符流也是通过字符与字节之间转化来实现流与文件交互的）.\n\nIO操作很耗时，所以一次尽量操作较多数据。\n\n## RandomAccessFile类\n\n**支持随意跳转到文件任意位置读写**\n\n```java\n// String name: 指定名称的文件\npublic RandomAccessFile(String name, String mode) throws FileNotFoundException{\n    this(name != null ? new File(name) : null, mode);\n}\n// String file: 指定文件\npublic RandomAccessFile(File file, String mode) throws FileNotFoundException{...}\n```\n\n| mode | 描述                                                         |\n| ---- | ------------------------------------------------------------ |\n| r    | 只读                                                         |\n| rw   | 读写                                                         |\n| rwd  | 相较于 `rw`，还要求对「文件内容」的每次更新都同步写入底层存储设备。 |\n| rws  | 相较于 `rw`，还需要将对「文件内容」或「元数据」的每次更新同步写入底层存储设备； |\n\n**常用方法**\n\n| 返回值 | 方法                              | 描述                                                         |\n| ------ | --------------------------------- | ------------------------------------------------------------ |\n| long   | getFilePointer()                  | 获取文件指针当前位置                                         |\n| void   | set(long pos)                     | 设置文件指针的偏移量                                         |\n| long   | length()                          | 返回文件长度                                                 |\n| int    | read()                            | 读取一个字节                                                 |\n| int    | read(byte[] b)                    | 从该文件读取最多 `b.length`字节的数据到字节数组。            |\n| int    | read(byte[] b, int off, int len)  | 从该文件读取最多 `len`个字节的数据到字节数组。               |\n| String | readLine()                        | 读取下一行文本。                                             |\n| String | readUTF()                         | 从该文件读取字符串。                                         |\n| void   | write(byte[] b)                   | 从指定的字节数组写入 `b.length`个字节到该文件，从当前文件指针开始。 |\n| void   | write(byte[] b, int off, int len) | 从指定的字节数组写入 `len`个字节，从偏移量 `off`开始写入此文件。 |\n| void   | write(int b)                      | 将指定的字节写入此文件。                                     |\n| void   | writeUTF(String str)              | 以机器无关的方式使用 UTF-8 编码将字符串写入文件。            |\n| int    | skipBytes(int n)                  | 尝试跳过 `n `字节的输入，丢弃跳过的字节。                    |\n\n## RandomAccessFile实现断点续传\n\n //todo\n\n# 2. IO模型（Unix）\n\n## 2.1 简述\n\n一个输入操作通常包括两个阶段:\n\n1. 等待数据准备好（数据已经通过读取磁盘或者通过网络模块获取到内核缓冲区中）\n\n2. 从内核缓冲区向进程缓冲区复制数据\n\n对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\n\n### 阻塞式IO\n\n**在获取数据时应用进程被阻塞，直到数据到达进程缓冲区**\n\n应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。\n\n```c\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);\n```\n\n![java-io-model-0](./java_IO/java-io-model-0.png)\n\n### 非阻塞式IO\n\n应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询(polling)。\n\n由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。\n\n![java-io-model-1](./java_IO/java-io-model-1.png)\n\n### IO复用\n\n使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。\n\n它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。\n\n如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。\n\n![java-io-model-2](./java_IO/java-io-model-2.png)\n\n### 信号驱动IO\n\n应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n\n相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。\n\n![java-io-model-3](./java_IO/java-io-model-3.png)\n\n### 异步IO\n\n进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n\n异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。\n\n![java-io-model-4](./java_IO/java-io-model-4.png)\n\n## 2.2 区别\n\n前四种 I/O 模型的主要区别在于第一个阶段，而第二个阶段是一样的: 将数据从内核复制到应用进程过程中，应用进程会被阻塞。\n\n![1492928105791_3](./java_IO/1492928105791_3.png)\n\n## 2.3 IO多路复用\n\n### 工作模式\n\n1. **LT模式**（边缘触发）：\n\n   当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。\n\n2. **ET模式**（水平触发）：\n\n   和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。\n\n   很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n\n3. **select 应用场景**\n\n   select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持。\n\n   **只支持LT**\n\n   **缺点**：使用数组存文件描述符，fd_set会在用户空间和内核空间之间来回复制，监控的文件描述符数量有限\n\n4. **poll 应用场景**\n\n   poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。\n\n   **只支持LT**\n\n   **缺点**：使用链表存文件描述符，获得文件描述符信息还是要O(n)时间复杂度遍历链表\n\n5. **epoll 应用场景**\n\n   只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。\n\n   **支持LT和ET**\n\n   使用红黑树存文件描述符，将就绪文件描述符添加到队列中。\n\n# 3. IO模型（java）\n\n**同步与非同步：**这两个概念是`操作系统级别`的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。\n\n**阻塞与非阻塞：**这两个概念是`程序级别`的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)\n\n## 3.1 BIO\n\n传统从服务端获取连接`accept()`方法以及从从流中获取数据的`read()`都是阻塞的，这些方法的调用会导致该线程一直处于等待状态\n\n## 3.2 NIO\n\n#### 流和块\n\nI/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。\n\n面向流的 I/O 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。\n\n面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。\n\n#### 通道与缓冲区\n\n1. Channel（通道）\n\n   通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。但是通道是双向的，不同于只能单向传输数据的InputStream或OutputStream\n\n   **常用类**：\n\n   - FileChannel: 从文件中读写数据；\n\n   - DatagramChannel: 通过 UDP 读写网络中数据；\n\n   - SocketChannel: 通过 TCP 读写网络中数据；\n\n   - ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。\n\n2. Buffer（缓冲区）\n\n   使用通道交换数据时，会先经过缓冲区\n\n   **常见类型**：\n\n   + ByteBuffer\n   + CharBuffer\n   + ShortBuffer\n   + IntBuffer\n   + LongBuffer\n   + FloatBuffer\n   + DoubleBuffer\n\n#### Buffer详细分析 \n\n```java\n//Buffer中定义的四个成员变量\npublic abstract class Buffer {\n    // Invariants: mark <= position <= limit <= capacity\n    private int mark = -1;\n    private int position = 0;\n    private int limit;\n    private int capacity;\n}\n```\n\n1. **容量（`capacity`）**：`Buffer`可以存储的最大数据量，`Buffer`创建时设置且不可改变；\n2. **界限（`limit`）**：`Buffer` 中可以读/写数据的边界。写模式下，`limit` 代表最多能写入的数据，一般等于 `capacity`（可以通过`limit(int newLimit)`方法设置）；读模式下，`limit` 等于 Buffer 中实际写入的数据大小。\n3. **位置（`position`）**：下一个可以被读写的数据的位置（索引）。从写操作模式到读操作模式切换的时候（flip），`position` 都会归零，这样就可以从头开始读写了。\n4. **标记（`mark`）**：`Buffer`允许将位置直接定位到该标记处，这是一个可选属性；\n\n **两种模式**：\n\nBuffer有写和读两种模式。Buffer创建出来默认是写模式，调用 `flip()` 可以切换到读模式。如果要再次切换回写模式，可以调用 `clear()` 或者 `compact()` 方法。\n\n\n\n**读写模式下三个成员变量之间的关系：**\n\n<img src=\"./java_IO/JavaNIOBuffer.png\" alt=\"JavaNIOBuffer\" style=\"zoom:100%;\" />\n\n\n\n**创建方式**：\n\n不能直接通过`new`调用构造方法创建对象，只能通过静态方法实例化`Buffer`\n\n```java\n//以ByteBuffer为例，其他缓冲区都差不多\n// 分配堆内存\npublic static ByteBuffer allocate(int capacity);\n// 分配直接内存\npublic static ByteBuffer allocateDirect(int capacity);\n```\n\n**常用方法**：\n\n| 返回值    | 方法    | 描述                                                         |\n| --------- | ------- | ------------------------------------------------------------ |\n| xxx       | get()   | 读取缓冲区的数据                                             |\n| xxxBuffer | put()   | 向缓冲区写入数据                                             |\n| Buffer    | flip()  | 将缓冲区从写模式切换到读模式，它会将 `limit` 的值设置为当前 `position` 的值，将 `position` 的值设置为 0。 |\n| Buffer    | clear() | 清空缓冲区，将缓冲区从读模式切换到写模式，并将 `position` 的值设置为 0，将 `limit` 的值设置为 `capacity` 的值。 |\n\n#### 选择器\n\nSelector（选择器） 是 NIO 中的一个关键组件，它允许一个线程处理多个 Channel。Selector 是基于事件驱动的 I/O 多路复用模型，主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行响应的 I/O 操作。\n\n**Selector可以监听的四种数据类型**：\n\n```java\npublic static final int OP_READ = 1 << 0;    //表示通道准备好进行读取的事件，即有数据可读。\npublic static final int OP_WRITE = 1 << 2;   //表示通道准备好进行写入的事件，即可以写入数据。\npublic static final int OP_CONNECT = 1 << 3; //表示通道完成连接的事件，这通常用于 SocketChannel。\npublic static final int OP_ACCEPT = 1 << 4;  //表示通道接受连接的事件，这通常用于 ServerSocketChannel。\n```\n\n可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如:\n\n```java\nint interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n```\n\n一个Selector的三个Selection：\n\n1. 所有的 `SelectionKey` 集合：代表了注册在该 Selector 上的 `Channel`，这个集合可以通过 `keys()` 方法返回。\n\n2. 被选择的 `SelectionKey` 集合：代表了所有可通过 `select()` 方法获取的、需要进行 `IO` 处理的 Channel，这个集合可以通过 `selectedKeys()` 返回。\n\n3. 被取消的 `SelectionKey` 集合：代表了所有被取消注册关系的 `Channel`，在下一次执行 `select()` 方法时，这些 `Channel` 对应的 `SelectionKey` 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。\n\n```java\n//遍历选择的Channel\nSet<SelectionKey> selectedKeys = selector.selectedKeys();\nIterator<SelectionKey> keyIterator = selectedKeys.iterator();\nwhile (keyIterator.hasNext()) {\n    SelectionKey key = keyIterator.next();\n    if (key != null) {\n        if (key.isAcceptable()) {\n            // ServerSocketChannel 接收了一个新连接\n        } else if (key.isConnectable()) {\n            // 表示一个新连接建立\n        } else if (key.isReadable()) {\n            // Channel 有准备好的数据，可以读取\n        } else if (key.isWritable()) {\n            // Channel 有空闲的 Buffer，可以写入数据\n        }\n    }\n    keyIterator.remove();\n}\n```\n\n**`select()`相关方法**\n\n1. `int select()`：监控所有注册的 `Channel`，当它们中间有需要处理的 `IO` 操作时，该方法返回，并将对应的 `SelectionKey` 加入被选择的 `SelectionKey` 集合中，该方法返回这些 `Channel` 的数量。\n\n2. `int select(long timeout)`：可以设置超时时长的 `select()` 操作。\n\n3. `int selectNow()`：执行一个立即返回的 `select()` 操作，相对于无参数的 `select()` 方法而言，该方法不会阻塞线程。\n\n4. `Selector wakeup()`：使一个还未返回的 `select()` 方法立刻返回。\n\n```java\n//NIO实例\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class NioSelectorExample {\n\n  public static void main(String[] args) {\n    try {\n      ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n      serverSocketChannel.configureBlocking(false);\n      serverSocketChannel.socket().bind(new InetSocketAddress(8080));\n\n      Selector selector = Selector.open();\n      // 将 ServerSocketChannel 注册到 Selector 并监听 OP_ACCEPT 事件\n      serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n      while (true) {\n        int readyChannels = selector.select();\n\n        if (readyChannels == 0) {\n          continue;\n        }\n\n        Set<SelectionKey> selectedKeys = selector.selectedKeys();\n        Iterator<SelectionKey> keyIterator = selectedKeys.iterator();\n\n        while (keyIterator.hasNext()) {\n          SelectionKey key = keyIterator.next();\n\n          if (key.isAcceptable()) {\n            // 处理连接事件\n            ServerSocketChannel server = (ServerSocketChannel) key.channel();\n            SocketChannel client = server.accept();\n            client.configureBlocking(false);\n\n            // 将客户端通道注册到 Selector 并监听 OP_READ 事件\n            client.register(selector, SelectionKey.OP_READ);\n          } else if (key.isReadable()) {\n            // 处理读事件\n            SocketChannel client = (SocketChannel) key.channel();\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            int bytesRead = client.read(buffer);\n\n            if (bytesRead > 0) {\n              buffer.flip();\n              System.out.println(\"收到数据：\" +new String(buffer.array(), 0, bytesRead));\n              // 将客户端通道注册到 Selector 并监听 OP_WRITE 事件\n              client.register(selector, SelectionKey.OP_WRITE);\n            } else if (bytesRead < 0) {\n              // 客户端断开连接\n              client.close();\n            }\n          } else if (key.isWritable()) {\n            // 处理写事件\n            SocketChannel client = (SocketChannel) key.channel();\n            ByteBuffer buffer = ByteBuffer.wrap(\"Hello, Client!\".getBytes());\n            client.write(buffer);\n            // 将客户端通道注册到 Selector 并监听 OP_READ 事件\n            client.register(selector, SelectionKey.OP_READ);\n          }\n\n          keyIterator.remove();\n        }\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n```\n\n## 3.3 零拷贝\n\n零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。也就是说，零拷贝主主要解决操作系统在处理 I/O 操作时频繁复制数据的问题。\n\nJava 对零拷贝的支持：\n\n+ `MappedByteBuffer` 是 NIO 基于内存映射（`mmap`）这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 `mmap` 系统调用。它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以直接操作内存中的数据，而不需要通过系统调用来读写文件。\n+ `FileChannel` 的`transferTo()/transferFrom()`是 NIO 基于发送文件（`sendfile`）这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 `sendfile`系统调用。它可以直接将文件数据从内核发送到网络，而不需要经过用户空间的缓冲区。\n\n```java\nprivate void loadFileIntoMemory(File xmlFile) throws IOException {\n  FileInputStream fis = new FileInputStream(xmlFile);\n  // 创建 FileChannel 对象\n  FileChannel fc = fis.getChannel();\n  // FileChannel.map() 将文件映射到直接内存并返回 MappedByteBuffer 对象\n  MappedByteBuffer mmb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());\n  xmlFileBuffer = new byte[(int)fc.size()];\n  mmb.get(xmlFileBuffer);\n  fis.close();\n}\n```\n\n向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。\n\n## 3.4 AIO\n\n异步IO，Linux没有这种机制的支持，只能模拟AIO，使用效率提升不大。\n\n## 3.5 Reactor模型\n\n我们可以粗略的将网络IO过程分为以下几个部分\n\n1. 连接的建立\n2. 数据的接受\n3. 数据的处理（数据的编解码以及业务计算）\n4. 数据的发送\n\n### 传统IO模型\n\n<img src=\"./java_IO/java-io-reactor-1.png\" alt=\"java-io-reactor-1\" style=\"zoom:80%;\" />\n\n一个线程处理一个客户端请求的全过程。由于一次请求的部分过程是不需要消耗CPU资源的（时间占比可能还挺大），所以一个线程处理一个请求的方式效率不高。\n\n### 事件驱动模型\n\n<img src=\"./java_IO/java-io-reactor-4.png\" alt=\"java-io-reactor-4\" style=\"zoom:80%;\" />\n\nReactor部分分为mainReactor与subReactor\n\n1. **mainReactor**\n\n   mainReactor主要进行客户端连接的处理，处理完成之后将该连接交由subReactor以处理客户端的网络读写。\n\n2. **subReactor**\n\n   subReactor使用一个线程池作为支撑，用多线程来处理网络读写和数据处理\n\n","slug":"java_IO","published":1,"updated":"2024-10-27T11:55:21.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6bn000iskusbj7mabew","content":"<p>本文主要关注于java中的IO</p>\n<span id=\"more\"></span>\n\n<h1 id=\"1-基础\"><a href=\"#1-基础\" class=\"headerlink\" title=\"1. 基础\"></a>1. 基础</h1><p><img src=\"/2024/09/10/java_IO/java-io-overview2.png\" alt=\"java-io-overview2\"></p>\n<h2 id=\"1-1-分类\"><a href=\"#1-1-分类\" class=\"headerlink\" title=\"1.1 分类\"></a>1.1 分类</h2><ol>\n<li><p>按数据的流向不同分为：<strong>输入流和输出流</strong></p>\n</li>\n<li><p>按操作数据单位的不同分为：<strong>字节流（8bit）和字符流（16bit）</strong></p>\n<p>编码是将字符流转化为字节流，解码是将字节流转化为字节流，编码解码规则不一样会导致乱码</p>\n<p>字节是给计算机看的，字符是给人看的。一个字符的大小和编码方式和字符类型有关。</p>\n<p>java使用UTF-16be 编码，中文字符和英文字符都占 2 个字节，这样一个中文或者英文字符都可以通过一个单位char类型存放。</p>\n</li>\n<li><p>根据IO流的角色不同分为：<strong>节点流和处理流</strong></p>\n<ul>\n<li>节点流：直接从数据源或目的地读写数据</li>\n<li>处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）上</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-文件\"><a href=\"#1-2-文件\" class=\"headerlink\" title=\"1.2 文件\"></a>1.2 文件</h2><p>文件在java中对应的对象为<code>File</code>，文件在程序中是以流的形式来操作的</p>\n<img src=\"/2024/09/10/java_IO/image-20240225220137926.png\" alt=\"image-20240225220137926\" style=\"zoom:60%;\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//常用构造方法</span></span><br><span class=\"line\">    <span class=\"comment\">//父目录以及子目录</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">File</span><span class=\"params\">(String parent, String child)</span> &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//父文件下所在目录的子目录</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">File</span><span class=\"params\">(String child, File parent)</span> &#123;&#125;</span><br><span class=\"line\">   <span class=\"comment\">//正常的路径</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">File</span><span class=\"params\">(String pathname)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所有 <code>java.io</code> 中的类的<strong>相对路径</strong>默认都是从<strong>用户工作目录</strong>开始的，使用 <code>System.getProperty(&quot;user.dir&quot;)</code> 可以获取你的用户工作目录。</p>\n<p>在 Windows 系统中的分隔符为 “<code>\\\\</code>“，在 Linux 系统中分隔符为 “<code>/</code>“，为了保证系统的可移植性，可以通过常量字符串 <code>java.io.File.separator</code> 获取。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> filename 文件名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> path 文件所在路径</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createNewFile</span><span class=\"params\">(String filename,String path)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(filename.isEmpty())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">pa</span> <span class=\"operator\">=</span> path+ File.separator+filename;</span><br><span class=\"line\">        <span class=\"comment\">//可以使用其他方式创建File对象</span></span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(pa);</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            file.createNewFile();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String</td>\n<td>getName()</td>\n<td>获取文件名</td>\n</tr>\n<tr>\n<td>String</td>\n<td>getAbsolutePath()</td>\n<td>获取文件绝对路径</td>\n</tr>\n<tr>\n<td>String</td>\n<td>getParent()</td>\n<td>获取文件父级目录</td>\n</tr>\n<tr>\n<td>long</td>\n<td>length()</td>\n<td>返回文件字节大小</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>exists()</td>\n<td>判断文件是否存在</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>isFile()</td>\n<td>判断是否是文件</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>isDirectory()</td>\n<td>判断是否是目录</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean</td>\n<td>mkdir()</td>\n<td>创建一级目录</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>mkdirs()</td>\n<td>创建多级目录</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>delete()</td>\n<td>删除文件或目录</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tableOfContent</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">parentPath</span> <span class=\"operator\">=</span> System.getProperty(<span class=\"string\">&quot;user.dir&quot;</span>);</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">fileName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;testFile.txt&quot;</span>;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">directoryName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;a&quot;</span>;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">mulDirectoryName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;b/c/d&quot;</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 删除文件</span></span><br><span class=\"line\">       <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(parentPath, fileName);</span><br><span class=\"line\">       file.delete();</span><br><span class=\"line\">       <span class=\"comment\">// 创建一级目录</span></span><br><span class=\"line\">       <span class=\"type\">File</span> <span class=\"variable\">directory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(parentPath, directoryName);</span><br><span class=\"line\">       directory.mkdir();</span><br><span class=\"line\">       <span class=\"comment\">// 创建多级目录</span></span><br><span class=\"line\">       <span class=\"type\">File</span> <span class=\"variable\">mulDirectory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(parentPath, mulDirectoryName);</span><br><span class=\"line\">       mulDirectory.mkdirs();</span><br><span class=\"line\">       <span class=\"comment\">// 删除目录</span></span><br><span class=\"line\">       directory.delete();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-输入输出流\"><a href=\"#1-3-输入输出流\" class=\"headerlink\" title=\"1.3 输入输出流\"></a>1.3 输入输出流</h2><p><strong>try-with-resources</strong></p>\n<p>这个语法糖的出现主要是为了减少关闭创建资源的工作</p>\n<p>详见<a href=\"https://zhuanlan.zhihu.com/p/27824934\">https://zhuanlan.zhihu.com/p/27824934</a></p>\n<h3 id=\"1-3-1-字节流\"><a href=\"#1-3-1-字节流\" class=\"headerlink\" title=\"1.3.1 字节流\"></a>1.3.1 字节流</h3><img src=\"/2024/09/10/java_IO/image-20240226191911489.png\" alt=\"image-20240226191911489\" style=\"zoom:80%;\">\n\n<h4 id=\"InputStream系\"><a href=\"#InputStream系\" class=\"headerlink\" title=\"InputStream系\"></a>InputStream系</h4><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int</td>\n<td>read()</td>\n<td>返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read(byte b[ ])</td>\n<td>从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ，返回读取的字节数。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read(byte b[], int off, int len)</td>\n<td>在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</td>\n</tr>\n<tr>\n<td>long</td>\n<td>skip(long n)</td>\n<td>忽略输入流中的 <code>n</code> 个字节 ，返回实际忽略的字节数。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>available()</td>\n<td>返回输入流中可以读取的字节数。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>close()</td>\n<td>关闭输入流释放相关的系统资源。</td>\n</tr>\n<tr>\n<td>byte[]</td>\n<td>readAllBytes()</td>\n<td>读取输入流中的所有字节，返回字节数组。</td>\n</tr>\n<tr>\n<td>byte[]</td>\n<td>readNBytes(byte[] b, int off, int len)</td>\n<td>阻塞直到读取 <code>len</code> 个字节。</td>\n</tr>\n<tr>\n<td>long</td>\n<td>transferTo(OutputStream out)</td>\n<td>将所有字节从一个输入流传递到一个输出流。</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p><strong>FileInputStream</strong></p>\n<img src=\"/2024/09/10/java_IO/image-20240226193441574.png\" alt=\"image-20240226193441574\" style=\"zoom:67%;\">\n\n<p>可以把File类实例作为参数传入构造函数，以类似以下读取数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">FileInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;文件路径&quot;</span>));</span><br><span class=\"line\"><span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">8</span>]; </span><br><span class=\"line\"><span class=\"type\">int</span> readLen;</span><br><span class=\"line\">       <span class=\"comment\">// 返回值为 -1 时，表示读取完毕</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> ((readLen = in.read(buf)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">           System.out.print(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buf, <span class=\"number\">0</span>, readLen)); </span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>FilterInputStream</strong></p>\n<p>该类是标准的装饰器模式的示例，FilterInputStream作为装饰器的根抽象类，可以接收InputStream对象实例作为参数以增强原有功能。</p>\n<ul>\n<li><p><strong>BufferedInputStream</strong></p>\n<p>内置了缓冲，可以提升效率（尽量使用该类）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//再套一层就行了</span></span><br><span class=\"line\"><span class=\"type\">BufferedInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;文件路径&quot;</span>)));</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">8</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> readLen;</span><br><span class=\"line\">        <span class=\"comment\">// 返回值为 -1 时，表示读取完毕</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((readLen = in.read(buf)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.print(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buf, <span class=\"number\">0</span>, readLen));</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>DataInputStream</strong></p>\n<p>用于读取指定类型的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testDataInputStream</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 必须将一个 InputStream 的实现类作为构造参数才能使用</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>(<span class=\"type\">DataInputStream</span> <span class=\"variable\">dis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;mrpersimmon2.txt&quot;</span>))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以读取任意具体的类型数据</span></span><br><span class=\"line\">        System.out.println(dis.readUTF()); <span class=\"comment\">// 读取已使用 modified UTF-8 格式编码的字符串。</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>ObjectInputStream</strong></p>\n<p>该类是序列化相关的类（反序列化），也就是可以从流中读取对象</p>\n</li>\n</ol>\n<h4 id=\"OutputStream系\"><a href=\"#OutputStream系\" class=\"headerlink\" title=\"OutputStream系\"></a>OutputStream系</h4><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void</td>\n<td>write(int b)</td>\n<td>将特定字节写入输出流。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(byte[] b)</td>\n<td>将数组 <code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(byte[] b, int off, int len)</td>\n<td>在 <code>write(byte b[])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>flush()</td>\n<td>刷新此输出流并强制写出所有缓冲的输出字节。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>close()</td>\n<td>关闭输出流释放相关的系统资源。</td>\n</tr>\n</tbody></table>\n<p>OutputStream 下的子类<code>FileOutputStream</code> ，<code>DataOutputStream</code>，<code>ObjectOutputStream</code>与<code>InputStream</code>中的类似</p>\n<h5 id=\"PrintStream\"><a href=\"#PrintStream\" class=\"headerlink\" title=\"PrintStream\"></a>PrintStream</h5><p>经常使用的 <code>System.out</code> 就是用于获取一个 <code>PrintStream</code> 对象，<code>System.out.print</code> 方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code> 方法。默认情况下，<code>PrintStream</code> 输出数据的位置是标准输出，即显示器。</p>\n<p>print(x)会先调用String.valueOf(x)将内容转换成字符串，在调用内部的write()方法。</p>\n<h3 id=\"1-3-2-字符流\"><a href=\"#1-3-2-字符流\" class=\"headerlink\" title=\"1.3.2 字符流\"></a>1.3.2 字符流</h3><h4 id=\"Writer系\"><a href=\"#Writer系\" class=\"headerlink\" title=\"Writer系\"></a>Writer系</h4><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void</td>\n<td>write(int c)</td>\n<td>写入单个字符。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(char[] cbuf)</td>\n<td>写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(char[] cbuf, int off, int len)</td>\n<td>在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(String str)</td>\n<td>写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(String str, int off, int len)</td>\n<td>在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</td>\n</tr>\n<tr>\n<td>Writer</td>\n<td>append(CharSenquence csq)</td>\n<td>将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</td>\n</tr>\n<tr>\n<td>Writer</td>\n<td>append(char c)</td>\n<td>将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象.</td>\n</tr>\n<tr>\n<td>void</td>\n<td>flush()</td>\n<td>刷新此输出流并强制写出所有缓冲的输出字符。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>close()</td>\n<td>关闭输出流释放相关的系统资源。</td>\n</tr>\n</tbody></table>\n<h4 id=\"Reader系\"><a href=\"#Reader系\" class=\"headerlink\" title=\"Reader系\"></a>Reader系</h4><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int</td>\n<td>read()</td>\n<td>从输入流读取一个字符。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read(char[] cbuf)</td>\n<td>从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read(char[] cbuf, int off, int len)</td>\n<td>在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</td>\n</tr>\n<tr>\n<td>long</td>\n<td>skip(long n)</td>\n<td>忽略输入流中的 n 个字符，返回实际忽略的字符数。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>close()</td>\n<td>关闭输入流并释放相关的系统资源。</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-3-3-OutputStreamWriter与InputStreamReader\"><a href=\"#1-3-3-OutputStreamWriter与InputStreamReader\" class=\"headerlink\" title=\"1.3.3 OutputStreamWriter与InputStreamReader\"></a>1.3.3 OutputStreamWriter与InputStreamReader</h3><p>这两个类是FileWriter&#x2F;Reader的父类，主要作用是进行字符与字节之间的转化</p>\n<h2 id=\"1-4-综合\"><a href=\"#1-4-综合\" class=\"headerlink\" title=\"1.4 综合\"></a>1.4 综合</h2><p>计算机只认字节，所以使用字节流效率要大于字符流（字符流也是通过字符与字节之间转化来实现流与文件交互的）.</p>\n<p>IO操作很耗时，所以一次尽量操作较多数据。</p>\n<h2 id=\"RandomAccessFile类\"><a href=\"#RandomAccessFile类\" class=\"headerlink\" title=\"RandomAccessFile类\"></a>RandomAccessFile类</h2><p><strong>支持随意跳转到文件任意位置读写</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// String name: 指定名称的文件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">RandomAccessFile</span><span class=\"params\">(String name, String mode)</span> <span class=\"keyword\">throws</span> FileNotFoundException&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>(name != <span class=\"literal\">null</span> ? <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(name) : <span class=\"literal\">null</span>, mode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// String file: 指定文件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">RandomAccessFile</span><span class=\"params\">(File file, String mode)</span> <span class=\"keyword\">throws</span> FileNotFoundException&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>mode</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r</td>\n<td>只读</td>\n</tr>\n<tr>\n<td>rw</td>\n<td>读写</td>\n</tr>\n<tr>\n<td>rwd</td>\n<td>相较于 <code>rw</code>，还要求对「文件内容」的每次更新都同步写入底层存储设备。</td>\n</tr>\n<tr>\n<td>rws</td>\n<td>相较于 <code>rw</code>，还需要将对「文件内容」或「元数据」的每次更新同步写入底层存储设备；</td>\n</tr>\n</tbody></table>\n<p><strong>常用方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>long</td>\n<td>getFilePointer()</td>\n<td>获取文件指针当前位置</td>\n</tr>\n<tr>\n<td>void</td>\n<td>set(long pos)</td>\n<td>设置文件指针的偏移量</td>\n</tr>\n<tr>\n<td>long</td>\n<td>length()</td>\n<td>返回文件长度</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read()</td>\n<td>读取一个字节</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read(byte[] b)</td>\n<td>从该文件读取最多 <code>b.length</code>字节的数据到字节数组。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read(byte[] b, int off, int len)</td>\n<td>从该文件读取最多 <code>len</code>个字节的数据到字节数组。</td>\n</tr>\n<tr>\n<td>String</td>\n<td>readLine()</td>\n<td>读取下一行文本。</td>\n</tr>\n<tr>\n<td>String</td>\n<td>readUTF()</td>\n<td>从该文件读取字符串。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(byte[] b)</td>\n<td>从指定的字节数组写入 <code>b.length</code>个字节到该文件，从当前文件指针开始。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(byte[] b, int off, int len)</td>\n<td>从指定的字节数组写入 <code>len</code>个字节，从偏移量 <code>off</code>开始写入此文件。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(int b)</td>\n<td>将指定的字节写入此文件。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>writeUTF(String str)</td>\n<td>以机器无关的方式使用 UTF-8 编码将字符串写入文件。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>skipBytes(int n)</td>\n<td>尝试跳过 <code>n </code>字节的输入，丢弃跳过的字节。</td>\n</tr>\n</tbody></table>\n<h2 id=\"RandomAccessFile实现断点续传\"><a href=\"#RandomAccessFile实现断点续传\" class=\"headerlink\" title=\"RandomAccessFile实现断点续传\"></a>RandomAccessFile实现断点续传</h2><p> &#x2F;&#x2F;todo</p>\n<h1 id=\"2-IO模型（Unix）\"><a href=\"#2-IO模型（Unix）\" class=\"headerlink\" title=\"2. IO模型（Unix）\"></a>2. IO模型（Unix）</h1><h2 id=\"2-1-简述\"><a href=\"#2-1-简述\" class=\"headerlink\" title=\"2.1 简述\"></a>2.1 简述</h2><p>一个输入操作通常包括两个阶段:</p>\n<ol>\n<li><p>等待数据准备好（数据已经通过读取磁盘或者通过网络模块获取到内核缓冲区中）</p>\n</li>\n<li><p>从内核缓冲区向进程缓冲区复制数据</p>\n</li>\n</ol>\n<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>\n<h3 id=\"阻塞式IO\"><a href=\"#阻塞式IO\" class=\"headerlink\" title=\"阻塞式IO\"></a>阻塞式IO</h3><p><strong>在获取数据时应用进程被阻塞，直到数据到达进程缓冲区</strong></p>\n<p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">recvfrom</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> len, <span class=\"type\">int</span> flags, <span class=\"keyword\">struct</span> sockaddr *src_addr, <span class=\"type\">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/09/10/java_IO/java-io-model-0.png\" alt=\"java-io-model-0\"></p>\n<h3 id=\"非阻塞式IO\"><a href=\"#非阻塞式IO\" class=\"headerlink\" title=\"非阻塞式IO\"></a>非阻塞式IO</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I&#x2F;O 是否完成，这种方式称为轮询(polling)。</p>\n<p>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。</p>\n<p><img src=\"/2024/09/10/java_IO/java-io-model-1.png\" alt=\"java-io-model-1\"></p>\n<h3 id=\"IO复用\"><a href=\"#IO复用\" class=\"headerlink\" title=\"IO复用\"></a>IO复用</h3><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。</p>\n<p>它可以让单个进程具有处理多个 I&#x2F;O 事件的能力。又被称为 Event Driven I&#x2F;O，即事件驱动 I&#x2F;O。</p>\n<p>如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>\n<p><img src=\"/2024/09/10/java_IO/java-io-model-2.png\" alt=\"java-io-model-2\"></p>\n<h3 id=\"信号驱动IO\"><a href=\"#信号驱动IO\" class=\"headerlink\" title=\"信号驱动IO\"></a>信号驱动IO</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>\n<p>相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高。</p>\n<p><img src=\"/2024/09/10/java_IO/java-io-model-3.png\" alt=\"java-io-model-3\"></p>\n<h3 id=\"异步IO\"><a href=\"#异步IO\" class=\"headerlink\" title=\"异步IO\"></a>异步IO</h3><p>进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>\n<p>异步 I&#x2F;O 与信号驱动 I&#x2F;O 的区别在于，异步 I&#x2F;O 的信号是通知应用进程 I&#x2F;O 完成，而信号驱动 I&#x2F;O 的信号是通知应用进程可以开始 I&#x2F;O。</p>\n<p><img src=\"/2024/09/10/java_IO/java-io-model-4.png\" alt=\"java-io-model-4\"></p>\n<h2 id=\"2-2-区别\"><a href=\"#2-2-区别\" class=\"headerlink\" title=\"2.2 区别\"></a>2.2 区别</h2><p>前四种 I&#x2F;O 模型的主要区别在于第一个阶段，而第二个阶段是一样的: 将数据从内核复制到应用进程过程中，应用进程会被阻塞。</p>\n<p><img src=\"/2024/09/10/java_IO/1492928105791_3.png\" alt=\"1492928105791_3\"></p>\n<h2 id=\"2-3-IO多路复用\"><a href=\"#2-3-IO多路复用\" class=\"headerlink\" title=\"2.3 IO多路复用\"></a>2.3 IO多路复用</h2><h3 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h3><ol>\n<li><p><strong>LT模式</strong>（边缘触发）：</p>\n<p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>\n</li>\n<li><p><strong>ET模式</strong>（水平触发）：</p>\n<p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>\n<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>\n</li>\n<li><p><strong>select 应用场景</strong></p>\n<p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持。</p>\n<p><strong>只支持LT</strong></p>\n<p><strong>缺点</strong>：使用数组存文件描述符，fd_set会在用户空间和内核空间之间来回复制，监控的文件描述符数量有限</p>\n</li>\n<li><p><strong>poll 应用场景</strong></p>\n<p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。</p>\n<p><strong>只支持LT</strong></p>\n<p><strong>缺点</strong>：使用链表存文件描述符，获得文件描述符信息还是要O(n)时间复杂度遍历链表</p>\n</li>\n<li><p><strong>epoll 应用场景</strong></p>\n<p>只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。</p>\n<p><strong>支持LT和ET</strong></p>\n<p>使用红黑树存文件描述符，将就绪文件描述符添加到队列中。</p>\n</li>\n</ol>\n<h1 id=\"3-IO模型（java）\"><a href=\"#3-IO模型（java）\" class=\"headerlink\" title=\"3. IO模型（java）\"></a>3. IO模型（java）</h1><p><strong>同步与非同步：</strong>这两个概念是<code>操作系统级别</code>的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。</p>\n<p><strong>阻塞与非阻塞：</strong>这两个概念是<code>程序级别</code>的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)</p>\n<h2 id=\"3-1-BIO\"><a href=\"#3-1-BIO\" class=\"headerlink\" title=\"3.1 BIO\"></a>3.1 BIO</h2><p>传统从服务端获取连接<code>accept()</code>方法以及从从流中获取数据的<code>read()</code>都是阻塞的，这些方法的调用会导致该线程一直处于等待状态</p>\n<h2 id=\"3-2-NIO\"><a href=\"#3-2-NIO\" class=\"headerlink\" title=\"3.2 NIO\"></a>3.2 NIO</h2><h4 id=\"流和块\"><a href=\"#流和块\" class=\"headerlink\" title=\"流和块\"></a>流和块</h4><p>I&#x2F;O 与 NIO 最重要的区别是数据打包和传输的方式，I&#x2F;O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>\n<p>面向流的 I&#x2F;O 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I&#x2F;O 通常相当慢。</p>\n<p>面向块的 I&#x2F;O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I&#x2F;O 缺少一些面向流的 I&#x2F;O 所具有的优雅性和简单性。</p>\n<h4 id=\"通道与缓冲区\"><a href=\"#通道与缓冲区\" class=\"headerlink\" title=\"通道与缓冲区\"></a>通道与缓冲区</h4><ol>\n<li><p>Channel（通道）</p>\n<p>通道 Channel 是对原 I&#x2F;O 包中的流的模拟，可以通过它读取和写入数据。但是通道是双向的，不同于只能单向传输数据的InputStream或OutputStream</p>\n<p><strong>常用类</strong>：</p>\n<ul>\n<li><p>FileChannel: 从文件中读写数据；</p>\n</li>\n<li><p>DatagramChannel: 通过 UDP 读写网络中数据；</p>\n</li>\n<li><p>SocketChannel: 通过 TCP 读写网络中数据；</p>\n</li>\n<li><p>ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</p>\n</li>\n</ul>\n</li>\n<li><p>Buffer（缓冲区）</p>\n<p>使用通道交换数据时，会先经过缓冲区</p>\n<p><strong>常见类型</strong>：</p>\n<ul>\n<li>ByteBuffer</li>\n<li>CharBuffer</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"Buffer详细分析\"><a href=\"#Buffer详细分析\" class=\"headerlink\" title=\"Buffer详细分析\"></a>Buffer详细分析</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Buffer中定义的四个成员变量</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Buffer</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">mark</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">position</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> limit;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>容量（<code>capacity</code>）</strong>：<code>Buffer</code>可以存储的最大数据量，<code>Buffer</code>创建时设置且不可改变；</li>\n<li><strong>界限（<code>limit</code>）</strong>：<code>Buffer</code> 中可以读&#x2F;写数据的边界。写模式下，<code>limit</code> 代表最多能写入的数据，一般等于 <code>capacity</code>（可以通过<code>limit(int newLimit)</code>方法设置）；读模式下，<code>limit</code> 等于 Buffer 中实际写入的数据大小。</li>\n<li><strong>位置（<code>position</code>）</strong>：下一个可以被读写的数据的位置（索引）。从写操作模式到读操作模式切换的时候（flip），<code>position</code> 都会归零，这样就可以从头开始读写了。</li>\n<li><strong>标记（<code>mark</code>）</strong>：<code>Buffer</code>允许将位置直接定位到该标记处，这是一个可选属性；</li>\n</ol>\n<p> <strong>两种模式</strong>：</p>\n<p>Buffer有写和读两种模式。Buffer创建出来默认是写模式，调用 <code>flip()</code> 可以切换到读模式。如果要再次切换回写模式，可以调用 <code>clear()</code> 或者 <code>compact()</code> 方法。</p>\n<p><strong>读写模式下三个成员变量之间的关系：</strong></p>\n<img src=\"/2024/09/10/java_IO/JavaNIOBuffer.png\" alt=\"JavaNIOBuffer\" style=\"zoom:100%;\">\n\n\n\n<p><strong>创建方式</strong>：</p>\n<p>不能直接通过<code>new</code>调用构造方法创建对象，只能通过静态方法实例化<code>Buffer</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以ByteBuffer为例，其他缓冲区都差不多</span></span><br><span class=\"line\"><span class=\"comment\">// 分配堆内存</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ByteBuffer <span class=\"title function_\">allocate</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 分配直接内存</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ByteBuffer <span class=\"title function_\">allocateDirect</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>常用方法</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xxx</td>\n<td>get()</td>\n<td>读取缓冲区的数据</td>\n</tr>\n<tr>\n<td>xxxBuffer</td>\n<td>put()</td>\n<td>向缓冲区写入数据</td>\n</tr>\n<tr>\n<td>Buffer</td>\n<td>flip()</td>\n<td>将缓冲区从写模式切换到读模式，它会将 <code>limit</code> 的值设置为当前 <code>position</code> 的值，将 <code>position</code> 的值设置为 0。</td>\n</tr>\n<tr>\n<td>Buffer</td>\n<td>clear()</td>\n<td>清空缓冲区，将缓冲区从读模式切换到写模式，并将 <code>position</code> 的值设置为 0，将 <code>limit</code> 的值设置为 <code>capacity</code> 的值。</td>\n</tr>\n</tbody></table>\n<h4 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h4><p>Selector（选择器） 是 NIO 中的一个关键组件，它允许一个线程处理多个 Channel。Selector 是基于事件驱动的 I&#x2F;O 多路复用模型，主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行响应的 I&#x2F;O 操作。</p>\n<p><strong>Selector可以监听的四种数据类型</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">OP_READ</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>;    <span class=\"comment\">//表示通道准备好进行读取的事件，即有数据可读。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">OP_WRITE</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>;   <span class=\"comment\">//表示通道准备好进行写入的事件，即可以写入数据。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">OP_CONNECT</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>; <span class=\"comment\">//表示通道完成连接的事件，这通常用于 SocketChannel。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">OP_ACCEPT</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;  <span class=\"comment\">//表示通道接受连接的事件，这通常用于 ServerSocketChannel。</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">interestSet</span> <span class=\"operator\">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>\n\n<p>一个Selector的三个Selection：</p>\n<ol>\n<li><p>所有的 <code>SelectionKey</code> 集合：代表了注册在该 Selector 上的 <code>Channel</code>，这个集合可以通过 <code>keys()</code> 方法返回。</p>\n</li>\n<li><p>被选择的 <code>SelectionKey</code> 集合：代表了所有可通过 <code>select()</code> 方法获取的、需要进行 <code>IO</code> 处理的 Channel，这个集合可以通过 <code>selectedKeys()</code> 返回。</p>\n</li>\n<li><p>被取消的 <code>SelectionKey</code> 集合：代表了所有被取消注册关系的 <code>Channel</code>，在下一次执行 <code>select()</code> 方法时，这些 <code>Channel</code> 对应的 <code>SelectionKey</code> 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//遍历选择的Channel</span></span><br><span class=\"line\">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class=\"line\">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (keyIterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> keyIterator.next();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ServerSocketChannel 接收了一个新连接</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isConnectable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 表示一个新连接建立</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Channel 有准备好的数据，可以读取</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isWritable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Channel 有空闲的 Buffer，可以写入数据</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    keyIterator.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>select()</code>相关方法</strong></p>\n<ol>\n<li><p><code>int select()</code>：监控所有注册的 <code>Channel</code>，当它们中间有需要处理的 <code>IO</code> 操作时，该方法返回，并将对应的 <code>SelectionKey</code> 加入被选择的 <code>SelectionKey</code> 集合中，该方法返回这些 <code>Channel</code> 的数量。</p>\n</li>\n<li><p><code>int select(long timeout)</code>：可以设置超时时长的 <code>select()</code> 操作。</p>\n</li>\n<li><p><code>int selectNow()</code>：执行一个立即返回的 <code>select()</code> 操作，相对于无参数的 <code>select()</code> 方法而言，该方法不会阻塞线程。</p>\n</li>\n<li><p><code>Selector wakeup()</code>：使一个还未返回的 <code>select()</code> 方法立刻返回。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//NIO实例</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetSocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SelectionKey;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.Selector;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NioSelectorExample</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">serverSocketChannel</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">      serverSocketChannel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">      serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">      <span class=\"comment\">// 将 ServerSocketChannel 注册到 Selector 并监听 OP_ACCEPT 事件</span></span><br><span class=\"line\">      serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">readyChannels</span> <span class=\"operator\">=</span> selector.select();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (readyChannels == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class=\"line\">        Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (keyIterator.hasNext()) &#123;</span><br><span class=\"line\">          <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> keyIterator.next();</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理连接事件</span></span><br><span class=\"line\">            <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">            <span class=\"type\">SocketChannel</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> server.accept();</span><br><span class=\"line\">            client.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将客户端通道注册到 Selector 并监听 OP_READ 事件</span></span><br><span class=\"line\">            client.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理读事件</span></span><br><span class=\"line\">            <span class=\"type\">SocketChannel</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">bytesRead</span> <span class=\"operator\">=</span> client.read(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bytesRead &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              buffer.flip();</span><br><span class=\"line\">              System.out.println(<span class=\"string\">&quot;收到数据：&quot;</span> +<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buffer.array(), <span class=\"number\">0</span>, bytesRead));</span><br><span class=\"line\">              <span class=\"comment\">// 将客户端通道注册到 Selector 并监听 OP_WRITE 事件</span></span><br><span class=\"line\">              client.register(selector, SelectionKey.OP_WRITE);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bytesRead &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 客户端断开连接</span></span><br><span class=\"line\">              client.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isWritable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理写事件</span></span><br><span class=\"line\">            <span class=\"type\">SocketChannel</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.wrap(<span class=\"string\">&quot;Hello, Client!&quot;</span>.getBytes());</span><br><span class=\"line\">            client.write(buffer);</span><br><span class=\"line\">            <span class=\"comment\">// 将客户端通道注册到 Selector 并监听 OP_READ 事件</span></span><br><span class=\"line\">            client.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          keyIterator.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-零拷贝\"><a href=\"#3-3-零拷贝\" class=\"headerlink\" title=\"3.3 零拷贝\"></a>3.3 零拷贝</h2><p>零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。也就是说，零拷贝主主要解决操作系统在处理 I&#x2F;O 操作时频繁复制数据的问题。</p>\n<p>Java 对零拷贝的支持：</p>\n<ul>\n<li><code>MappedByteBuffer</code> 是 NIO 基于内存映射（<code>mmap</code>）这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 <code>mmap</code> 系统调用。它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以直接操作内存中的数据，而不需要通过系统调用来读写文件。</li>\n<li><code>FileChannel</code> 的<code>transferTo()/transferFrom()</code>是 NIO 基于发送文件（<code>sendfile</code>）这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 <code>sendfile</code>系统调用。它可以直接将文件数据从内核发送到网络，而不需要经过用户空间的缓冲区。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadFileIntoMemory</span><span class=\"params\">(File xmlFile)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">  <span class=\"type\">FileInputStream</span> <span class=\"variable\">fis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(xmlFile);</span><br><span class=\"line\">  <span class=\"comment\">// 创建 FileChannel 对象</span></span><br><span class=\"line\">  <span class=\"type\">FileChannel</span> <span class=\"variable\">fc</span> <span class=\"operator\">=</span> fis.getChannel();</span><br><span class=\"line\">  <span class=\"comment\">// FileChannel.map() 将文件映射到直接内存并返回 MappedByteBuffer 对象</span></span><br><span class=\"line\">  <span class=\"type\">MappedByteBuffer</span> <span class=\"variable\">mmb</span> <span class=\"operator\">=</span> fc.map(FileChannel.MapMode.READ_ONLY, <span class=\"number\">0</span>, fc.size());</span><br><span class=\"line\">  xmlFileBuffer = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[(<span class=\"type\">int</span>)fc.size()];</span><br><span class=\"line\">  mmb.get(xmlFileBuffer);</span><br><span class=\"line\">  fis.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>\n<h2 id=\"3-4-AIO\"><a href=\"#3-4-AIO\" class=\"headerlink\" title=\"3.4 AIO\"></a>3.4 AIO</h2><p>异步IO，Linux没有这种机制的支持，只能模拟AIO，使用效率提升不大。</p>\n<h2 id=\"3-5-Reactor模型\"><a href=\"#3-5-Reactor模型\" class=\"headerlink\" title=\"3.5 Reactor模型\"></a>3.5 Reactor模型</h2><p>我们可以粗略的将网络IO过程分为以下几个部分</p>\n<ol>\n<li>连接的建立</li>\n<li>数据的接受</li>\n<li>数据的处理（数据的编解码以及业务计算）</li>\n<li>数据的发送</li>\n</ol>\n<h3 id=\"传统IO模型\"><a href=\"#传统IO模型\" class=\"headerlink\" title=\"传统IO模型\"></a>传统IO模型</h3><img src=\"/2024/09/10/java_IO/java-io-reactor-1.png\" alt=\"java-io-reactor-1\" style=\"zoom:80%;\">\n\n<p>一个线程处理一个客户端请求的全过程。由于一次请求的部分过程是不需要消耗CPU资源的（时间占比可能还挺大），所以一个线程处理一个请求的方式效率不高。</p>\n<h3 id=\"事件驱动模型\"><a href=\"#事件驱动模型\" class=\"headerlink\" title=\"事件驱动模型\"></a>事件驱动模型</h3><img src=\"/2024/09/10/java_IO/java-io-reactor-4.png\" alt=\"java-io-reactor-4\" style=\"zoom:80%;\">\n\n<p>Reactor部分分为mainReactor与subReactor</p>\n<ol>\n<li><p><strong>mainReactor</strong></p>\n<p>mainReactor主要进行客户端连接的处理，处理完成之后将该连接交由subReactor以处理客户端的网络读写。</p>\n</li>\n<li><p><strong>subReactor</strong></p>\n<p>subReactor使用一个线程池作为支撑，用多线程来处理网络读写和数据处理</p>\n</li>\n</ol>\n","site":{"data":{}},"length":6541,"excerpt":"<p>本文主要关注于java中的IO</p>","more":"<h1 id=\"1-基础\"><a href=\"#1-基础\" class=\"headerlink\" title=\"1. 基础\"></a>1. 基础</h1><p><img src=\"/2024/09/10/java_IO/java-io-overview2.png\" alt=\"java-io-overview2\"></p>\n<h2 id=\"1-1-分类\"><a href=\"#1-1-分类\" class=\"headerlink\" title=\"1.1 分类\"></a>1.1 分类</h2><ol>\n<li><p>按数据的流向不同分为：<strong>输入流和输出流</strong></p>\n</li>\n<li><p>按操作数据单位的不同分为：<strong>字节流（8bit）和字符流（16bit）</strong></p>\n<p>编码是将字符流转化为字节流，解码是将字节流转化为字节流，编码解码规则不一样会导致乱码</p>\n<p>字节是给计算机看的，字符是给人看的。一个字符的大小和编码方式和字符类型有关。</p>\n<p>java使用UTF-16be 编码，中文字符和英文字符都占 2 个字节，这样一个中文或者英文字符都可以通过一个单位char类型存放。</p>\n</li>\n<li><p>根据IO流的角色不同分为：<strong>节点流和处理流</strong></p>\n<ul>\n<li>节点流：直接从数据源或目的地读写数据</li>\n<li>处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）上</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-文件\"><a href=\"#1-2-文件\" class=\"headerlink\" title=\"1.2 文件\"></a>1.2 文件</h2><p>文件在java中对应的对象为<code>File</code>，文件在程序中是以流的形式来操作的</p>\n<img src=\"/2024/09/10/java_IO/image-20240225220137926.png\" alt=\"image-20240225220137926\" style=\"zoom:60%;\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//常用构造方法</span></span><br><span class=\"line\">    <span class=\"comment\">//父目录以及子目录</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"title function_\">File</span><span class=\"params\">(String parent, String child)</span> &#123;&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//父文件下所在目录的子目录</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">File</span><span class=\"params\">(String child, File parent)</span> &#123;&#125;</span><br><span class=\"line\">   <span class=\"comment\">//正常的路径</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">File</span><span class=\"params\">(String pathname)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所有 <code>java.io</code> 中的类的<strong>相对路径</strong>默认都是从<strong>用户工作目录</strong>开始的，使用 <code>System.getProperty(&quot;user.dir&quot;)</code> 可以获取你的用户工作目录。</p>\n<p>在 Windows 系统中的分隔符为 “<code>\\\\</code>“，在 Linux 系统中分隔符为 “<code>/</code>“，为了保证系统的可移植性，可以通过常量字符串 <code>java.io.File.separator</code> 获取。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> filename 文件名</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> path 文件所在路径</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">createNewFile</span><span class=\"params\">(String filename,String path)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(filename.isEmpty())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">pa</span> <span class=\"operator\">=</span> path+ File.separator+filename;</span><br><span class=\"line\">        <span class=\"comment\">//可以使用其他方式创建File对象</span></span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(pa);</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            file.createNewFile();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (IOException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String</td>\n<td>getName()</td>\n<td>获取文件名</td>\n</tr>\n<tr>\n<td>String</td>\n<td>getAbsolutePath()</td>\n<td>获取文件绝对路径</td>\n</tr>\n<tr>\n<td>String</td>\n<td>getParent()</td>\n<td>获取文件父级目录</td>\n</tr>\n<tr>\n<td>long</td>\n<td>length()</td>\n<td>返回文件字节大小</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>exists()</td>\n<td>判断文件是否存在</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>isFile()</td>\n<td>判断是否是文件</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>isDirectory()</td>\n<td>判断是否是目录</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean</td>\n<td>mkdir()</td>\n<td>创建一级目录</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>mkdirs()</td>\n<td>创建多级目录</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>delete()</td>\n<td>删除文件或目录</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">tableOfContent</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">parentPath</span> <span class=\"operator\">=</span> System.getProperty(<span class=\"string\">&quot;user.dir&quot;</span>);</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">fileName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;testFile.txt&quot;</span>;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">directoryName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;a&quot;</span>;</span><br><span class=\"line\">       <span class=\"type\">String</span> <span class=\"variable\">mulDirectoryName</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;b/c/d&quot;</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 删除文件</span></span><br><span class=\"line\">       <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(parentPath, fileName);</span><br><span class=\"line\">       file.delete();</span><br><span class=\"line\">       <span class=\"comment\">// 创建一级目录</span></span><br><span class=\"line\">       <span class=\"type\">File</span> <span class=\"variable\">directory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(parentPath, directoryName);</span><br><span class=\"line\">       directory.mkdir();</span><br><span class=\"line\">       <span class=\"comment\">// 创建多级目录</span></span><br><span class=\"line\">       <span class=\"type\">File</span> <span class=\"variable\">mulDirectory</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(parentPath, mulDirectoryName);</span><br><span class=\"line\">       mulDirectory.mkdirs();</span><br><span class=\"line\">       <span class=\"comment\">// 删除目录</span></span><br><span class=\"line\">       directory.delete();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-输入输出流\"><a href=\"#1-3-输入输出流\" class=\"headerlink\" title=\"1.3 输入输出流\"></a>1.3 输入输出流</h2><p><strong>try-with-resources</strong></p>\n<p>这个语法糖的出现主要是为了减少关闭创建资源的工作</p>\n<p>详见<a href=\"https://zhuanlan.zhihu.com/p/27824934\">https://zhuanlan.zhihu.com/p/27824934</a></p>\n<h3 id=\"1-3-1-字节流\"><a href=\"#1-3-1-字节流\" class=\"headerlink\" title=\"1.3.1 字节流\"></a>1.3.1 字节流</h3><img src=\"/2024/09/10/java_IO/image-20240226191911489.png\" alt=\"image-20240226191911489\" style=\"zoom:80%;\">\n\n<h4 id=\"InputStream系\"><a href=\"#InputStream系\" class=\"headerlink\" title=\"InputStream系\"></a>InputStream系</h4><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int</td>\n<td>read()</td>\n<td>返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read(byte b[ ])</td>\n<td>从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ，返回读取的字节数。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read(byte b[], int off, int len)</td>\n<td>在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</td>\n</tr>\n<tr>\n<td>long</td>\n<td>skip(long n)</td>\n<td>忽略输入流中的 <code>n</code> 个字节 ，返回实际忽略的字节数。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>available()</td>\n<td>返回输入流中可以读取的字节数。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>close()</td>\n<td>关闭输入流释放相关的系统资源。</td>\n</tr>\n<tr>\n<td>byte[]</td>\n<td>readAllBytes()</td>\n<td>读取输入流中的所有字节，返回字节数组。</td>\n</tr>\n<tr>\n<td>byte[]</td>\n<td>readNBytes(byte[] b, int off, int len)</td>\n<td>阻塞直到读取 <code>len</code> 个字节。</td>\n</tr>\n<tr>\n<td>long</td>\n<td>transferTo(OutputStream out)</td>\n<td>将所有字节从一个输入流传递到一个输出流。</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p><strong>FileInputStream</strong></p>\n<img src=\"/2024/09/10/java_IO/image-20240226193441574.png\" alt=\"image-20240226193441574\" style=\"zoom:67%;\">\n\n<p>可以把File类实例作为参数传入构造函数，以类似以下读取数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">FileInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;文件路径&quot;</span>));</span><br><span class=\"line\"><span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">8</span>]; </span><br><span class=\"line\"><span class=\"type\">int</span> readLen;</span><br><span class=\"line\">       <span class=\"comment\">// 返回值为 -1 时，表示读取完毕</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span> ((readLen = in.read(buf)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">           System.out.print(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buf, <span class=\"number\">0</span>, readLen)); </span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>FilterInputStream</strong></p>\n<p>该类是标准的装饰器模式的示例，FilterInputStream作为装饰器的根抽象类，可以接收InputStream对象实例作为参数以增强原有功能。</p>\n<ul>\n<li><p><strong>BufferedInputStream</strong></p>\n<p>内置了缓冲，可以提升效率（尽量使用该类）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//再套一层就行了</span></span><br><span class=\"line\"><span class=\"type\">BufferedInputStream</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;文件路径&quot;</span>)));</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] buf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">8</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> readLen;</span><br><span class=\"line\">        <span class=\"comment\">// 返回值为 -1 时，表示读取完毕</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((readLen = in.read(buf)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.print(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buf, <span class=\"number\">0</span>, readLen));</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>DataInputStream</strong></p>\n<p>用于读取指定类型的数据</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testDataInputStream</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 必须将一个 InputStream 的实现类作为构造参数才能使用</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>(<span class=\"type\">DataInputStream</span> <span class=\"variable\">dis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;mrpersimmon2.txt&quot;</span>))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以读取任意具体的类型数据</span></span><br><span class=\"line\">        System.out.println(dis.readUTF()); <span class=\"comment\">// 读取已使用 modified UTF-8 格式编码的字符串。</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>ObjectInputStream</strong></p>\n<p>该类是序列化相关的类（反序列化），也就是可以从流中读取对象</p>\n</li>\n</ol>\n<h4 id=\"OutputStream系\"><a href=\"#OutputStream系\" class=\"headerlink\" title=\"OutputStream系\"></a>OutputStream系</h4><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void</td>\n<td>write(int b)</td>\n<td>将特定字节写入输出流。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(byte[] b)</td>\n<td>将数组 <code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(byte[] b, int off, int len)</td>\n<td>在 <code>write(byte b[])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>flush()</td>\n<td>刷新此输出流并强制写出所有缓冲的输出字节。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>close()</td>\n<td>关闭输出流释放相关的系统资源。</td>\n</tr>\n</tbody></table>\n<p>OutputStream 下的子类<code>FileOutputStream</code> ，<code>DataOutputStream</code>，<code>ObjectOutputStream</code>与<code>InputStream</code>中的类似</p>\n<h5 id=\"PrintStream\"><a href=\"#PrintStream\" class=\"headerlink\" title=\"PrintStream\"></a>PrintStream</h5><p>经常使用的 <code>System.out</code> 就是用于获取一个 <code>PrintStream</code> 对象，<code>System.out.print</code> 方法实际调用的是 <code>PrintStream</code> 对象的 <code>write</code> 方法。默认情况下，<code>PrintStream</code> 输出数据的位置是标准输出，即显示器。</p>\n<p>print(x)会先调用String.valueOf(x)将内容转换成字符串，在调用内部的write()方法。</p>\n<h3 id=\"1-3-2-字符流\"><a href=\"#1-3-2-字符流\" class=\"headerlink\" title=\"1.3.2 字符流\"></a>1.3.2 字符流</h3><h4 id=\"Writer系\"><a href=\"#Writer系\" class=\"headerlink\" title=\"Writer系\"></a>Writer系</h4><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void</td>\n<td>write(int c)</td>\n<td>写入单个字符。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(char[] cbuf)</td>\n<td>写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(char[] cbuf, int off, int len)</td>\n<td>在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(String str)</td>\n<td>写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(String str, int off, int len)</td>\n<td>在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</td>\n</tr>\n<tr>\n<td>Writer</td>\n<td>append(CharSenquence csq)</td>\n<td>将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</td>\n</tr>\n<tr>\n<td>Writer</td>\n<td>append(char c)</td>\n<td>将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象.</td>\n</tr>\n<tr>\n<td>void</td>\n<td>flush()</td>\n<td>刷新此输出流并强制写出所有缓冲的输出字符。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>close()</td>\n<td>关闭输出流释放相关的系统资源。</td>\n</tr>\n</tbody></table>\n<h4 id=\"Reader系\"><a href=\"#Reader系\" class=\"headerlink\" title=\"Reader系\"></a>Reader系</h4><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int</td>\n<td>read()</td>\n<td>从输入流读取一个字符。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read(char[] cbuf)</td>\n<td>从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read(char[] cbuf, int off, int len)</td>\n<td>在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</td>\n</tr>\n<tr>\n<td>long</td>\n<td>skip(long n)</td>\n<td>忽略输入流中的 n 个字符，返回实际忽略的字符数。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>close()</td>\n<td>关闭输入流并释放相关的系统资源。</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-3-3-OutputStreamWriter与InputStreamReader\"><a href=\"#1-3-3-OutputStreamWriter与InputStreamReader\" class=\"headerlink\" title=\"1.3.3 OutputStreamWriter与InputStreamReader\"></a>1.3.3 OutputStreamWriter与InputStreamReader</h3><p>这两个类是FileWriter&#x2F;Reader的父类，主要作用是进行字符与字节之间的转化</p>\n<h2 id=\"1-4-综合\"><a href=\"#1-4-综合\" class=\"headerlink\" title=\"1.4 综合\"></a>1.4 综合</h2><p>计算机只认字节，所以使用字节流效率要大于字符流（字符流也是通过字符与字节之间转化来实现流与文件交互的）.</p>\n<p>IO操作很耗时，所以一次尽量操作较多数据。</p>\n<h2 id=\"RandomAccessFile类\"><a href=\"#RandomAccessFile类\" class=\"headerlink\" title=\"RandomAccessFile类\"></a>RandomAccessFile类</h2><p><strong>支持随意跳转到文件任意位置读写</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// String name: 指定名称的文件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">RandomAccessFile</span><span class=\"params\">(String name, String mode)</span> <span class=\"keyword\">throws</span> FileNotFoundException&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>(name != <span class=\"literal\">null</span> ? <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(name) : <span class=\"literal\">null</span>, mode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// String file: 指定文件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">RandomAccessFile</span><span class=\"params\">(File file, String mode)</span> <span class=\"keyword\">throws</span> FileNotFoundException&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>mode</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r</td>\n<td>只读</td>\n</tr>\n<tr>\n<td>rw</td>\n<td>读写</td>\n</tr>\n<tr>\n<td>rwd</td>\n<td>相较于 <code>rw</code>，还要求对「文件内容」的每次更新都同步写入底层存储设备。</td>\n</tr>\n<tr>\n<td>rws</td>\n<td>相较于 <code>rw</code>，还需要将对「文件内容」或「元数据」的每次更新同步写入底层存储设备；</td>\n</tr>\n</tbody></table>\n<p><strong>常用方法</strong></p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>long</td>\n<td>getFilePointer()</td>\n<td>获取文件指针当前位置</td>\n</tr>\n<tr>\n<td>void</td>\n<td>set(long pos)</td>\n<td>设置文件指针的偏移量</td>\n</tr>\n<tr>\n<td>long</td>\n<td>length()</td>\n<td>返回文件长度</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read()</td>\n<td>读取一个字节</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read(byte[] b)</td>\n<td>从该文件读取最多 <code>b.length</code>字节的数据到字节数组。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>read(byte[] b, int off, int len)</td>\n<td>从该文件读取最多 <code>len</code>个字节的数据到字节数组。</td>\n</tr>\n<tr>\n<td>String</td>\n<td>readLine()</td>\n<td>读取下一行文本。</td>\n</tr>\n<tr>\n<td>String</td>\n<td>readUTF()</td>\n<td>从该文件读取字符串。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(byte[] b)</td>\n<td>从指定的字节数组写入 <code>b.length</code>个字节到该文件，从当前文件指针开始。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(byte[] b, int off, int len)</td>\n<td>从指定的字节数组写入 <code>len</code>个字节，从偏移量 <code>off</code>开始写入此文件。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>write(int b)</td>\n<td>将指定的字节写入此文件。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>writeUTF(String str)</td>\n<td>以机器无关的方式使用 UTF-8 编码将字符串写入文件。</td>\n</tr>\n<tr>\n<td>int</td>\n<td>skipBytes(int n)</td>\n<td>尝试跳过 <code>n </code>字节的输入，丢弃跳过的字节。</td>\n</tr>\n</tbody></table>\n<h2 id=\"RandomAccessFile实现断点续传\"><a href=\"#RandomAccessFile实现断点续传\" class=\"headerlink\" title=\"RandomAccessFile实现断点续传\"></a>RandomAccessFile实现断点续传</h2><p> &#x2F;&#x2F;todo</p>\n<h1 id=\"2-IO模型（Unix）\"><a href=\"#2-IO模型（Unix）\" class=\"headerlink\" title=\"2. IO模型（Unix）\"></a>2. IO模型（Unix）</h1><h2 id=\"2-1-简述\"><a href=\"#2-1-简述\" class=\"headerlink\" title=\"2.1 简述\"></a>2.1 简述</h2><p>一个输入操作通常包括两个阶段:</p>\n<ol>\n<li><p>等待数据准备好（数据已经通过读取磁盘或者通过网络模块获取到内核缓冲区中）</p>\n</li>\n<li><p>从内核缓冲区向进程缓冲区复制数据</p>\n</li>\n</ol>\n<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>\n<h3 id=\"阻塞式IO\"><a href=\"#阻塞式IO\" class=\"headerlink\" title=\"阻塞式IO\"></a>阻塞式IO</h3><p><strong>在获取数据时应用进程被阻塞，直到数据到达进程缓冲区</strong></p>\n<p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">recvfrom</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">void</span> *buf, <span class=\"type\">size_t</span> len, <span class=\"type\">int</span> flags, <span class=\"keyword\">struct</span> sockaddr *src_addr, <span class=\"type\">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2024/09/10/java_IO/java-io-model-0.png\" alt=\"java-io-model-0\"></p>\n<h3 id=\"非阻塞式IO\"><a href=\"#非阻塞式IO\" class=\"headerlink\" title=\"非阻塞式IO\"></a>非阻塞式IO</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I&#x2F;O 是否完成，这种方式称为轮询(polling)。</p>\n<p>由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。</p>\n<p><img src=\"/2024/09/10/java_IO/java-io-model-1.png\" alt=\"java-io-model-1\"></p>\n<h3 id=\"IO复用\"><a href=\"#IO复用\" class=\"headerlink\" title=\"IO复用\"></a>IO复用</h3><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。</p>\n<p>它可以让单个进程具有处理多个 I&#x2F;O 事件的能力。又被称为 Event Driven I&#x2F;O，即事件驱动 I&#x2F;O。</p>\n<p>如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>\n<p><img src=\"/2024/09/10/java_IO/java-io-model-2.png\" alt=\"java-io-model-2\"></p>\n<h3 id=\"信号驱动IO\"><a href=\"#信号驱动IO\" class=\"headerlink\" title=\"信号驱动IO\"></a>信号驱动IO</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>\n<p>相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高。</p>\n<p><img src=\"/2024/09/10/java_IO/java-io-model-3.png\" alt=\"java-io-model-3\"></p>\n<h3 id=\"异步IO\"><a href=\"#异步IO\" class=\"headerlink\" title=\"异步IO\"></a>异步IO</h3><p>进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>\n<p>异步 I&#x2F;O 与信号驱动 I&#x2F;O 的区别在于，异步 I&#x2F;O 的信号是通知应用进程 I&#x2F;O 完成，而信号驱动 I&#x2F;O 的信号是通知应用进程可以开始 I&#x2F;O。</p>\n<p><img src=\"/2024/09/10/java_IO/java-io-model-4.png\" alt=\"java-io-model-4\"></p>\n<h2 id=\"2-2-区别\"><a href=\"#2-2-区别\" class=\"headerlink\" title=\"2.2 区别\"></a>2.2 区别</h2><p>前四种 I&#x2F;O 模型的主要区别在于第一个阶段，而第二个阶段是一样的: 将数据从内核复制到应用进程过程中，应用进程会被阻塞。</p>\n<p><img src=\"/2024/09/10/java_IO/1492928105791_3.png\" alt=\"1492928105791_3\"></p>\n<h2 id=\"2-3-IO多路复用\"><a href=\"#2-3-IO多路复用\" class=\"headerlink\" title=\"2.3 IO多路复用\"></a>2.3 IO多路复用</h2><h3 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h3><ol>\n<li><p><strong>LT模式</strong>（边缘触发）：</p>\n<p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>\n</li>\n<li><p><strong>ET模式</strong>（水平触发）：</p>\n<p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>\n<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>\n</li>\n<li><p><strong>select 应用场景</strong></p>\n<p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时要求更高的场景，比如核反应堆的控制。select 可移植性更好，几乎被所有主流平台所支持。</p>\n<p><strong>只支持LT</strong></p>\n<p><strong>缺点</strong>：使用数组存文件描述符，fd_set会在用户空间和内核空间之间来回复制，监控的文件描述符数量有限</p>\n</li>\n<li><p><strong>poll 应用场景</strong></p>\n<p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且epoll 的描述符存储在内核，不容易调试。</p>\n<p><strong>只支持LT</strong></p>\n<p><strong>缺点</strong>：使用链表存文件描述符，获得文件描述符信息还是要O(n)时间复杂度遍历链表</p>\n</li>\n<li><p><strong>epoll 应用场景</strong></p>\n<p>只需要运行在 Linux 平台上，并且有非常大量的描述符需要同时轮询，而且这些连接最好是长连接。</p>\n<p><strong>支持LT和ET</strong></p>\n<p>使用红黑树存文件描述符，将就绪文件描述符添加到队列中。</p>\n</li>\n</ol>\n<h1 id=\"3-IO模型（java）\"><a href=\"#3-IO模型（java）\" class=\"headerlink\" title=\"3. IO模型（java）\"></a>3. IO模型（java）</h1><p><strong>同步与非同步：</strong>这两个概念是<code>操作系统级别</code>的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。</p>\n<p><strong>阻塞与非阻塞：</strong>这两个概念是<code>程序级别</code>的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)</p>\n<h2 id=\"3-1-BIO\"><a href=\"#3-1-BIO\" class=\"headerlink\" title=\"3.1 BIO\"></a>3.1 BIO</h2><p>传统从服务端获取连接<code>accept()</code>方法以及从从流中获取数据的<code>read()</code>都是阻塞的，这些方法的调用会导致该线程一直处于等待状态</p>\n<h2 id=\"3-2-NIO\"><a href=\"#3-2-NIO\" class=\"headerlink\" title=\"3.2 NIO\"></a>3.2 NIO</h2><h4 id=\"流和块\"><a href=\"#流和块\" class=\"headerlink\" title=\"流和块\"></a>流和块</h4><p>I&#x2F;O 与 NIO 最重要的区别是数据打包和传输的方式，I&#x2F;O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>\n<p>面向流的 I&#x2F;O 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I&#x2F;O 通常相当慢。</p>\n<p>面向块的 I&#x2F;O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I&#x2F;O 缺少一些面向流的 I&#x2F;O 所具有的优雅性和简单性。</p>\n<h4 id=\"通道与缓冲区\"><a href=\"#通道与缓冲区\" class=\"headerlink\" title=\"通道与缓冲区\"></a>通道与缓冲区</h4><ol>\n<li><p>Channel（通道）</p>\n<p>通道 Channel 是对原 I&#x2F;O 包中的流的模拟，可以通过它读取和写入数据。但是通道是双向的，不同于只能单向传输数据的InputStream或OutputStream</p>\n<p><strong>常用类</strong>：</p>\n<ul>\n<li><p>FileChannel: 从文件中读写数据；</p>\n</li>\n<li><p>DatagramChannel: 通过 UDP 读写网络中数据；</p>\n</li>\n<li><p>SocketChannel: 通过 TCP 读写网络中数据；</p>\n</li>\n<li><p>ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</p>\n</li>\n</ul>\n</li>\n<li><p>Buffer（缓冲区）</p>\n<p>使用通道交换数据时，会先经过缓冲区</p>\n<p><strong>常见类型</strong>：</p>\n<ul>\n<li>ByteBuffer</li>\n<li>CharBuffer</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"Buffer详细分析\"><a href=\"#Buffer详细分析\" class=\"headerlink\" title=\"Buffer详细分析\"></a>Buffer详细分析</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Buffer中定义的四个成员变量</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Buffer</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">mark</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">position</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> limit;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><strong>容量（<code>capacity</code>）</strong>：<code>Buffer</code>可以存储的最大数据量，<code>Buffer</code>创建时设置且不可改变；</li>\n<li><strong>界限（<code>limit</code>）</strong>：<code>Buffer</code> 中可以读&#x2F;写数据的边界。写模式下，<code>limit</code> 代表最多能写入的数据，一般等于 <code>capacity</code>（可以通过<code>limit(int newLimit)</code>方法设置）；读模式下，<code>limit</code> 等于 Buffer 中实际写入的数据大小。</li>\n<li><strong>位置（<code>position</code>）</strong>：下一个可以被读写的数据的位置（索引）。从写操作模式到读操作模式切换的时候（flip），<code>position</code> 都会归零，这样就可以从头开始读写了。</li>\n<li><strong>标记（<code>mark</code>）</strong>：<code>Buffer</code>允许将位置直接定位到该标记处，这是一个可选属性；</li>\n</ol>\n<p> <strong>两种模式</strong>：</p>\n<p>Buffer有写和读两种模式。Buffer创建出来默认是写模式，调用 <code>flip()</code> 可以切换到读模式。如果要再次切换回写模式，可以调用 <code>clear()</code> 或者 <code>compact()</code> 方法。</p>\n<p><strong>读写模式下三个成员变量之间的关系：</strong></p>\n<img src=\"/2024/09/10/java_IO/JavaNIOBuffer.png\" alt=\"JavaNIOBuffer\" style=\"zoom:100%;\">\n\n\n\n<p><strong>创建方式</strong>：</p>\n<p>不能直接通过<code>new</code>调用构造方法创建对象，只能通过静态方法实例化<code>Buffer</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以ByteBuffer为例，其他缓冲区都差不多</span></span><br><span class=\"line\"><span class=\"comment\">// 分配堆内存</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ByteBuffer <span class=\"title function_\">allocate</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 分配直接内存</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ByteBuffer <span class=\"title function_\">allocateDirect</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>常用方法</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>xxx</td>\n<td>get()</td>\n<td>读取缓冲区的数据</td>\n</tr>\n<tr>\n<td>xxxBuffer</td>\n<td>put()</td>\n<td>向缓冲区写入数据</td>\n</tr>\n<tr>\n<td>Buffer</td>\n<td>flip()</td>\n<td>将缓冲区从写模式切换到读模式，它会将 <code>limit</code> 的值设置为当前 <code>position</code> 的值，将 <code>position</code> 的值设置为 0。</td>\n</tr>\n<tr>\n<td>Buffer</td>\n<td>clear()</td>\n<td>清空缓冲区，将缓冲区从读模式切换到写模式，并将 <code>position</code> 的值设置为 0，将 <code>limit</code> 的值设置为 <code>capacity</code> 的值。</td>\n</tr>\n</tbody></table>\n<h4 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h4><p>Selector（选择器） 是 NIO 中的一个关键组件，它允许一个线程处理多个 Channel。Selector 是基于事件驱动的 I&#x2F;O 多路复用模型，主要运作原理是：通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行响应的 I&#x2F;O 操作。</p>\n<p><strong>Selector可以监听的四种数据类型</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">OP_READ</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">0</span>;    <span class=\"comment\">//表示通道准备好进行读取的事件，即有数据可读。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">OP_WRITE</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>;   <span class=\"comment\">//表示通道准备好进行写入的事件，即可以写入数据。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">OP_CONNECT</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">3</span>; <span class=\"comment\">//表示通道完成连接的事件，这通常用于 SocketChannel。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">OP_ACCEPT</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;  <span class=\"comment\">//表示通道接受连接的事件，这通常用于 ServerSocketChannel。</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">interestSet</span> <span class=\"operator\">=</span> SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>\n\n<p>一个Selector的三个Selection：</p>\n<ol>\n<li><p>所有的 <code>SelectionKey</code> 集合：代表了注册在该 Selector 上的 <code>Channel</code>，这个集合可以通过 <code>keys()</code> 方法返回。</p>\n</li>\n<li><p>被选择的 <code>SelectionKey</code> 集合：代表了所有可通过 <code>select()</code> 方法获取的、需要进行 <code>IO</code> 处理的 Channel，这个集合可以通过 <code>selectedKeys()</code> 返回。</p>\n</li>\n<li><p>被取消的 <code>SelectionKey</code> 集合：代表了所有被取消注册关系的 <code>Channel</code>，在下一次执行 <code>select()</code> 方法时，这些 <code>Channel</code> 对应的 <code>SelectionKey</code> 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//遍历选择的Channel</span></span><br><span class=\"line\">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class=\"line\">Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (keyIterator.hasNext()) &#123;</span><br><span class=\"line\">    <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> keyIterator.next();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// ServerSocketChannel 接收了一个新连接</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isConnectable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 表示一个新连接建立</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Channel 有准备好的数据，可以读取</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isWritable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Channel 有空闲的 Buffer，可以写入数据</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    keyIterator.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>select()</code>相关方法</strong></p>\n<ol>\n<li><p><code>int select()</code>：监控所有注册的 <code>Channel</code>，当它们中间有需要处理的 <code>IO</code> 操作时，该方法返回，并将对应的 <code>SelectionKey</code> 加入被选择的 <code>SelectionKey</code> 集合中，该方法返回这些 <code>Channel</code> 的数量。</p>\n</li>\n<li><p><code>int select(long timeout)</code>：可以设置超时时长的 <code>select()</code> 操作。</p>\n</li>\n<li><p><code>int selectNow()</code>：执行一个立即返回的 <code>select()</code> 操作，相对于无参数的 <code>select()</code> 方法而言，该方法不会阻塞线程。</p>\n</li>\n<li><p><code>Selector wakeup()</code>：使一个还未返回的 <code>select()</code> 方法立刻返回。</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//NIO实例</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.InetSocketAddress;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.ByteBuffer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SelectionKey;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.Selector;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.channels.SocketChannel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">NioSelectorExample</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">serverSocketChannel</span> <span class=\"operator\">=</span> ServerSocketChannel.open();</span><br><span class=\"line\">      serverSocketChannel.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\">      serverSocketChannel.socket().bind(<span class=\"keyword\">new</span> <span class=\"title class_\">InetSocketAddress</span>(<span class=\"number\">8080</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"type\">Selector</span> <span class=\"variable\">selector</span> <span class=\"operator\">=</span> Selector.open();</span><br><span class=\"line\">      <span class=\"comment\">// 将 ServerSocketChannel 注册到 Selector 并监听 OP_ACCEPT 事件</span></span><br><span class=\"line\">      serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">readyChannels</span> <span class=\"operator\">=</span> selector.select();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (readyChannels == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class=\"line\">        Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (keyIterator.hasNext()) &#123;</span><br><span class=\"line\">          <span class=\"type\">SelectionKey</span> <span class=\"variable\">key</span> <span class=\"operator\">=</span> keyIterator.next();</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (key.isAcceptable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理连接事件</span></span><br><span class=\"line\">            <span class=\"type\">ServerSocketChannel</span> <span class=\"variable\">server</span> <span class=\"operator\">=</span> (ServerSocketChannel) key.channel();</span><br><span class=\"line\">            <span class=\"type\">SocketChannel</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> server.accept();</span><br><span class=\"line\">            client.configureBlocking(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 将客户端通道注册到 Selector 并监听 OP_READ 事件</span></span><br><span class=\"line\">            client.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isReadable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理读事件</span></span><br><span class=\"line\">            <span class=\"type\">SocketChannel</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">bytesRead</span> <span class=\"operator\">=</span> client.read(buffer);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (bytesRead &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              buffer.flip();</span><br><span class=\"line\">              System.out.println(<span class=\"string\">&quot;收到数据：&quot;</span> +<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(buffer.array(), <span class=\"number\">0</span>, bytesRead));</span><br><span class=\"line\">              <span class=\"comment\">// 将客户端通道注册到 Selector 并监听 OP_WRITE 事件</span></span><br><span class=\"line\">              client.register(selector, SelectionKey.OP_WRITE);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (bytesRead &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 客户端断开连接</span></span><br><span class=\"line\">              client.close();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (key.isWritable()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 处理写事件</span></span><br><span class=\"line\">            <span class=\"type\">SocketChannel</span> <span class=\"variable\">client</span> <span class=\"operator\">=</span> (SocketChannel) key.channel();</span><br><span class=\"line\">            <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.wrap(<span class=\"string\">&quot;Hello, Client!&quot;</span>.getBytes());</span><br><span class=\"line\">            client.write(buffer);</span><br><span class=\"line\">            <span class=\"comment\">// 将客户端通道注册到 Selector 并监听 OP_READ 事件</span></span><br><span class=\"line\">            client.register(selector, SelectionKey.OP_READ);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">          keyIterator.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-零拷贝\"><a href=\"#3-3-零拷贝\" class=\"headerlink\" title=\"3.3 零拷贝\"></a>3.3 零拷贝</h2><p>零拷贝是指计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及 CPU 的拷贝时间。也就是说，零拷贝主主要解决操作系统在处理 I&#x2F;O 操作时频繁复制数据的问题。</p>\n<p>Java 对零拷贝的支持：</p>\n<ul>\n<li><code>MappedByteBuffer</code> 是 NIO 基于内存映射（<code>mmap</code>）这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 <code>mmap</code> 系统调用。它可以将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件，这样就可以直接操作内存中的数据，而不需要通过系统调用来读写文件。</li>\n<li><code>FileChannel</code> 的<code>transferTo()/transferFrom()</code>是 NIO 基于发送文件（<code>sendfile</code>）这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 <code>sendfile</code>系统调用。它可以直接将文件数据从内核发送到网络，而不需要经过用户空间的缓冲区。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">loadFileIntoMemory</span><span class=\"params\">(File xmlFile)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">  <span class=\"type\">FileInputStream</span> <span class=\"variable\">fis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(xmlFile);</span><br><span class=\"line\">  <span class=\"comment\">// 创建 FileChannel 对象</span></span><br><span class=\"line\">  <span class=\"type\">FileChannel</span> <span class=\"variable\">fc</span> <span class=\"operator\">=</span> fis.getChannel();</span><br><span class=\"line\">  <span class=\"comment\">// FileChannel.map() 将文件映射到直接内存并返回 MappedByteBuffer 对象</span></span><br><span class=\"line\">  <span class=\"type\">MappedByteBuffer</span> <span class=\"variable\">mmb</span> <span class=\"operator\">=</span> fc.map(FileChannel.MapMode.READ_ONLY, <span class=\"number\">0</span>, fc.size());</span><br><span class=\"line\">  xmlFileBuffer = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[(<span class=\"type\">int</span>)fc.size()];</span><br><span class=\"line\">  mmb.get(xmlFileBuffer);</span><br><span class=\"line\">  fis.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>\n<h2 id=\"3-4-AIO\"><a href=\"#3-4-AIO\" class=\"headerlink\" title=\"3.4 AIO\"></a>3.4 AIO</h2><p>异步IO，Linux没有这种机制的支持，只能模拟AIO，使用效率提升不大。</p>\n<h2 id=\"3-5-Reactor模型\"><a href=\"#3-5-Reactor模型\" class=\"headerlink\" title=\"3.5 Reactor模型\"></a>3.5 Reactor模型</h2><p>我们可以粗略的将网络IO过程分为以下几个部分</p>\n<ol>\n<li>连接的建立</li>\n<li>数据的接受</li>\n<li>数据的处理（数据的编解码以及业务计算）</li>\n<li>数据的发送</li>\n</ol>\n<h3 id=\"传统IO模型\"><a href=\"#传统IO模型\" class=\"headerlink\" title=\"传统IO模型\"></a>传统IO模型</h3><img src=\"/2024/09/10/java_IO/java-io-reactor-1.png\" alt=\"java-io-reactor-1\" style=\"zoom:80%;\">\n\n<p>一个线程处理一个客户端请求的全过程。由于一次请求的部分过程是不需要消耗CPU资源的（时间占比可能还挺大），所以一个线程处理一个请求的方式效率不高。</p>\n<h3 id=\"事件驱动模型\"><a href=\"#事件驱动模型\" class=\"headerlink\" title=\"事件驱动模型\"></a>事件驱动模型</h3><img src=\"/2024/09/10/java_IO/java-io-reactor-4.png\" alt=\"java-io-reactor-4\" style=\"zoom:80%;\">\n\n<p>Reactor部分分为mainReactor与subReactor</p>\n<ol>\n<li><p><strong>mainReactor</strong></p>\n<p>mainReactor主要进行客户端连接的处理，处理完成之后将该连接交由subReactor以处理客户端的网络读写。</p>\n</li>\n<li><p><strong>subReactor</strong></p>\n<p>subReactor使用一个线程池作为支撑，用多线程来处理网络读写和数据处理</p>\n</li>\n</ol>"},{"title":"ReentrantLock解析","date":"2024-10-27T11:57:10.000Z","_content":"\n多线程可以提升任务的执行效率，但是多线程由于隔离程度不够，会出现多个线程同时操作同一变量使得变量值不可控的情况，也就是线程安全问题。\n\n**线程安全问题出现的场景**：\n\n+ 多线程环境\n+ 有共享数据\n+ 有多条语句操作共享数据/单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）\n\n一般来说解决问题就是需要破坏三个条件中的一个，锁就是将多线程访问变量的过程串行化，破坏多线程环境。另外还可以通过创建副本的方法来破坏第二个条件，lua脚本将多个redis操作合并成原子操作破坏第三个条件。\n\njava中锁的实现大体分两种，分别是基于`Monitor`的`synchronized`和基于`AQS`的`ReentrantLock`，这篇文章来总结一下ReentrantLock的使用与实现。\n\n<!--more-->\n\n# 1. ReentrantLock的使用\n\n```java\npublic static void main(String[] args) {\n        ReentrantLock lock = new ReentrantLock();\n        Thread thread1 = new Thread(()->{\n            //尝试获取锁\n            if (lock.tryLock()) {\n                //获取锁成功则执行\n                lock.unlock();\n            } else {\n                // 无法获取锁时的处理逻辑\n            }\n        });\n        Thread thread2 = new Thread(()->{\n            //阻塞获取锁\n            lock.lock();\n        });\n    }\n```\n\n# 2. ReentrantLock实现原理\n\n```java\n/*\n\t实现lock接口\n*/\npublic class ReentrantLock implements Lock, java.io.Serializable {\n    private static final long serialVersionUID = 7373984872572414699L;\n    /** Synchronizer providing all implementation mechanics */\n    private final Sync sync;\n    \n}\n/**\n*\tlock接口相当于是锁的实现规范，Redisson分布式锁也实现该接口\n**/\npublic interface Lock {\n    void lock();\n    void lockInterruptibly() throws InterruptedException;\n    boolean tryLock();\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n    void unlock();\n    Condition newCondition();\n}\n/*\n*\tCondition是实现类似与Sychronized中的wait和notify机制的规范，实现依赖于LockSupport\n*/\npublic interface Condition {\n    void await() throws InterruptedException;\n    void awaitUninterruptibly();\n    long awaitNanos(long nanosTimeout) throws InterruptedException;\n    boolean await(long time, TimeUnit unit) throws InterruptedException;\n    boolean awaitUntil(Date deadline) throws InterruptedException;\n    void signal();\n    void signalAll();\n}\n```\n\n##  2.1 基础知识\n\n```java\n//加锁通过调用sync对象的lock()方法实现 \npublic void lock() {\n        sync.lock();\n    }\n//Sync内部对象是AbstractQueuedSynchronizer的实现\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    ...\n}\n```\n\n先来看看AbstractQueuedSynchronizer\n\n### 2.1.1 AQS\n\n```java\n//抽象队列同步器，是ReentrantLock实现的核心\npublic abstract class AbstractQueuedSynchronizer\n    extends AbstractOwnableSynchronizer\n    implements java.io.Serializable {\n  \n    \n    static final int WAITING   = 1;          \n    static final int CANCELLED = 0x80000000; \n    static final int COND      = 2;          \n\n    /** CLH 公平队列，用来封装任务 */\n    abstract static class Node {\n        volatile Node prev;       \n        volatile Node next;       \n        Thread waiter;            \n        volatile int status;      \n\n        \n        final boolean casPrev(Node c, Node v) {  \n            return U.weakCompareAndSetReference(this, PREV, c, v);\n        }\n        final boolean casNext(Node c, Node v) { \n            return U.weakCompareAndSetReference(this, NEXT, c, v);\n        }\n        final int getAndUnsetStatus(int v) {     \n            return U.getAndBitwiseAndInt(this, STATUS, ~v);\n        }\n        final void setPrevRelaxed(Node p) {      \n            U.putReference(this, PREV, p);\n        }\n        final void setStatusRelaxed(int s) {     \n            U.putInt(this, STATUS, s);\n        }\n        final void clearStatus() {              \n            U.putIntOpaque(this, STATUS, 0);\n        }\n\n        //获得Node对应变量的偏移量\n        private static final long STATUS\n            = U.objectFieldOffset(Node.class, \"status\");\n        private static final long NEXT\n            = U.objectFieldOffset(Node.class, \"next\");\n        private static final long PREV\n            = U.objectFieldOffset(Node.class, \"prev\");\n    }\n\n   \n    static final class ExclusiveNode extends Node { }\n    static final class SharedNode extends Node { }\n\n    static final class ConditionNode extends Node\n        implements ForkJoinPool.ManagedBlocker {\n        ConditionNode nextWaiter;            \n        \n        public final boolean isReleasable() {\n            return status <= 1 || Thread.currentThread().isInterrupted();\n        }\n\n        public final boolean block() {\n            while (!isReleasable()) LockSupport.park();\n            return true;\n        }\n    }\n\n    private transient volatile Node head;\n\n    private transient volatile Node tail;\n\n    //状态\n    private volatile int state;\n    \n     private static final Unsafe U = Unsafe.getUnsafe();\n    //获得AQS对应变量的内存偏移\n    private static final long STATE\n        = U.objectFieldOffset(AbstractQueuedSynchronizer.class, \"state\");\n    private static final long HEAD\n        = U.objectFieldOffset(AbstractQueuedSynchronizer.class, \"head\");\n    private static final long TAIL\n        = U.objectFieldOffset(AbstractQueuedSynchronizer.class, \"tail\");\n\n    //jvm静态代码块或变量在<clinit>方法中初始化，该代码主要是为了显示加载LockSupport的class文件，防止后续调用LockSupport中静态方法时加载影响效率。\n    static {\n        Class<?> ensureLoaded = LockSupport.class;\n    }\n}\n```\n\nAQS实现基于LockSupport与Unsafe类\n\n### 2.1.2 UnSafe\n\nUnSafe是java提供的用来直接操作内存的对象。操作内存显然是不安全的，所以叫UnSafe，名字起得真有艺术感。\n\n```java\npublic final class Unsafe {\n    private Unsafe() {}\n    private static final Unsafe theUnsafe = new Unsafe();\n    public static Unsafe getUnsafe() {\n        return theUnsafe;\n    }\n      @IntrinsicCandidate\n    public final native boolean compareAndSetReference(Object o, long offset,\n                                                       Object expected,\n                                                       Object x);\n    @IntrinsicCandidate\n    public final native int compareAndExchangeInt(Object o, long offset,\n                                                  int expected,\n                                                  int x);\n    \n                                                   @IntrinsicCandidate\n    public final boolean compareAndSetByte(Object o, long offset,\n                                           byte expected,\n                                           byte x) {\n        return compareAndExchangeByte(o, offset, expected, x) == expected;\n    }int x);\n    ...\n}\n```\n\n如上UnSafe类提供了一系列的CAS方法，简单看下参数。\n\n- `Object`表示属性存在的对象\n- `offset`表示属性在内存中的偏移量（可以通过api获取）\n- `expected`表示修改后的期望值\n- `x`表示修改前的值。\n- 返回值为boolean类型表示CAS修改是否成功。\n\n### 2.1.3 LockSupport\n\n```java\npublic class LockSupport {\n    //私有构造函数，对外都是静态方法，和上面提前加载class文件相对应\n    private LockSupport() {} \n    private static void setBlocker(Thread t, Object arg) {\n        U.putReferenceOpaque(t, PARKBLOCKER, arg);\n    }\n    //作用和方法名一样: 阻塞线程获取许可证，有许可证则直接通行\n    public static void park() {\n        U.park(false, 0L);\n    }\n   //重载方法, blocker表示阻塞该线程的对象或者原因，用于调试不影响主体功能。\n    public static void park(Object blocker) {\n        Thread t = Thread.currentThread();\n        setBlocker(t, blocker);\n        U.park(false, 0L);\n        setBlocker(t, null);\n    }\n    //给某个线程发许可证\n     public static void unpark(Thread thread) {\n        if (thread != null)\n            U.unpark(thread);\n    }\n}\n```\n\nLockSupport主要是通过`park()`和`unpark()`实现阻塞和唤醒的过程，`park()`方法提供了许多重载，包括设置阻塞器、阻塞时间等，底层调用的UnSafe类的native()方法。\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread(Thread.currentThread());\n        myThread.start();\n        try {\n            // 主线程睡眠3s\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"before park\");\n        // 获取许可\n        LockSupport.park(\"ParkAndUnparkDemo\");\n        System.out.println(\"after park\");\n    }\n}\nclass MyThread extends Thread {\n    private Object object;\n\n    public MyThread(Object object) {\n        this.object = object;\n    }\n\n    public void run() {\n        System.out.println(\"before unpark\");\n        // 释放许可\n        LockSupport.unpark((Thread) object);\n        System.out.println(\"after unpark\");\n    }\n}\n```\n\n### 2.2.4 常见问题\n\nLockSupport与Object中wait()和notify()区别\n\n1. **实现依赖不同**：Object中wait()和notify()基于JVM Monitor机制，LockSupport基于UnSafe类的CAS\n\n2. **功能不同**\n\n   - LockSupport更加灵活，可以先unpark()再park()。Object是等待唤醒机制，只能先wait再notify()。\n\n   - Object中wait()会释放资源并加入队列，LockSupport中park()只会一直阻塞（释放资源交给Condition await实现）\n\n\n\n","source":"_posts/java两锁之一的ReentrantLock.md","raw":"---\ntitle: ReentrantLock解析\ndate: 2024-10-27 19:57:10\ntags:\n   - java锁\ncategories:\n   - 后端开发\n---\n\n多线程可以提升任务的执行效率，但是多线程由于隔离程度不够，会出现多个线程同时操作同一变量使得变量值不可控的情况，也就是线程安全问题。\n\n**线程安全问题出现的场景**：\n\n+ 多线程环境\n+ 有共享数据\n+ 有多条语句操作共享数据/单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）\n\n一般来说解决问题就是需要破坏三个条件中的一个，锁就是将多线程访问变量的过程串行化，破坏多线程环境。另外还可以通过创建副本的方法来破坏第二个条件，lua脚本将多个redis操作合并成原子操作破坏第三个条件。\n\njava中锁的实现大体分两种，分别是基于`Monitor`的`synchronized`和基于`AQS`的`ReentrantLock`，这篇文章来总结一下ReentrantLock的使用与实现。\n\n<!--more-->\n\n# 1. ReentrantLock的使用\n\n```java\npublic static void main(String[] args) {\n        ReentrantLock lock = new ReentrantLock();\n        Thread thread1 = new Thread(()->{\n            //尝试获取锁\n            if (lock.tryLock()) {\n                //获取锁成功则执行\n                lock.unlock();\n            } else {\n                // 无法获取锁时的处理逻辑\n            }\n        });\n        Thread thread2 = new Thread(()->{\n            //阻塞获取锁\n            lock.lock();\n        });\n    }\n```\n\n# 2. ReentrantLock实现原理\n\n```java\n/*\n\t实现lock接口\n*/\npublic class ReentrantLock implements Lock, java.io.Serializable {\n    private static final long serialVersionUID = 7373984872572414699L;\n    /** Synchronizer providing all implementation mechanics */\n    private final Sync sync;\n    \n}\n/**\n*\tlock接口相当于是锁的实现规范，Redisson分布式锁也实现该接口\n**/\npublic interface Lock {\n    void lock();\n    void lockInterruptibly() throws InterruptedException;\n    boolean tryLock();\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n    void unlock();\n    Condition newCondition();\n}\n/*\n*\tCondition是实现类似与Sychronized中的wait和notify机制的规范，实现依赖于LockSupport\n*/\npublic interface Condition {\n    void await() throws InterruptedException;\n    void awaitUninterruptibly();\n    long awaitNanos(long nanosTimeout) throws InterruptedException;\n    boolean await(long time, TimeUnit unit) throws InterruptedException;\n    boolean awaitUntil(Date deadline) throws InterruptedException;\n    void signal();\n    void signalAll();\n}\n```\n\n##  2.1 基础知识\n\n```java\n//加锁通过调用sync对象的lock()方法实现 \npublic void lock() {\n        sync.lock();\n    }\n//Sync内部对象是AbstractQueuedSynchronizer的实现\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    ...\n}\n```\n\n先来看看AbstractQueuedSynchronizer\n\n### 2.1.1 AQS\n\n```java\n//抽象队列同步器，是ReentrantLock实现的核心\npublic abstract class AbstractQueuedSynchronizer\n    extends AbstractOwnableSynchronizer\n    implements java.io.Serializable {\n  \n    \n    static final int WAITING   = 1;          \n    static final int CANCELLED = 0x80000000; \n    static final int COND      = 2;          \n\n    /** CLH 公平队列，用来封装任务 */\n    abstract static class Node {\n        volatile Node prev;       \n        volatile Node next;       \n        Thread waiter;            \n        volatile int status;      \n\n        \n        final boolean casPrev(Node c, Node v) {  \n            return U.weakCompareAndSetReference(this, PREV, c, v);\n        }\n        final boolean casNext(Node c, Node v) { \n            return U.weakCompareAndSetReference(this, NEXT, c, v);\n        }\n        final int getAndUnsetStatus(int v) {     \n            return U.getAndBitwiseAndInt(this, STATUS, ~v);\n        }\n        final void setPrevRelaxed(Node p) {      \n            U.putReference(this, PREV, p);\n        }\n        final void setStatusRelaxed(int s) {     \n            U.putInt(this, STATUS, s);\n        }\n        final void clearStatus() {              \n            U.putIntOpaque(this, STATUS, 0);\n        }\n\n        //获得Node对应变量的偏移量\n        private static final long STATUS\n            = U.objectFieldOffset(Node.class, \"status\");\n        private static final long NEXT\n            = U.objectFieldOffset(Node.class, \"next\");\n        private static final long PREV\n            = U.objectFieldOffset(Node.class, \"prev\");\n    }\n\n   \n    static final class ExclusiveNode extends Node { }\n    static final class SharedNode extends Node { }\n\n    static final class ConditionNode extends Node\n        implements ForkJoinPool.ManagedBlocker {\n        ConditionNode nextWaiter;            \n        \n        public final boolean isReleasable() {\n            return status <= 1 || Thread.currentThread().isInterrupted();\n        }\n\n        public final boolean block() {\n            while (!isReleasable()) LockSupport.park();\n            return true;\n        }\n    }\n\n    private transient volatile Node head;\n\n    private transient volatile Node tail;\n\n    //状态\n    private volatile int state;\n    \n     private static final Unsafe U = Unsafe.getUnsafe();\n    //获得AQS对应变量的内存偏移\n    private static final long STATE\n        = U.objectFieldOffset(AbstractQueuedSynchronizer.class, \"state\");\n    private static final long HEAD\n        = U.objectFieldOffset(AbstractQueuedSynchronizer.class, \"head\");\n    private static final long TAIL\n        = U.objectFieldOffset(AbstractQueuedSynchronizer.class, \"tail\");\n\n    //jvm静态代码块或变量在<clinit>方法中初始化，该代码主要是为了显示加载LockSupport的class文件，防止后续调用LockSupport中静态方法时加载影响效率。\n    static {\n        Class<?> ensureLoaded = LockSupport.class;\n    }\n}\n```\n\nAQS实现基于LockSupport与Unsafe类\n\n### 2.1.2 UnSafe\n\nUnSafe是java提供的用来直接操作内存的对象。操作内存显然是不安全的，所以叫UnSafe，名字起得真有艺术感。\n\n```java\npublic final class Unsafe {\n    private Unsafe() {}\n    private static final Unsafe theUnsafe = new Unsafe();\n    public static Unsafe getUnsafe() {\n        return theUnsafe;\n    }\n      @IntrinsicCandidate\n    public final native boolean compareAndSetReference(Object o, long offset,\n                                                       Object expected,\n                                                       Object x);\n    @IntrinsicCandidate\n    public final native int compareAndExchangeInt(Object o, long offset,\n                                                  int expected,\n                                                  int x);\n    \n                                                   @IntrinsicCandidate\n    public final boolean compareAndSetByte(Object o, long offset,\n                                           byte expected,\n                                           byte x) {\n        return compareAndExchangeByte(o, offset, expected, x) == expected;\n    }int x);\n    ...\n}\n```\n\n如上UnSafe类提供了一系列的CAS方法，简单看下参数。\n\n- `Object`表示属性存在的对象\n- `offset`表示属性在内存中的偏移量（可以通过api获取）\n- `expected`表示修改后的期望值\n- `x`表示修改前的值。\n- 返回值为boolean类型表示CAS修改是否成功。\n\n### 2.1.3 LockSupport\n\n```java\npublic class LockSupport {\n    //私有构造函数，对外都是静态方法，和上面提前加载class文件相对应\n    private LockSupport() {} \n    private static void setBlocker(Thread t, Object arg) {\n        U.putReferenceOpaque(t, PARKBLOCKER, arg);\n    }\n    //作用和方法名一样: 阻塞线程获取许可证，有许可证则直接通行\n    public static void park() {\n        U.park(false, 0L);\n    }\n   //重载方法, blocker表示阻塞该线程的对象或者原因，用于调试不影响主体功能。\n    public static void park(Object blocker) {\n        Thread t = Thread.currentThread();\n        setBlocker(t, blocker);\n        U.park(false, 0L);\n        setBlocker(t, null);\n    }\n    //给某个线程发许可证\n     public static void unpark(Thread thread) {\n        if (thread != null)\n            U.unpark(thread);\n    }\n}\n```\n\nLockSupport主要是通过`park()`和`unpark()`实现阻塞和唤醒的过程，`park()`方法提供了许多重载，包括设置阻塞器、阻塞时间等，底层调用的UnSafe类的native()方法。\n\n```java\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        MyThread myThread = new MyThread(Thread.currentThread());\n        myThread.start();\n        try {\n            // 主线程睡眠3s\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"before park\");\n        // 获取许可\n        LockSupport.park(\"ParkAndUnparkDemo\");\n        System.out.println(\"after park\");\n    }\n}\nclass MyThread extends Thread {\n    private Object object;\n\n    public MyThread(Object object) {\n        this.object = object;\n    }\n\n    public void run() {\n        System.out.println(\"before unpark\");\n        // 释放许可\n        LockSupport.unpark((Thread) object);\n        System.out.println(\"after unpark\");\n    }\n}\n```\n\n### 2.2.4 常见问题\n\nLockSupport与Object中wait()和notify()区别\n\n1. **实现依赖不同**：Object中wait()和notify()基于JVM Monitor机制，LockSupport基于UnSafe类的CAS\n\n2. **功能不同**\n\n   - LockSupport更加灵活，可以先unpark()再park()。Object是等待唤醒机制，只能先wait再notify()。\n\n   - Object中wait()会释放资源并加入队列，LockSupport中park()只会一直阻塞（释放资源交给Condition await实现）\n\n\n\n","slug":"java两锁之一的ReentrantLock","published":1,"updated":"2024-10-28T14:24:53.074Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6bo000lskuse0vr00hg","content":"<p>多线程可以提升任务的执行效率，但是多线程由于隔离程度不够，会出现多个线程同时操作同一变量使得变量值不可控的情况，也就是线程安全问题。</p>\n<p><strong>线程安全问题出现的场景</strong>：</p>\n<ul>\n<li>多线程环境</li>\n<li>有共享数据</li>\n<li>有多条语句操作共享数据&#x2F;单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）</li>\n</ul>\n<p>一般来说解决问题就是需要破坏三个条件中的一个，锁就是将多线程访问变量的过程串行化，破坏多线程环境。另外还可以通过创建副本的方法来破坏第二个条件，lua脚本将多个redis操作合并成原子操作破坏第三个条件。</p>\n<p>java中锁的实现大体分两种，分别是基于<code>Monitor</code>的<code>synchronized</code>和基于<code>AQS</code>的<code>ReentrantLock</code>，这篇文章来总结一下ReentrantLock的使用与实现。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"1-ReentrantLock的使用\"><a href=\"#1-ReentrantLock的使用\" class=\"headerlink\" title=\"1. ReentrantLock的使用\"></a>1. ReentrantLock的使用</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"comment\">//尝试获取锁</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lock.tryLock()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//获取锁成功则执行</span></span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 无法获取锁时的处理逻辑</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"comment\">//阻塞获取锁</span></span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-ReentrantLock实现原理\"><a href=\"#2-ReentrantLock实现原理\" class=\"headerlink\" title=\"2. ReentrantLock实现原理\"></a>2. ReentrantLock实现原理</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t实现lock接口</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Lock</span>, java.io.Serializable &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">7373984872572414699L</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** Synchronizer providing all implementation mechanics */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*\tlock接口相当于是锁的实现规范，Redisson分布式锁也实现该接口</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Lock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Condition <span class=\"title function_\">newCondition</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">*\tCondition是实现类似与Sychronized中的wait和notify机制的规范，实现依赖于LockSupport</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Condition</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">awaitUninterruptibly</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">awaitNanos</span><span class=\"params\">(<span class=\"type\">long</span> nanosTimeout)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">awaitUntil</span><span class=\"params\">(Date deadline)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">signal</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">signalAll</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-1-基础知识\"><a href=\"#2-1-基础知识\" class=\"headerlink\" title=\"2.1 基础知识\"></a>2.1 基础知识</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加锁通过调用sync对象的lock()方法实现 </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        sync.lock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//Sync内部对象是AbstractQueuedSynchronizer的实现</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractQueuedSynchronizer</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先来看看AbstractQueuedSynchronizer</p>\n<h3 id=\"2-1-1-AQS\"><a href=\"#2-1-1-AQS\" class=\"headerlink\" title=\"2.1.1 AQS\"></a>2.1.1 AQS</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抽象队列同步器，是ReentrantLock实现的核心</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractQueuedSynchronizer</span></span><br><span class=\"line\">    <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractOwnableSynchronizer</span></span><br><span class=\"line\">    <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">WAITING</span>   <span class=\"operator\">=</span> <span class=\"number\">1</span>;          </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CANCELLED</span> <span class=\"operator\">=</span> <span class=\"number\">0x80000000</span>; </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">COND</span>      <span class=\"operator\">=</span> <span class=\"number\">2</span>;          </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** CLH 公平队列，用来封装任务 */</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> Node prev;       </span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> Node next;       </span><br><span class=\"line\">        Thread waiter;            </span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> status;      </span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">casPrev</span><span class=\"params\">(Node c, Node v)</span> &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> U.weakCompareAndSetReference(<span class=\"built_in\">this</span>, PREV, c, v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">casNext</span><span class=\"params\">(Node c, Node v)</span> &#123; </span><br><span class=\"line\">            <span class=\"keyword\">return</span> U.weakCompareAndSetReference(<span class=\"built_in\">this</span>, NEXT, c, v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">getAndUnsetStatus</span><span class=\"params\">(<span class=\"type\">int</span> v)</span> &#123;     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> U.getAndBitwiseAndInt(<span class=\"built_in\">this</span>, STATUS, ~v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setPrevRelaxed</span><span class=\"params\">(Node p)</span> &#123;      </span><br><span class=\"line\">            U.putReference(<span class=\"built_in\">this</span>, PREV, p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setStatusRelaxed</span><span class=\"params\">(<span class=\"type\">int</span> s)</span> &#123;     </span><br><span class=\"line\">            U.putInt(<span class=\"built_in\">this</span>, STATUS, s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearStatus</span><span class=\"params\">()</span> &#123;              </span><br><span class=\"line\">            U.putIntOpaque(<span class=\"built_in\">this</span>, STATUS, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//获得Node对应变量的偏移量</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">STATUS</span></span><br><span class=\"line\">            <span class=\"operator\">=</span> U.objectFieldOffset(Node.class, <span class=\"string\">&quot;status&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">NEXT</span></span><br><span class=\"line\">            <span class=\"operator\">=</span> U.objectFieldOffset(Node.class, <span class=\"string\">&quot;next&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">PREV</span></span><br><span class=\"line\">            <span class=\"operator\">=</span> U.objectFieldOffset(Node.class, <span class=\"string\">&quot;prev&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExclusiveNode</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Node</span> &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SharedNode</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Node</span> &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConditionNode</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Node</span></span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">ForkJoinPool</span>.ManagedBlocker &#123;</span><br><span class=\"line\">        ConditionNode nextWaiter;            </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isReleasable</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> status &lt;= <span class=\"number\">1</span> || Thread.currentThread().isInterrupted();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">block</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!isReleasable()) LockSupport.park();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//状态</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> state;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Unsafe</span> <span class=\"variable\">U</span> <span class=\"operator\">=</span> Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"comment\">//获得AQS对应变量的内存偏移</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">STATE</span></span><br><span class=\"line\">        <span class=\"operator\">=</span> U.objectFieldOffset(AbstractQueuedSynchronizer.class, <span class=\"string\">&quot;state&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">HEAD</span></span><br><span class=\"line\">        <span class=\"operator\">=</span> U.objectFieldOffset(AbstractQueuedSynchronizer.class, <span class=\"string\">&quot;head&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">TAIL</span></span><br><span class=\"line\">        <span class=\"operator\">=</span> U.objectFieldOffset(AbstractQueuedSynchronizer.class, <span class=\"string\">&quot;tail&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//jvm静态代码块或变量在&lt;clinit&gt;方法中初始化，该代码主要是为了显示加载LockSupport的class文件，防止后续调用LockSupport中静态方法时加载影响效率。</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        Class&lt;?&gt; ensureLoaded = LockSupport.class;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AQS实现基于LockSupport与Unsafe类</p>\n<h3 id=\"2-1-2-UnSafe\"><a href=\"#2-1-2-UnSafe\" class=\"headerlink\" title=\"2.1.2 UnSafe\"></a>2.1.2 UnSafe</h3><p>UnSafe是java提供的用来直接操作内存的对象。操作内存显然是不安全的，所以叫UnSafe，名字起得真有艺术感。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Unsafe</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Unsafe</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Unsafe</span> <span class=\"variable\">theUnsafe</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Unsafe</span>();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Unsafe <span class=\"title function_\">getUnsafe</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> theUnsafe;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      <span class=\"meta\">@IntrinsicCandidate</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSetReference</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,</span></span><br><span class=\"line\"><span class=\"params\">                                                       Object expected,</span></span><br><span class=\"line\"><span class=\"params\">                                                       Object x)</span>;</span><br><span class=\"line\">    <span class=\"meta\">@IntrinsicCandidate</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">compareAndExchangeInt</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,</span></span><br><span class=\"line\"><span class=\"params\">                                                  <span class=\"type\">int</span> expected,</span></span><br><span class=\"line\"><span class=\"params\">                                                  <span class=\"type\">int</span> x)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">                                                   <span class=\"meta\">@IntrinsicCandidate</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSetByte</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,</span></span><br><span class=\"line\"><span class=\"params\">                                           <span class=\"type\">byte</span> expected,</span></span><br><span class=\"line\"><span class=\"params\">                                           <span class=\"type\">byte</span> x)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compareAndExchangeByte(o, offset, expected, x) == expected;</span><br><span class=\"line\">    &#125;<span class=\"type\">int</span> x);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上UnSafe类提供了一系列的CAS方法，简单看下参数。</p>\n<ul>\n<li><code>Object</code>表示属性存在的对象</li>\n<li><code>offset</code>表示属性在内存中的偏移量（可以通过api获取）</li>\n<li><code>expected</code>表示修改后的期望值</li>\n<li><code>x</code>表示修改前的值。</li>\n<li>返回值为boolean类型表示CAS修改是否成功。</li>\n</ul>\n<h3 id=\"2-1-3-LockSupport\"><a href=\"#2-1-3-LockSupport\" class=\"headerlink\" title=\"2.1.3 LockSupport\"></a>2.1.3 LockSupport</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockSupport</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//私有构造函数，对外都是静态方法，和上面提前加载class文件相对应</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">LockSupport</span><span class=\"params\">()</span> &#123;&#125; </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setBlocker</span><span class=\"params\">(Thread t, Object arg)</span> &#123;</span><br><span class=\"line\">        U.putReferenceOpaque(t, PARKBLOCKER, arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//作用和方法名一样: 阻塞线程获取许可证，有许可证则直接通行</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">park</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        U.park(<span class=\"literal\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//重载方法, blocker表示阻塞该线程的对象或者原因，用于调试不影响主体功能。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">park</span><span class=\"params\">(Object blocker)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">        setBlocker(t, blocker);</span><br><span class=\"line\">        U.park(<span class=\"literal\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">        setBlocker(t, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//给某个线程发许可证</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unpark</span><span class=\"params\">(Thread thread)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (thread != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            U.unpark(thread);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>LockSupport主要是通过<code>park()</code>和<code>unpark()</code>实现阻塞和唤醒的过程，<code>park()</code>方法提供了许多重载，包括设置阻塞器、阻塞时间等，底层调用的UnSafe类的native()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>(Thread.currentThread());</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 主线程睡眠3s</span></span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before park&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取许可</span></span><br><span class=\"line\">        LockSupport.park(<span class=\"string\">&quot;ParkAndUnparkDemo&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after park&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object object;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyThread</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.object = object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before unpark&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 释放许可</span></span><br><span class=\"line\">        LockSupport.unpark((Thread) object);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after unpark&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-4-常见问题\"><a href=\"#2-2-4-常见问题\" class=\"headerlink\" title=\"2.2.4 常见问题\"></a>2.2.4 常见问题</h3><p>LockSupport与Object中wait()和notify()区别</p>\n<ol>\n<li><p><strong>实现依赖不同</strong>：Object中wait()和notify()基于JVM Monitor机制，LockSupport基于UnSafe类的CAS</p>\n</li>\n<li><p><strong>功能不同</strong></p>\n<ul>\n<li><p>LockSupport更加灵活，可以先unpark()再park()。Object是等待唤醒机制，只能先wait再notify()。</p>\n</li>\n<li><p>Object中wait()会释放资源并加入队列，LockSupport中park()只会一直阻塞（释放资源交给Condition await实现）</p>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"length":1392,"excerpt":"<p>多线程可以提升任务的执行效率，但是多线程由于隔离程度不够，会出现多个线程同时操作同一变量使得变量值不可控的情况，也就是线程安全问题。</p>\n<p><strong>线程安全问题出现的场景</strong>：</p>\n<ul>\n<li>多线程环境</li>\n<li>有共享数据</li>\n<li>有多条语句操作共享数据&#x2F;单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）</li>\n</ul>\n<p>一般来说解决问题就是需要破坏三个条件中的一个，锁就是将多线程访问变量的过程串行化，破坏多线程环境。另外还可以通过创建副本的方法来破坏第二个条件，lua脚本将多个redis操作合并成原子操作破坏第三个条件。</p>\n<p>java中锁的实现大体分两种，分别是基于<code>Monitor</code>的<code>synchronized</code>和基于<code>AQS</code>的<code>ReentrantLock</code>，这篇文章来总结一下ReentrantLock的使用与实现。</p>","more":"<h1 id=\"1-ReentrantLock的使用\"><a href=\"#1-ReentrantLock的使用\" class=\"headerlink\" title=\"1. ReentrantLock的使用\"></a>1. ReentrantLock的使用</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ReentrantLock</span> <span class=\"variable\">lock</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ReentrantLock</span>();</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"comment\">//尝试获取锁</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lock.tryLock()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//获取锁成功则执行</span></span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 无法获取锁时的处理逻辑</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">thread2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">            <span class=\"comment\">//阻塞获取锁</span></span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-ReentrantLock实现原理\"><a href=\"#2-ReentrantLock实现原理\" class=\"headerlink\" title=\"2. ReentrantLock实现原理\"></a>2. ReentrantLock实现原理</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t实现lock接口</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Lock</span>, java.io.Serializable &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">7373984872572414699L</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** Synchronizer providing all implementation mechanics */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*\tlock接口相当于是锁的实现规范，Redisson分布式锁也实现该接口</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Lock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">tryLock</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">unlock</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    Condition <span class=\"title function_\">newCondition</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">*\tCondition是实现类似与Sychronized中的wait和notify机制的规范，实现依赖于LockSupport</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Condition</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">awaitUninterruptibly</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">awaitNanos</span><span class=\"params\">(<span class=\"type\">long</span> nanosTimeout)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">awaitUntil</span><span class=\"params\">(Date deadline)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">signal</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">signalAll</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-1-基础知识\"><a href=\"#2-1-基础知识\" class=\"headerlink\" title=\"2.1 基础知识\"></a>2.1 基础知识</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//加锁通过调用sync对象的lock()方法实现 </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        sync.lock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//Sync内部对象是AbstractQueuedSynchronizer的实现</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractQueuedSynchronizer</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先来看看AbstractQueuedSynchronizer</p>\n<h3 id=\"2-1-1-AQS\"><a href=\"#2-1-1-AQS\" class=\"headerlink\" title=\"2.1.1 AQS\"></a>2.1.1 AQS</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抽象队列同步器，是ReentrantLock实现的核心</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AbstractQueuedSynchronizer</span></span><br><span class=\"line\">    <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractOwnableSynchronizer</span></span><br><span class=\"line\">    <span class=\"keyword\">implements</span> <span class=\"title class_\">java</span>.io.Serializable &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">WAITING</span>   <span class=\"operator\">=</span> <span class=\"number\">1</span>;          </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">CANCELLED</span> <span class=\"operator\">=</span> <span class=\"number\">0x80000000</span>; </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">COND</span>      <span class=\"operator\">=</span> <span class=\"number\">2</span>;          </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** CLH 公平队列，用来封装任务 */</span></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> Node prev;       </span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> Node next;       </span><br><span class=\"line\">        Thread waiter;            </span><br><span class=\"line\">        <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> status;      </span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">casPrev</span><span class=\"params\">(Node c, Node v)</span> &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> U.weakCompareAndSetReference(<span class=\"built_in\">this</span>, PREV, c, v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">casNext</span><span class=\"params\">(Node c, Node v)</span> &#123; </span><br><span class=\"line\">            <span class=\"keyword\">return</span> U.weakCompareAndSetReference(<span class=\"built_in\">this</span>, NEXT, c, v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"title function_\">getAndUnsetStatus</span><span class=\"params\">(<span class=\"type\">int</span> v)</span> &#123;     </span><br><span class=\"line\">            <span class=\"keyword\">return</span> U.getAndBitwiseAndInt(<span class=\"built_in\">this</span>, STATUS, ~v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setPrevRelaxed</span><span class=\"params\">(Node p)</span> &#123;      </span><br><span class=\"line\">            U.putReference(<span class=\"built_in\">this</span>, PREV, p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setStatusRelaxed</span><span class=\"params\">(<span class=\"type\">int</span> s)</span> &#123;     </span><br><span class=\"line\">            U.putInt(<span class=\"built_in\">this</span>, STATUS, s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title function_\">clearStatus</span><span class=\"params\">()</span> &#123;              </span><br><span class=\"line\">            U.putIntOpaque(<span class=\"built_in\">this</span>, STATUS, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//获得Node对应变量的偏移量</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">STATUS</span></span><br><span class=\"line\">            <span class=\"operator\">=</span> U.objectFieldOffset(Node.class, <span class=\"string\">&quot;status&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">NEXT</span></span><br><span class=\"line\">            <span class=\"operator\">=</span> U.objectFieldOffset(Node.class, <span class=\"string\">&quot;next&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">PREV</span></span><br><span class=\"line\">            <span class=\"operator\">=</span> U.objectFieldOffset(Node.class, <span class=\"string\">&quot;prev&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ExclusiveNode</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Node</span> &#123; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SharedNode</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Node</span> &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConditionNode</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Node</span></span><br><span class=\"line\">        <span class=\"keyword\">implements</span> <span class=\"title class_\">ForkJoinPool</span>.ManagedBlocker &#123;</span><br><span class=\"line\">        ConditionNode nextWaiter;            </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isReleasable</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> status &lt;= <span class=\"number\">1</span> || Thread.currentThread().isInterrupted();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">block</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!isReleasable()) LockSupport.park();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//状态</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> state;</span><br><span class=\"line\">    </span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Unsafe</span> <span class=\"variable\">U</span> <span class=\"operator\">=</span> Unsafe.getUnsafe();</span><br><span class=\"line\">    <span class=\"comment\">//获得AQS对应变量的内存偏移</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">STATE</span></span><br><span class=\"line\">        <span class=\"operator\">=</span> U.objectFieldOffset(AbstractQueuedSynchronizer.class, <span class=\"string\">&quot;state&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">HEAD</span></span><br><span class=\"line\">        <span class=\"operator\">=</span> U.objectFieldOffset(AbstractQueuedSynchronizer.class, <span class=\"string\">&quot;head&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">TAIL</span></span><br><span class=\"line\">        <span class=\"operator\">=</span> U.objectFieldOffset(AbstractQueuedSynchronizer.class, <span class=\"string\">&quot;tail&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//jvm静态代码块或变量在&lt;clinit&gt;方法中初始化，该代码主要是为了显示加载LockSupport的class文件，防止后续调用LockSupport中静态方法时加载影响效率。</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        Class&lt;?&gt; ensureLoaded = LockSupport.class;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>AQS实现基于LockSupport与Unsafe类</p>\n<h3 id=\"2-1-2-UnSafe\"><a href=\"#2-1-2-UnSafe\" class=\"headerlink\" title=\"2.1.2 UnSafe\"></a>2.1.2 UnSafe</h3><p>UnSafe是java提供的用来直接操作内存的对象。操作内存显然是不安全的，所以叫UnSafe，名字起得真有艺术感。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Unsafe</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Unsafe</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Unsafe</span> <span class=\"variable\">theUnsafe</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Unsafe</span>();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Unsafe <span class=\"title function_\">getUnsafe</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> theUnsafe;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      <span class=\"meta\">@IntrinsicCandidate</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSetReference</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,</span></span><br><span class=\"line\"><span class=\"params\">                                                       Object expected,</span></span><br><span class=\"line\"><span class=\"params\">                                                       Object x)</span>;</span><br><span class=\"line\">    <span class=\"meta\">@IntrinsicCandidate</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">native</span> <span class=\"type\">int</span> <span class=\"title function_\">compareAndExchangeInt</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,</span></span><br><span class=\"line\"><span class=\"params\">                                                  <span class=\"type\">int</span> expected,</span></span><br><span class=\"line\"><span class=\"params\">                                                  <span class=\"type\">int</span> x)</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">                                                   <span class=\"meta\">@IntrinsicCandidate</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compareAndSetByte</span><span class=\"params\">(Object o, <span class=\"type\">long</span> offset,</span></span><br><span class=\"line\"><span class=\"params\">                                           <span class=\"type\">byte</span> expected,</span></span><br><span class=\"line\"><span class=\"params\">                                           <span class=\"type\">byte</span> x)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compareAndExchangeByte(o, offset, expected, x) == expected;</span><br><span class=\"line\">    &#125;<span class=\"type\">int</span> x);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上UnSafe类提供了一系列的CAS方法，简单看下参数。</p>\n<ul>\n<li><code>Object</code>表示属性存在的对象</li>\n<li><code>offset</code>表示属性在内存中的偏移量（可以通过api获取）</li>\n<li><code>expected</code>表示修改后的期望值</li>\n<li><code>x</code>表示修改前的值。</li>\n<li>返回值为boolean类型表示CAS修改是否成功。</li>\n</ul>\n<h3 id=\"2-1-3-LockSupport\"><a href=\"#2-1-3-LockSupport\" class=\"headerlink\" title=\"2.1.3 LockSupport\"></a>2.1.3 LockSupport</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LockSupport</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//私有构造函数，对外都是静态方法，和上面提前加载class文件相对应</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">LockSupport</span><span class=\"params\">()</span> &#123;&#125; </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setBlocker</span><span class=\"params\">(Thread t, Object arg)</span> &#123;</span><br><span class=\"line\">        U.putReferenceOpaque(t, PARKBLOCKER, arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//作用和方法名一样: 阻塞线程获取许可证，有许可证则直接通行</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">park</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        U.park(<span class=\"literal\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"comment\">//重载方法, blocker表示阻塞该线程的对象或者原因，用于调试不影响主体功能。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">park</span><span class=\"params\">(Object blocker)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">        setBlocker(t, blocker);</span><br><span class=\"line\">        U.park(<span class=\"literal\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">        setBlocker(t, <span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//给某个线程发许可证</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">unpark</span><span class=\"params\">(Thread thread)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (thread != <span class=\"literal\">null</span>)</span><br><span class=\"line\">            U.unpark(thread);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>LockSupport主要是通过<code>park()</code>和<code>unpark()</code>实现阻塞和唤醒的过程，<code>park()</code>方法提供了许多重载，包括设置阻塞器、阻塞时间等，底层调用的UnSafe类的native()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">MyThread</span> <span class=\"variable\">myThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MyThread</span>(Thread.currentThread());</span><br><span class=\"line\">        myThread.start();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 主线程睡眠3s</span></span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before park&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取许可</span></span><br><span class=\"line\">        LockSupport.park(<span class=\"string\">&quot;ParkAndUnparkDemo&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after park&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object object;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyThread</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.object = object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before unpark&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 释放许可</span></span><br><span class=\"line\">        LockSupport.unpark((Thread) object);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after unpark&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-4-常见问题\"><a href=\"#2-2-4-常见问题\" class=\"headerlink\" title=\"2.2.4 常见问题\"></a>2.2.4 常见问题</h3><p>LockSupport与Object中wait()和notify()区别</p>\n<ol>\n<li><p><strong>实现依赖不同</strong>：Object中wait()和notify()基于JVM Monitor机制，LockSupport基于UnSafe类的CAS</p>\n</li>\n<li><p><strong>功能不同</strong></p>\n<ul>\n<li><p>LockSupport更加灵活，可以先unpark()再park()。Object是等待唤醒机制，只能先wait再notify()。</p>\n</li>\n<li><p>Object中wait()会释放资源并加入队列，LockSupport中park()只会一直阻塞（释放资源交给Condition await实现）</p>\n</li>\n</ul>\n</li>\n</ol>"},{"title":"synchronized解析","date":"2024-05-08T01:02:00.000Z","_content":"\n多线程可以提升任务的执行效率，但是多线程由于隔离程度不够，会出现多个线程同时操作同一变量使得变量值不可控的情况，也就是线程安全问题。\n\n**线程安全问题出现的场景**：\n\n+ 多线程环境\n+ 有共享数据\n+ 有多条语句操作共享数据/单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）\n\n一般来说解决问题就是需要破坏三个条件中的一个，锁就是将多线程访问变量的过程串行化，破坏多线程环境。另外还可以通过创建副本的方法来破坏第二个条件，lua脚本将多个redis操作合并成原子操作破坏第三个条件。\n\njava中锁的实现大体分两种，分别是基于`Monitor`的`synchronized`和基于`AQS`的`ReentrantLock`，这篇文章先来总结一下synchronized的使用与实现\n\n<!--more-->\n\n# 1. synchronized的使用\n\n## 1.1 经典的单例模式\n\n为了保证类只有一个实例，需要保证只有一个线程能使用Class文件创建类对象，这样就可以对`SingletonPattern.class`加锁，保证资源独享。\n\n```java\npublic class SingletonPattern {\n    //volatile 用于禁止JVM指令重排\n    public static volatile SingletonPattern INSTANCE;\n    public SingletonPattern getINSTANCE() {\n        if(INSTANCE == null){\n            synchronized (SingletonPattern.class){\n                if(INSTANCE == null){\n                    //具体的初始化逻辑\n                    INSTANCE = new SingletonPattern();\n                    try{\n                        Thread.sleep(350L);\n                    }catch (InterruptedException e){\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        return INSTANCE;\n    }\n}\n```\n\n## 1.2 用法\n\nsynchronized用法一般可以分为两大类，对方法进行同步和对代码块进行同步。\n\n1. 代码块\n\n   ```java\n   public static void main(String[] args) throws InterruptedException {\n           Object o = new Object();\n           Thread t1 = new Thread(() -> {\n               //对对象进行加锁\n               synchronized (o) {\n                   System.out.println(\"test1\");\n               }\n           });\n           Thread t2 = new Thread(() -> {\n               synchronized (o) {\n                   System.out.println(\"test2\");\n               }\n           });\n           t1.start();\n           t2.start();\n           t1.join();\n           t2.join();\n       }\n   ```\n\n   ```class\n    0 aload_0\n    1 dup\n    2 astore_1\n    3 monitorenter\n    4 getstatic #25 <java/lang/System.out : Ljava/io/PrintStream;>\n    7 ldc #39 <test2>\n    9 invokevirtual #33 <java/io/PrintStream.println : (Ljava/lang/String;)V>\n   12 aload_1\n   13 monitorexit\n   14 goto 22 (+8)\n   17 astore_2\n   18 aload_1\n   19 monitorexit\n   20 aload_2\n   21 athrow\n   22 return\n   ```\n\n   字节码可以看到代码块通过**monitorenter**和**monitorexit**来实现加锁和释放锁\n\n2. 方法\n\n   ```java\n   public static void main(String[] args) throws InterruptedException {\n           test();\n   }\n   //对方法进行加锁\n   public static synchronized void test() {\n           System.out.println(\"test1\");\n   }\n   ```\n   \n   ```java\n   //观察字节码方法同步是通过设置标志ACC_SYNCHRONIZED来实现的,(方法中没有monitorenter等同步字节码)\n   public static synchronized void test();\n       descriptor: ()V\n       flags: (0x0029) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED\n       Code:\n         stack=2, locals=0, args_size=0\n            0: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;\n            3: ldc           #18                 // String test1\n            5: invokevirtual #20                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n            8: return\n         LineNumberTable:\n           line 12: 0\n           line 13: 8\n   }\n   ```\n\n不论是代码块还是方法，synchronized同步都是针对对象进行的。代码块直接是操作对象，方法会根据是否是static方法来判断是对class对象还是实例对象进行加锁（static方法属于类而不是实例对象）。\n\n# 2. synchronized的实现\n\n## 2.1 概述\n\n**特性**：原子性、可见性、可重入性、有序性\n\nsynchronized的实现依赖于JVM，java对象在JVM中会按**对象头、实例数据和对齐填充**的形式存储，了解synchronized我们只需要关注对象头就行了。\n\n**对象头结构**：\n\n- **mark-word**：对象标记字段占 4 个字节，用于存储一些列的标记位，比如：哈希值、轻量级锁的标记位，偏向锁标记位、分代年龄等。\n\n- **Klass Pointer**：Class 对象的类型指针，Jdk1.8 默认开启指针压缩后为 4 字节，关闭指针压缩（-XX:-UseCompressedOops）后，长度为 8 字节。其指向的位置是对象对应的 Class 对象（其对应的元数据对象）的内存地址。\n\nmark-word在各锁状态的总览：\n\n<img src=\"java两锁之一的synchronized\\jvm_markWord.png\" alt=\"jvm_markWord\" />\n\nmarkWord使用3位来表示对象的五种状态（无锁，偏向锁，轻量锁，重量锁，以及 GC 标记），线程在竞争锁时会判断对象加锁情况进行竞争。\n\n## 2.2 无锁->偏向锁\n\n无锁状态时MarkWord中会存放**HashCode**、**分代年龄**等信息。当一个线程来请求获取锁时,此时MarkWord前54bit会用来表示持有该锁的线程，Epoch表示该锁的版本戳，当该线程再次来访问时可以直接访问，不需要同步。\n\nJDK15之后偏向锁就被弃用了，因为使用锁的场景大多是多个线程竞争的情况，而偏向锁的优势是**可以节省同一个线程多次请求同一锁时同步消耗的资源**，这样一来多个线程竞争时反而会因为偏向锁向轻量级锁转变造成资源的浪费。\n\nJDK8之前可以设置`-XX:-UseBiasedLocking`来禁用偏向锁，另外JVM延迟设置偏向锁，所以下面测试偏向锁需要sleep()或者`-XX:BiasedLockingStartupDelay=0`关闭延迟偏向锁\n\n```java\npublic static void main(String[] args)  throws InterruptedException{\n    TimeUnit.SECONDS.sleep(5);\n        Object o = new Object();\n        synchronized (o){\n            //打印，观察对象加锁情况\n            System.out.println(ClassLayout.parseInstance(o).toPrintable()); \n        }\n    }\n/*\n<!--查看对象头工具-->\n      <dependency>\n          <groupId>org.openjdk.jol</groupId>\n          <artifactId>jol-core</artifactId>\n          <version>0.9</version>\n          <scope>test</scope>\n      </dependency>\n*/\n```\n\n//可以看到加上参数后，对象加的是轻量级锁（观察开头4个字节最后三位，顺序是倒过来的，所以最后8位是`c8`，最后两位是00）\n\n<img src=\"java两锁之一的synchronized\\image-20240513145730228.png\" alt=\"image-20240513145730228\" />\n\n//不加参数的情况，最后三位是101，加的是偏向锁\n\n<img src=\"java两锁之一的synchronized\\image-20240513150908609.png\" alt=\"image-20240513150908609\" />\n\n## 2.3 偏向锁->轻量级锁\n\n多个线程竞争同一把锁且竞争不太激烈时，偏向锁会升级为轻量级锁（CAS自旋来获取），虚拟机会在当前线程的栈帧中创建一个LockRecord空间，储存当前锁对象的MarkWord拷贝（主要是为记录了HashCode，分代年龄等内容）。\n\n线程竞争锁时会先将MarkWord复制到栈帧中，之后**通过CAS尝试将锁对象的LockRecord指针指向栈帧中的LockRecord**，并将owner指针指向锁对象的MarkWord，CAS操作成功后将锁对象MarkWord锁字段更新为00，表示轻量级锁。CAS失败后会检查MarkWord中LockRecord指针是否指向当前线程的栈帧，如果是则表明已抢到锁，否则自旋等待。\n\n**概述**：轻量级锁抢占需要维持对象和线程的双向联系，**锁对象的LockRecord需要指向栈帧中的LockRecord**，**栈帧中的owner指针需要指向锁对象的MarkWord**。只有同时满足这两个联系，才算成功加锁。\n\n### LockRecord和owner分别是什么？\n\nLockRecord在openjdk中通过以下两个类来实现\n\n```c++\n// A BasicObjectLock associates a specific Java object with a BasicLock.\n// It is currently embedded in an interpreter frame(在栈的解释帧上分配).\nclass BasicObjectLock {\n  friend class VMStructs;\n private:\n  BasicLock _lock; // 锁\n  oop       _obj; // 持有锁的对象，owner的实现\n};\n\n\nclass BasicLock {\n private:\n  volatile markOop _displaced_header;\n};\n```\n\n当字节码解释器执行monitorenter字节码轻量地锁住一个对象时，就会在获取锁的线程的栈上显式或隐式分配一个lock record。\n\n栈帧中解释帧包含一个区域，该区域保存激活拥有的所有监视器的锁记录。在解释的方法执行期间，该区域根据持有的锁数量增长或缩小。lock record在线程的Interpretered Frame（解释帧）上分配。\n\n其实关于LockRecord只需要知道，**在轻量级锁时JVM会在栈帧中创建一个对象（对象中有着owner指针）来进行线程与加锁对象的双向关联**\n\n## 2.4 轻量级锁->重量级锁\n\n当CAS自旋达到一定次数会变成重量级锁，这时线程会进入ObjectMonitor的阻塞队列中，当锁被释放时会随机从队列中唤醒一个进程持有锁。持有锁的线程执行Object.wait()方法阻塞会转移到**WaitSet**队列，等待被notify()或notifyAll()唤醒后会进入**EntryList**中。\n\n**ObjectMonitor结构**：\n\n```java\nObjectMonitor() {\n\t_header = NULL;\n\t_count = 0; // 记录个数\n\t_waiters = 0,\n\t_recursions = 0; // 线程重入次数\n\t_object = NULL; // 存储 Monitor 对象\n\t_owner = NULL; // 持有当前线程的 owner\n\t_WaitSet = NULL; // 处于 wait 状态的线程，会被加入到 _WaitSet\n\t_WaitSetLock = 0 ;\n\t_Responsible = NULL ;\n\t_succ = NULL ;\n\t_cxq = NULL ; // 单向列表\n\tFreeNext = NULL ;\n\t_EntryList = NULL ; // 处于等待锁 block 状态的线程，会被加入到该列表\n\t_SpinFreq = 0 ;\n\t_SpinClock = 0 ;\n\tOwnerIsThread = 0 ;\n\t_previous_owner_tid = 0;\n}\n```\n\n每个对象都会关联一个ObjectMonitor，java通过ObjectMonitor来管理锁（只要有synchronized就离不开ObjectMonitor）。\n\n<img src=\"java两锁之一的synchronized\\java重量级锁.webp\" alt=\"java重量级锁\" style=\"zoom:80%;\" />\n\n**重量级锁的升级条件**：\n\n1. 从轻量级锁升级为重量级锁的条件： 自旋超过一定次数（默认10次），可以通过`-XX:PreBlockSpin`设置次数\n2. 从无锁/偏向锁直接升级为重量级锁的条件：**调用了object.wait()方法，则会直接升级为重量级锁！**\n\n\n\n\n\n","source":"_posts/java两锁之一的synchronized.md","raw":"---\ntitle: synchronized解析\ndate: 2024-05-08 09:02:00\ntags:\n   - java锁\ncategories:\n   - 后端开发\n---\n\n多线程可以提升任务的执行效率，但是多线程由于隔离程度不够，会出现多个线程同时操作同一变量使得变量值不可控的情况，也就是线程安全问题。\n\n**线程安全问题出现的场景**：\n\n+ 多线程环境\n+ 有共享数据\n+ 有多条语句操作共享数据/单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）\n\n一般来说解决问题就是需要破坏三个条件中的一个，锁就是将多线程访问变量的过程串行化，破坏多线程环境。另外还可以通过创建副本的方法来破坏第二个条件，lua脚本将多个redis操作合并成原子操作破坏第三个条件。\n\njava中锁的实现大体分两种，分别是基于`Monitor`的`synchronized`和基于`AQS`的`ReentrantLock`，这篇文章先来总结一下synchronized的使用与实现\n\n<!--more-->\n\n# 1. synchronized的使用\n\n## 1.1 经典的单例模式\n\n为了保证类只有一个实例，需要保证只有一个线程能使用Class文件创建类对象，这样就可以对`SingletonPattern.class`加锁，保证资源独享。\n\n```java\npublic class SingletonPattern {\n    //volatile 用于禁止JVM指令重排\n    public static volatile SingletonPattern INSTANCE;\n    public SingletonPattern getINSTANCE() {\n        if(INSTANCE == null){\n            synchronized (SingletonPattern.class){\n                if(INSTANCE == null){\n                    //具体的初始化逻辑\n                    INSTANCE = new SingletonPattern();\n                    try{\n                        Thread.sleep(350L);\n                    }catch (InterruptedException e){\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        return INSTANCE;\n    }\n}\n```\n\n## 1.2 用法\n\nsynchronized用法一般可以分为两大类，对方法进行同步和对代码块进行同步。\n\n1. 代码块\n\n   ```java\n   public static void main(String[] args) throws InterruptedException {\n           Object o = new Object();\n           Thread t1 = new Thread(() -> {\n               //对对象进行加锁\n               synchronized (o) {\n                   System.out.println(\"test1\");\n               }\n           });\n           Thread t2 = new Thread(() -> {\n               synchronized (o) {\n                   System.out.println(\"test2\");\n               }\n           });\n           t1.start();\n           t2.start();\n           t1.join();\n           t2.join();\n       }\n   ```\n\n   ```class\n    0 aload_0\n    1 dup\n    2 astore_1\n    3 monitorenter\n    4 getstatic #25 <java/lang/System.out : Ljava/io/PrintStream;>\n    7 ldc #39 <test2>\n    9 invokevirtual #33 <java/io/PrintStream.println : (Ljava/lang/String;)V>\n   12 aload_1\n   13 monitorexit\n   14 goto 22 (+8)\n   17 astore_2\n   18 aload_1\n   19 monitorexit\n   20 aload_2\n   21 athrow\n   22 return\n   ```\n\n   字节码可以看到代码块通过**monitorenter**和**monitorexit**来实现加锁和释放锁\n\n2. 方法\n\n   ```java\n   public static void main(String[] args) throws InterruptedException {\n           test();\n   }\n   //对方法进行加锁\n   public static synchronized void test() {\n           System.out.println(\"test1\");\n   }\n   ```\n   \n   ```java\n   //观察字节码方法同步是通过设置标志ACC_SYNCHRONIZED来实现的,(方法中没有monitorenter等同步字节码)\n   public static synchronized void test();\n       descriptor: ()V\n       flags: (0x0029) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED\n       Code:\n         stack=2, locals=0, args_size=0\n            0: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;\n            3: ldc           #18                 // String test1\n            5: invokevirtual #20                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n            8: return\n         LineNumberTable:\n           line 12: 0\n           line 13: 8\n   }\n   ```\n\n不论是代码块还是方法，synchronized同步都是针对对象进行的。代码块直接是操作对象，方法会根据是否是static方法来判断是对class对象还是实例对象进行加锁（static方法属于类而不是实例对象）。\n\n# 2. synchronized的实现\n\n## 2.1 概述\n\n**特性**：原子性、可见性、可重入性、有序性\n\nsynchronized的实现依赖于JVM，java对象在JVM中会按**对象头、实例数据和对齐填充**的形式存储，了解synchronized我们只需要关注对象头就行了。\n\n**对象头结构**：\n\n- **mark-word**：对象标记字段占 4 个字节，用于存储一些列的标记位，比如：哈希值、轻量级锁的标记位，偏向锁标记位、分代年龄等。\n\n- **Klass Pointer**：Class 对象的类型指针，Jdk1.8 默认开启指针压缩后为 4 字节，关闭指针压缩（-XX:-UseCompressedOops）后，长度为 8 字节。其指向的位置是对象对应的 Class 对象（其对应的元数据对象）的内存地址。\n\nmark-word在各锁状态的总览：\n\n<img src=\"java两锁之一的synchronized\\jvm_markWord.png\" alt=\"jvm_markWord\" />\n\nmarkWord使用3位来表示对象的五种状态（无锁，偏向锁，轻量锁，重量锁，以及 GC 标记），线程在竞争锁时会判断对象加锁情况进行竞争。\n\n## 2.2 无锁->偏向锁\n\n无锁状态时MarkWord中会存放**HashCode**、**分代年龄**等信息。当一个线程来请求获取锁时,此时MarkWord前54bit会用来表示持有该锁的线程，Epoch表示该锁的版本戳，当该线程再次来访问时可以直接访问，不需要同步。\n\nJDK15之后偏向锁就被弃用了，因为使用锁的场景大多是多个线程竞争的情况，而偏向锁的优势是**可以节省同一个线程多次请求同一锁时同步消耗的资源**，这样一来多个线程竞争时反而会因为偏向锁向轻量级锁转变造成资源的浪费。\n\nJDK8之前可以设置`-XX:-UseBiasedLocking`来禁用偏向锁，另外JVM延迟设置偏向锁，所以下面测试偏向锁需要sleep()或者`-XX:BiasedLockingStartupDelay=0`关闭延迟偏向锁\n\n```java\npublic static void main(String[] args)  throws InterruptedException{\n    TimeUnit.SECONDS.sleep(5);\n        Object o = new Object();\n        synchronized (o){\n            //打印，观察对象加锁情况\n            System.out.println(ClassLayout.parseInstance(o).toPrintable()); \n        }\n    }\n/*\n<!--查看对象头工具-->\n      <dependency>\n          <groupId>org.openjdk.jol</groupId>\n          <artifactId>jol-core</artifactId>\n          <version>0.9</version>\n          <scope>test</scope>\n      </dependency>\n*/\n```\n\n//可以看到加上参数后，对象加的是轻量级锁（观察开头4个字节最后三位，顺序是倒过来的，所以最后8位是`c8`，最后两位是00）\n\n<img src=\"java两锁之一的synchronized\\image-20240513145730228.png\" alt=\"image-20240513145730228\" />\n\n//不加参数的情况，最后三位是101，加的是偏向锁\n\n<img src=\"java两锁之一的synchronized\\image-20240513150908609.png\" alt=\"image-20240513150908609\" />\n\n## 2.3 偏向锁->轻量级锁\n\n多个线程竞争同一把锁且竞争不太激烈时，偏向锁会升级为轻量级锁（CAS自旋来获取），虚拟机会在当前线程的栈帧中创建一个LockRecord空间，储存当前锁对象的MarkWord拷贝（主要是为记录了HashCode，分代年龄等内容）。\n\n线程竞争锁时会先将MarkWord复制到栈帧中，之后**通过CAS尝试将锁对象的LockRecord指针指向栈帧中的LockRecord**，并将owner指针指向锁对象的MarkWord，CAS操作成功后将锁对象MarkWord锁字段更新为00，表示轻量级锁。CAS失败后会检查MarkWord中LockRecord指针是否指向当前线程的栈帧，如果是则表明已抢到锁，否则自旋等待。\n\n**概述**：轻量级锁抢占需要维持对象和线程的双向联系，**锁对象的LockRecord需要指向栈帧中的LockRecord**，**栈帧中的owner指针需要指向锁对象的MarkWord**。只有同时满足这两个联系，才算成功加锁。\n\n### LockRecord和owner分别是什么？\n\nLockRecord在openjdk中通过以下两个类来实现\n\n```c++\n// A BasicObjectLock associates a specific Java object with a BasicLock.\n// It is currently embedded in an interpreter frame(在栈的解释帧上分配).\nclass BasicObjectLock {\n  friend class VMStructs;\n private:\n  BasicLock _lock; // 锁\n  oop       _obj; // 持有锁的对象，owner的实现\n};\n\n\nclass BasicLock {\n private:\n  volatile markOop _displaced_header;\n};\n```\n\n当字节码解释器执行monitorenter字节码轻量地锁住一个对象时，就会在获取锁的线程的栈上显式或隐式分配一个lock record。\n\n栈帧中解释帧包含一个区域，该区域保存激活拥有的所有监视器的锁记录。在解释的方法执行期间，该区域根据持有的锁数量增长或缩小。lock record在线程的Interpretered Frame（解释帧）上分配。\n\n其实关于LockRecord只需要知道，**在轻量级锁时JVM会在栈帧中创建一个对象（对象中有着owner指针）来进行线程与加锁对象的双向关联**\n\n## 2.4 轻量级锁->重量级锁\n\n当CAS自旋达到一定次数会变成重量级锁，这时线程会进入ObjectMonitor的阻塞队列中，当锁被释放时会随机从队列中唤醒一个进程持有锁。持有锁的线程执行Object.wait()方法阻塞会转移到**WaitSet**队列，等待被notify()或notifyAll()唤醒后会进入**EntryList**中。\n\n**ObjectMonitor结构**：\n\n```java\nObjectMonitor() {\n\t_header = NULL;\n\t_count = 0; // 记录个数\n\t_waiters = 0,\n\t_recursions = 0; // 线程重入次数\n\t_object = NULL; // 存储 Monitor 对象\n\t_owner = NULL; // 持有当前线程的 owner\n\t_WaitSet = NULL; // 处于 wait 状态的线程，会被加入到 _WaitSet\n\t_WaitSetLock = 0 ;\n\t_Responsible = NULL ;\n\t_succ = NULL ;\n\t_cxq = NULL ; // 单向列表\n\tFreeNext = NULL ;\n\t_EntryList = NULL ; // 处于等待锁 block 状态的线程，会被加入到该列表\n\t_SpinFreq = 0 ;\n\t_SpinClock = 0 ;\n\tOwnerIsThread = 0 ;\n\t_previous_owner_tid = 0;\n}\n```\n\n每个对象都会关联一个ObjectMonitor，java通过ObjectMonitor来管理锁（只要有synchronized就离不开ObjectMonitor）。\n\n<img src=\"java两锁之一的synchronized\\java重量级锁.webp\" alt=\"java重量级锁\" style=\"zoom:80%;\" />\n\n**重量级锁的升级条件**：\n\n1. 从轻量级锁升级为重量级锁的条件： 自旋超过一定次数（默认10次），可以通过`-XX:PreBlockSpin`设置次数\n2. 从无锁/偏向锁直接升级为重量级锁的条件：**调用了object.wait()方法，则会直接升级为重量级锁！**\n\n\n\n\n\n","slug":"java两锁之一的synchronized","published":1,"updated":"2024-10-27T11:57:40.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6bp000oskus0e1q660q","content":"<p>多线程可以提升任务的执行效率，但是多线程由于隔离程度不够，会出现多个线程同时操作同一变量使得变量值不可控的情况，也就是线程安全问题。</p>\n<p><strong>线程安全问题出现的场景</strong>：</p>\n<ul>\n<li>多线程环境</li>\n<li>有共享数据</li>\n<li>有多条语句操作共享数据&#x2F;单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）</li>\n</ul>\n<p>一般来说解决问题就是需要破坏三个条件中的一个，锁就是将多线程访问变量的过程串行化，破坏多线程环境。另外还可以通过创建副本的方法来破坏第二个条件，lua脚本将多个redis操作合并成原子操作破坏第三个条件。</p>\n<p>java中锁的实现大体分两种，分别是基于<code>Monitor</code>的<code>synchronized</code>和基于<code>AQS</code>的<code>ReentrantLock</code>，这篇文章先来总结一下synchronized的使用与实现</p>\n<span id=\"more\"></span>\n\n<h1 id=\"1-synchronized的使用\"><a href=\"#1-synchronized的使用\" class=\"headerlink\" title=\"1. synchronized的使用\"></a>1. synchronized的使用</h1><h2 id=\"1-1-经典的单例模式\"><a href=\"#1-1-经典的单例模式\" class=\"headerlink\" title=\"1.1 经典的单例模式\"></a>1.1 经典的单例模式</h2><p>为了保证类只有一个实例，需要保证只有一个线程能使用Class文件创建类对象，这样就可以对<code>SingletonPattern.class</code>加锁，保证资源独享。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonPattern</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//volatile 用于禁止JVM指令重排</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> SingletonPattern INSTANCE;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> SingletonPattern <span class=\"title function_\">getINSTANCE</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(INSTANCE == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (SingletonPattern.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(INSTANCE == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//具体的初始化逻辑</span></span><br><span class=\"line\">                    INSTANCE = <span class=\"keyword\">new</span> <span class=\"title class_\">SingletonPattern</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                        Thread.sleep(<span class=\"number\">350L</span>);</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-用法\"><a href=\"#1-2-用法\" class=\"headerlink\" title=\"1.2 用法\"></a>1.2 用法</h2><p>synchronized用法一般可以分为两大类，对方法进行同步和对代码块进行同步。</p>\n<ol>\n<li><p>代码块</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//对对象进行加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (o) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;test1&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (o) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;test2&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t1.join();</span><br><span class=\"line\">        t2.join();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 0 aload_0</span><br><span class=\"line\"> 1 dup</span><br><span class=\"line\"> 2 astore_1</span><br><span class=\"line\"> 3 monitorenter</span><br><span class=\"line\"> 4 getstatic #25 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span><br><span class=\"line\"> 7 ldc #39 &lt;test2&gt;</span><br><span class=\"line\"> 9 invokevirtual #33 &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;</span><br><span class=\"line\">12 aload_1</span><br><span class=\"line\">13 monitorexit</span><br><span class=\"line\">14 goto 22 (+8)</span><br><span class=\"line\">17 astore_2</span><br><span class=\"line\">18 aload_1</span><br><span class=\"line\">19 monitorexit</span><br><span class=\"line\">20 aload_2</span><br><span class=\"line\">21 athrow</span><br><span class=\"line\">22 return</span><br></pre></td></tr></table></figure>\n\n<p>字节码可以看到代码块通过<strong>monitorenter</strong>和<strong>monitorexit</strong>来实现加锁和释放锁</p>\n</li>\n<li><p>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        test();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对方法进行加锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;test1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//观察字节码方法同步是通过设置标志ACC_SYNCHRONIZED来实现的,(方法中没有monitorenter等同步字节码)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0029</span>) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">0</span>, args_size=<span class=\"number\">0</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: getstatic     #<span class=\"number\">12</span>                 <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: ldc           #<span class=\"number\">18</span>                 <span class=\"comment\">// String test1</span></span><br><span class=\"line\">         <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">20</span>                 <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">12</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">13</span>: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>不论是代码块还是方法，synchronized同步都是针对对象进行的。代码块直接是操作对象，方法会根据是否是static方法来判断是对class对象还是实例对象进行加锁（static方法属于类而不是实例对象）。</p>\n<h1 id=\"2-synchronized的实现\"><a href=\"#2-synchronized的实现\" class=\"headerlink\" title=\"2. synchronized的实现\"></a>2. synchronized的实现</h1><h2 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1 概述\"></a>2.1 概述</h2><p><strong>特性</strong>：原子性、可见性、可重入性、有序性</p>\n<p>synchronized的实现依赖于JVM，java对象在JVM中会按<strong>对象头、实例数据和对齐填充</strong>的形式存储，了解synchronized我们只需要关注对象头就行了。</p>\n<p><strong>对象头结构</strong>：</p>\n<ul>\n<li><p><strong>mark-word</strong>：对象标记字段占 4 个字节，用于存储一些列的标记位，比如：哈希值、轻量级锁的标记位，偏向锁标记位、分代年龄等。</p>\n</li>\n<li><p><strong>Klass Pointer</strong>：Class 对象的类型指针，Jdk1.8 默认开启指针压缩后为 4 字节，关闭指针压缩（-XX:-UseCompressedOops）后，长度为 8 字节。其指向的位置是对象对应的 Class 对象（其对应的元数据对象）的内存地址。</p>\n</li>\n</ul>\n<p>mark-word在各锁状态的总览：</p>\n<img src=\"/2024/05/08/java%E4%B8%A4%E9%94%81%E4%B9%8B%E4%B8%80%E7%9A%84synchronized/jvm_markWord.png\" alt=\"jvm_markWord\">\n\n<p>markWord使用3位来表示对象的五种状态（无锁，偏向锁，轻量锁，重量锁，以及 GC 标记），线程在竞争锁时会判断对象加锁情况进行竞争。</p>\n<h2 id=\"2-2-无锁-偏向锁\"><a href=\"#2-2-无锁-偏向锁\" class=\"headerlink\" title=\"2.2 无锁-&gt;偏向锁\"></a>2.2 无锁-&gt;偏向锁</h2><p>无锁状态时MarkWord中会存放<strong>HashCode</strong>、<strong>分代年龄</strong>等信息。当一个线程来请求获取锁时,此时MarkWord前54bit会用来表示持有该锁的线程，Epoch表示该锁的版本戳，当该线程再次来访问时可以直接访问，不需要同步。</p>\n<p>JDK15之后偏向锁就被弃用了，因为使用锁的场景大多是多个线程竞争的情况，而偏向锁的优势是<strong>可以节省同一个线程多次请求同一锁时同步消耗的资源</strong>，这样一来多个线程竞争时反而会因为偏向锁向轻量级锁转变造成资源的浪费。</p>\n<p>JDK8之前可以设置<code>-XX:-UseBiasedLocking</code>来禁用偏向锁，另外JVM延迟设置偏向锁，所以下面测试偏向锁需要sleep()或者<code>-XX:BiasedLockingStartupDelay=0</code>关闭延迟偏向锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>  <span class=\"keyword\">throws</span> InterruptedException&#123;</span><br><span class=\"line\">    TimeUnit.SECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (o)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//打印，观察对象加锁情况</span></span><br><span class=\"line\">            System.out.println(ClassLayout.parseInstance(o).toPrintable()); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--查看对象头工具--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">      &lt;dependency&gt;</span></span><br><span class=\"line\"><span class=\"comment\">          &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span></span><br><span class=\"line\"><span class=\"comment\">          &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span></span><br><span class=\"line\"><span class=\"comment\">          &lt;version&gt;0.9&lt;/version&gt;</span></span><br><span class=\"line\"><span class=\"comment\">          &lt;scope&gt;test&lt;/scope&gt;</span></span><br><span class=\"line\"><span class=\"comment\">      &lt;/dependency&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>&#x2F;&#x2F;可以看到加上参数后，对象加的是轻量级锁（观察开头4个字节最后三位，顺序是倒过来的，所以最后8位是<code>c8</code>，最后两位是00）</p>\n<img src=\"/2024/05/08/java%E4%B8%A4%E9%94%81%E4%B9%8B%E4%B8%80%E7%9A%84synchronized/image-20240513145730228.png\" alt=\"image-20240513145730228\">\n\n<p>&#x2F;&#x2F;不加参数的情况，最后三位是101，加的是偏向锁</p>\n<img src=\"/2024/05/08/java%E4%B8%A4%E9%94%81%E4%B9%8B%E4%B8%80%E7%9A%84synchronized/image-20240513150908609.png\" alt=\"image-20240513150908609\">\n\n<h2 id=\"2-3-偏向锁-轻量级锁\"><a href=\"#2-3-偏向锁-轻量级锁\" class=\"headerlink\" title=\"2.3 偏向锁-&gt;轻量级锁\"></a>2.3 偏向锁-&gt;轻量级锁</h2><p>多个线程竞争同一把锁且竞争不太激烈时，偏向锁会升级为轻量级锁（CAS自旋来获取），虚拟机会在当前线程的栈帧中创建一个LockRecord空间，储存当前锁对象的MarkWord拷贝（主要是为记录了HashCode，分代年龄等内容）。</p>\n<p>线程竞争锁时会先将MarkWord复制到栈帧中，之后<strong>通过CAS尝试将锁对象的LockRecord指针指向栈帧中的LockRecord</strong>，并将owner指针指向锁对象的MarkWord，CAS操作成功后将锁对象MarkWord锁字段更新为00，表示轻量级锁。CAS失败后会检查MarkWord中LockRecord指针是否指向当前线程的栈帧，如果是则表明已抢到锁，否则自旋等待。</p>\n<p><strong>概述</strong>：轻量级锁抢占需要维持对象和线程的双向联系，<strong>锁对象的LockRecord需要指向栈帧中的LockRecord</strong>，<strong>栈帧中的owner指针需要指向锁对象的MarkWord</strong>。只有同时满足这两个联系，才算成功加锁。</p>\n<h3 id=\"LockRecord和owner分别是什么？\"><a href=\"#LockRecord和owner分别是什么？\" class=\"headerlink\" title=\"LockRecord和owner分别是什么？\"></a>LockRecord和owner分别是什么？</h3><p>LockRecord在openjdk中通过以下两个类来实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A BasicObjectLock associates a specific Java object with a BasicLock.</span></span><br><span class=\"line\"><span class=\"comment\">// It is currently embedded in an interpreter frame(在栈的解释帧上分配).</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BasicObjectLock</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VMStructs</span>;</span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  BasicLock _lock; <span class=\"comment\">// 锁</span></span><br><span class=\"line\">  oop       _obj; <span class=\"comment\">// 持有锁的对象，owner的实现</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BasicLock</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> markOop _displaced_header;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>当字节码解释器执行monitorenter字节码轻量地锁住一个对象时，就会在获取锁的线程的栈上显式或隐式分配一个lock record。</p>\n<p>栈帧中解释帧包含一个区域，该区域保存激活拥有的所有监视器的锁记录。在解释的方法执行期间，该区域根据持有的锁数量增长或缩小。lock record在线程的Interpretered Frame（解释帧）上分配。</p>\n<p>其实关于LockRecord只需要知道，<strong>在轻量级锁时JVM会在栈帧中创建一个对象（对象中有着owner指针）来进行线程与加锁对象的双向关联</strong></p>\n<h2 id=\"2-4-轻量级锁-重量级锁\"><a href=\"#2-4-轻量级锁-重量级锁\" class=\"headerlink\" title=\"2.4 轻量级锁-&gt;重量级锁\"></a>2.4 轻量级锁-&gt;重量级锁</h2><p>当CAS自旋达到一定次数会变成重量级锁，这时线程会进入ObjectMonitor的阻塞队列中，当锁被释放时会随机从队列中唤醒一个进程持有锁。持有锁的线程执行Object.wait()方法阻塞会转移到<strong>WaitSet</strong>队列，等待被notify()或notifyAll()唤醒后会进入<strong>EntryList</strong>中。</p>\n<p><strong>ObjectMonitor结构</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectMonitor() &#123;</span><br><span class=\"line\">\t_header = NULL;</span><br><span class=\"line\">\t_count = <span class=\"number\">0</span>; <span class=\"comment\">// 记录个数</span></span><br><span class=\"line\">\t_waiters = <span class=\"number\">0</span>,</span><br><span class=\"line\">\t_recursions = <span class=\"number\">0</span>; <span class=\"comment\">// 线程重入次数</span></span><br><span class=\"line\">\t_object = NULL; <span class=\"comment\">// 存储 Monitor 对象</span></span><br><span class=\"line\">\t_owner = NULL; <span class=\"comment\">// 持有当前线程的 owner</span></span><br><span class=\"line\">\t_WaitSet = NULL; <span class=\"comment\">// 处于 wait 状态的线程，会被加入到 _WaitSet</span></span><br><span class=\"line\">\t_WaitSetLock = <span class=\"number\">0</span> ;</span><br><span class=\"line\">\t_Responsible = NULL ;</span><br><span class=\"line\">\t_succ = NULL ;</span><br><span class=\"line\">\t_cxq = NULL ; <span class=\"comment\">// 单向列表</span></span><br><span class=\"line\">\tFreeNext = NULL ;</span><br><span class=\"line\">\t_EntryList = NULL ; <span class=\"comment\">// 处于等待锁 block 状态的线程，会被加入到该列表</span></span><br><span class=\"line\">\t_SpinFreq = <span class=\"number\">0</span> ;</span><br><span class=\"line\">\t_SpinClock = <span class=\"number\">0</span> ;</span><br><span class=\"line\">\tOwnerIsThread = <span class=\"number\">0</span> ;</span><br><span class=\"line\">\t_previous_owner_tid = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个对象都会关联一个ObjectMonitor，java通过ObjectMonitor来管理锁（只要有synchronized就离不开ObjectMonitor）。</p>\n<img src=\"/2024/05/08/java%E4%B8%A4%E9%94%81%E4%B9%8B%E4%B8%80%E7%9A%84synchronized/java重量级锁.webp\" alt=\"java重量级锁\" style=\"zoom:80%;\">\n\n<p><strong>重量级锁的升级条件</strong>：</p>\n<ol>\n<li>从轻量级锁升级为重量级锁的条件： 自旋超过一定次数（默认10次），可以通过<code>-XX:PreBlockSpin</code>设置次数</li>\n<li>从无锁&#x2F;偏向锁直接升级为重量级锁的条件：<strong>调用了object.wait()方法，则会直接升级为重量级锁！</strong></li>\n</ol>\n","site":{"data":{}},"length":2200,"excerpt":"<p>多线程可以提升任务的执行效率，但是多线程由于隔离程度不够，会出现多个线程同时操作同一变量使得变量值不可控的情况，也就是线程安全问题。</p>\n<p><strong>线程安全问题出现的场景</strong>：</p>\n<ul>\n<li>多线程环境</li>\n<li>有共享数据</li>\n<li>有多条语句操作共享数据&#x2F;单条语句本身非原子操作（比如i++虽然是单条语句，但并非原子操作）</li>\n</ul>\n<p>一般来说解决问题就是需要破坏三个条件中的一个，锁就是将多线程访问变量的过程串行化，破坏多线程环境。另外还可以通过创建副本的方法来破坏第二个条件，lua脚本将多个redis操作合并成原子操作破坏第三个条件。</p>\n<p>java中锁的实现大体分两种，分别是基于<code>Monitor</code>的<code>synchronized</code>和基于<code>AQS</code>的<code>ReentrantLock</code>，这篇文章先来总结一下synchronized的使用与实现</p>","more":"<h1 id=\"1-synchronized的使用\"><a href=\"#1-synchronized的使用\" class=\"headerlink\" title=\"1. synchronized的使用\"></a>1. synchronized的使用</h1><h2 id=\"1-1-经典的单例模式\"><a href=\"#1-1-经典的单例模式\" class=\"headerlink\" title=\"1.1 经典的单例模式\"></a>1.1 经典的单例模式</h2><p>为了保证类只有一个实例，需要保证只有一个线程能使用Class文件创建类对象，这样就可以对<code>SingletonPattern.class</code>加锁，保证资源独享。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonPattern</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//volatile 用于禁止JVM指令重排</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> SingletonPattern INSTANCE;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> SingletonPattern <span class=\"title function_\">getINSTANCE</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(INSTANCE == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (SingletonPattern.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(INSTANCE == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//具体的初始化逻辑</span></span><br><span class=\"line\">                    INSTANCE = <span class=\"keyword\">new</span> <span class=\"title class_\">SingletonPattern</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                        Thread.sleep(<span class=\"number\">350L</span>);</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-用法\"><a href=\"#1-2-用法\" class=\"headerlink\" title=\"1.2 用法\"></a>1.2 用法</h2><p>synchronized用法一般可以分为两大类，对方法进行同步和对代码块进行同步。</p>\n<ol>\n<li><p>代码块</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">//对对象进行加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (o) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;test1&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (o) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;test2&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t1.join();</span><br><span class=\"line\">        t2.join();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 0 aload_0</span><br><span class=\"line\"> 1 dup</span><br><span class=\"line\"> 2 astore_1</span><br><span class=\"line\"> 3 monitorenter</span><br><span class=\"line\"> 4 getstatic #25 &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span><br><span class=\"line\"> 7 ldc #39 &lt;test2&gt;</span><br><span class=\"line\"> 9 invokevirtual #33 &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;</span><br><span class=\"line\">12 aload_1</span><br><span class=\"line\">13 monitorexit</span><br><span class=\"line\">14 goto 22 (+8)</span><br><span class=\"line\">17 astore_2</span><br><span class=\"line\">18 aload_1</span><br><span class=\"line\">19 monitorexit</span><br><span class=\"line\">20 aload_2</span><br><span class=\"line\">21 athrow</span><br><span class=\"line\">22 return</span><br></pre></td></tr></table></figure>\n\n<p>字节码可以看到代码块通过<strong>monitorenter</strong>和<strong>monitorexit</strong>来实现加锁和释放锁</p>\n</li>\n<li><p>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        test();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//对方法进行加锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;test1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//观察字节码方法同步是通过设置标志ACC_SYNCHRONIZED来实现的,(方法中没有monitorenter等同步字节码)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\">    descriptor: ()V</span><br><span class=\"line\">    flags: (<span class=\"number\">0x0029</span>) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">      stack=<span class=\"number\">2</span>, locals=<span class=\"number\">0</span>, args_size=<span class=\"number\">0</span></span><br><span class=\"line\">         <span class=\"number\">0</span>: getstatic     #<span class=\"number\">12</span>                 <span class=\"comment\">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class=\"line\">         <span class=\"number\">3</span>: ldc           #<span class=\"number\">18</span>                 <span class=\"comment\">// String test1</span></span><br><span class=\"line\">         <span class=\"number\">5</span>: invokevirtual #<span class=\"number\">20</span>                 <span class=\"comment\">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class=\"line\">         <span class=\"number\">8</span>: <span class=\"keyword\">return</span></span><br><span class=\"line\">      LineNumberTable:</span><br><span class=\"line\">        line <span class=\"number\">12</span>: <span class=\"number\">0</span></span><br><span class=\"line\">        line <span class=\"number\">13</span>: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>不论是代码块还是方法，synchronized同步都是针对对象进行的。代码块直接是操作对象，方法会根据是否是static方法来判断是对class对象还是实例对象进行加锁（static方法属于类而不是实例对象）。</p>\n<h1 id=\"2-synchronized的实现\"><a href=\"#2-synchronized的实现\" class=\"headerlink\" title=\"2. synchronized的实现\"></a>2. synchronized的实现</h1><h2 id=\"2-1-概述\"><a href=\"#2-1-概述\" class=\"headerlink\" title=\"2.1 概述\"></a>2.1 概述</h2><p><strong>特性</strong>：原子性、可见性、可重入性、有序性</p>\n<p>synchronized的实现依赖于JVM，java对象在JVM中会按<strong>对象头、实例数据和对齐填充</strong>的形式存储，了解synchronized我们只需要关注对象头就行了。</p>\n<p><strong>对象头结构</strong>：</p>\n<ul>\n<li><p><strong>mark-word</strong>：对象标记字段占 4 个字节，用于存储一些列的标记位，比如：哈希值、轻量级锁的标记位，偏向锁标记位、分代年龄等。</p>\n</li>\n<li><p><strong>Klass Pointer</strong>：Class 对象的类型指针，Jdk1.8 默认开启指针压缩后为 4 字节，关闭指针压缩（-XX:-UseCompressedOops）后，长度为 8 字节。其指向的位置是对象对应的 Class 对象（其对应的元数据对象）的内存地址。</p>\n</li>\n</ul>\n<p>mark-word在各锁状态的总览：</p>\n<img src=\"/2024/05/08/java%E4%B8%A4%E9%94%81%E4%B9%8B%E4%B8%80%E7%9A%84synchronized/jvm_markWord.png\" alt=\"jvm_markWord\">\n\n<p>markWord使用3位来表示对象的五种状态（无锁，偏向锁，轻量锁，重量锁，以及 GC 标记），线程在竞争锁时会判断对象加锁情况进行竞争。</p>\n<h2 id=\"2-2-无锁-偏向锁\"><a href=\"#2-2-无锁-偏向锁\" class=\"headerlink\" title=\"2.2 无锁-&gt;偏向锁\"></a>2.2 无锁-&gt;偏向锁</h2><p>无锁状态时MarkWord中会存放<strong>HashCode</strong>、<strong>分代年龄</strong>等信息。当一个线程来请求获取锁时,此时MarkWord前54bit会用来表示持有该锁的线程，Epoch表示该锁的版本戳，当该线程再次来访问时可以直接访问，不需要同步。</p>\n<p>JDK15之后偏向锁就被弃用了，因为使用锁的场景大多是多个线程竞争的情况，而偏向锁的优势是<strong>可以节省同一个线程多次请求同一锁时同步消耗的资源</strong>，这样一来多个线程竞争时反而会因为偏向锁向轻量级锁转变造成资源的浪费。</p>\n<p>JDK8之前可以设置<code>-XX:-UseBiasedLocking</code>来禁用偏向锁，另外JVM延迟设置偏向锁，所以下面测试偏向锁需要sleep()或者<code>-XX:BiasedLockingStartupDelay=0</code>关闭延迟偏向锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>  <span class=\"keyword\">throws</span> InterruptedException&#123;</span><br><span class=\"line\">    TimeUnit.SECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">o</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (o)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//打印，观察对象加锁情况</span></span><br><span class=\"line\">            System.out.println(ClassLayout.parseInstance(o).toPrintable()); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--查看对象头工具--&gt;</span></span><br><span class=\"line\"><span class=\"comment\">      &lt;dependency&gt;</span></span><br><span class=\"line\"><span class=\"comment\">          &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span></span><br><span class=\"line\"><span class=\"comment\">          &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span></span><br><span class=\"line\"><span class=\"comment\">          &lt;version&gt;0.9&lt;/version&gt;</span></span><br><span class=\"line\"><span class=\"comment\">          &lt;scope&gt;test&lt;/scope&gt;</span></span><br><span class=\"line\"><span class=\"comment\">      &lt;/dependency&gt;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>&#x2F;&#x2F;可以看到加上参数后，对象加的是轻量级锁（观察开头4个字节最后三位，顺序是倒过来的，所以最后8位是<code>c8</code>，最后两位是00）</p>\n<img src=\"/2024/05/08/java%E4%B8%A4%E9%94%81%E4%B9%8B%E4%B8%80%E7%9A%84synchronized/image-20240513145730228.png\" alt=\"image-20240513145730228\">\n\n<p>&#x2F;&#x2F;不加参数的情况，最后三位是101，加的是偏向锁</p>\n<img src=\"/2024/05/08/java%E4%B8%A4%E9%94%81%E4%B9%8B%E4%B8%80%E7%9A%84synchronized/image-20240513150908609.png\" alt=\"image-20240513150908609\">\n\n<h2 id=\"2-3-偏向锁-轻量级锁\"><a href=\"#2-3-偏向锁-轻量级锁\" class=\"headerlink\" title=\"2.3 偏向锁-&gt;轻量级锁\"></a>2.3 偏向锁-&gt;轻量级锁</h2><p>多个线程竞争同一把锁且竞争不太激烈时，偏向锁会升级为轻量级锁（CAS自旋来获取），虚拟机会在当前线程的栈帧中创建一个LockRecord空间，储存当前锁对象的MarkWord拷贝（主要是为记录了HashCode，分代年龄等内容）。</p>\n<p>线程竞争锁时会先将MarkWord复制到栈帧中，之后<strong>通过CAS尝试将锁对象的LockRecord指针指向栈帧中的LockRecord</strong>，并将owner指针指向锁对象的MarkWord，CAS操作成功后将锁对象MarkWord锁字段更新为00，表示轻量级锁。CAS失败后会检查MarkWord中LockRecord指针是否指向当前线程的栈帧，如果是则表明已抢到锁，否则自旋等待。</p>\n<p><strong>概述</strong>：轻量级锁抢占需要维持对象和线程的双向联系，<strong>锁对象的LockRecord需要指向栈帧中的LockRecord</strong>，<strong>栈帧中的owner指针需要指向锁对象的MarkWord</strong>。只有同时满足这两个联系，才算成功加锁。</p>\n<h3 id=\"LockRecord和owner分别是什么？\"><a href=\"#LockRecord和owner分别是什么？\" class=\"headerlink\" title=\"LockRecord和owner分别是什么？\"></a>LockRecord和owner分别是什么？</h3><p>LockRecord在openjdk中通过以下两个类来实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A BasicObjectLock associates a specific Java object with a BasicLock.</span></span><br><span class=\"line\"><span class=\"comment\">// It is currently embedded in an interpreter frame(在栈的解释帧上分配).</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BasicObjectLock</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">VMStructs</span>;</span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  BasicLock _lock; <span class=\"comment\">// 锁</span></span><br><span class=\"line\">  oop       _obj; <span class=\"comment\">// 持有锁的对象，owner的实现</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BasicLock</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> markOop _displaced_header;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>当字节码解释器执行monitorenter字节码轻量地锁住一个对象时，就会在获取锁的线程的栈上显式或隐式分配一个lock record。</p>\n<p>栈帧中解释帧包含一个区域，该区域保存激活拥有的所有监视器的锁记录。在解释的方法执行期间，该区域根据持有的锁数量增长或缩小。lock record在线程的Interpretered Frame（解释帧）上分配。</p>\n<p>其实关于LockRecord只需要知道，<strong>在轻量级锁时JVM会在栈帧中创建一个对象（对象中有着owner指针）来进行线程与加锁对象的双向关联</strong></p>\n<h2 id=\"2-4-轻量级锁-重量级锁\"><a href=\"#2-4-轻量级锁-重量级锁\" class=\"headerlink\" title=\"2.4 轻量级锁-&gt;重量级锁\"></a>2.4 轻量级锁-&gt;重量级锁</h2><p>当CAS自旋达到一定次数会变成重量级锁，这时线程会进入ObjectMonitor的阻塞队列中，当锁被释放时会随机从队列中唤醒一个进程持有锁。持有锁的线程执行Object.wait()方法阻塞会转移到<strong>WaitSet</strong>队列，等待被notify()或notifyAll()唤醒后会进入<strong>EntryList</strong>中。</p>\n<p><strong>ObjectMonitor结构</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectMonitor() &#123;</span><br><span class=\"line\">\t_header = NULL;</span><br><span class=\"line\">\t_count = <span class=\"number\">0</span>; <span class=\"comment\">// 记录个数</span></span><br><span class=\"line\">\t_waiters = <span class=\"number\">0</span>,</span><br><span class=\"line\">\t_recursions = <span class=\"number\">0</span>; <span class=\"comment\">// 线程重入次数</span></span><br><span class=\"line\">\t_object = NULL; <span class=\"comment\">// 存储 Monitor 对象</span></span><br><span class=\"line\">\t_owner = NULL; <span class=\"comment\">// 持有当前线程的 owner</span></span><br><span class=\"line\">\t_WaitSet = NULL; <span class=\"comment\">// 处于 wait 状态的线程，会被加入到 _WaitSet</span></span><br><span class=\"line\">\t_WaitSetLock = <span class=\"number\">0</span> ;</span><br><span class=\"line\">\t_Responsible = NULL ;</span><br><span class=\"line\">\t_succ = NULL ;</span><br><span class=\"line\">\t_cxq = NULL ; <span class=\"comment\">// 单向列表</span></span><br><span class=\"line\">\tFreeNext = NULL ;</span><br><span class=\"line\">\t_EntryList = NULL ; <span class=\"comment\">// 处于等待锁 block 状态的线程，会被加入到该列表</span></span><br><span class=\"line\">\t_SpinFreq = <span class=\"number\">0</span> ;</span><br><span class=\"line\">\t_SpinClock = <span class=\"number\">0</span> ;</span><br><span class=\"line\">\tOwnerIsThread = <span class=\"number\">0</span> ;</span><br><span class=\"line\">\t_previous_owner_tid = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个对象都会关联一个ObjectMonitor，java通过ObjectMonitor来管理锁（只要有synchronized就离不开ObjectMonitor）。</p>\n<img src=\"/2024/05/08/java%E4%B8%A4%E9%94%81%E4%B9%8B%E4%B8%80%E7%9A%84synchronized/java重量级锁.webp\" alt=\"java重量级锁\" style=\"zoom:80%;\">\n\n<p><strong>重量级锁的升级条件</strong>：</p>\n<ol>\n<li>从轻量级锁升级为重量级锁的条件： 自旋超过一定次数（默认10次），可以通过<code>-XX:PreBlockSpin</code>设置次数</li>\n<li>从无锁&#x2F;偏向锁直接升级为重量级锁的条件：<strong>调用了object.wait()方法，则会直接升级为重量级锁！</strong></li>\n</ol>"},{"title":"什么是伪共享?","date":"2024-10-30T08:34:24.000Z","_content":"\n","source":"_posts/什么是伪共享.md","raw":"---\ntitle: 什么是伪共享?\ndate: 2024-10-30 16:34:24\ntags:\n  - cpu缓存\ncategories:\t\n  - 计算机基础\n---\n\n","slug":"什么是伪共享","published":1,"updated":"2024-10-30T08:42:34.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6bq000rskus1cyl23un","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"jvm","date":"2024-09-10T08:34:06.000Z","_content":"\n**主要内容**：\n\n1. jvm垃圾回收\n2. class文件\n3. 类加载过程\n4. jvm内存模型\n\n<!--more-->\n\n# 1. 垃圾回收\n\n## 1.1 基础\n\n### 垃圾的定义\n\n没有任何引用指向的一个对象或者多个对象（循环引用）\n\n### 垃圾定位\n\n1. 引用计数（ReferenceCount）\n\n   加一个引用计数器+1，减少一个计数器-1（易出现循环引用的问题）\n\n2. 根可达算法(RootSearching)\n\n   常见根：\n\n   - JVM statck 虚拟机栈\n   - native method statck 本地方法栈\n   - run-time constant pool 常量池\n   - static references in method area 方法区的静态引用 \n   - Clazz \n\n### GC算法\n\n1. 标记清除(mark sweep) - 位置不连续 产生碎片 效率偏低（两遍扫描）\n\n   <img src=\"./jvm/image-20231201151500158.png\" alt=\"image-20231201151500158\" style=\"zoom:80%;\" />\n\n   碎片空间可能导致大对象没有地方存放\n\n2. 拷贝算法 (copying) - 没有碎片，浪费空间\n\n   <img src=\"./jvm/image-20231201151606407.png\" alt=\"image-20231201151606407\" style=\"zoom:80%;\" />\n\n   将空间分成两半，gc时将使用一半的存活对象复制到另一半\n\n3. 标记压缩(mark compact) - 没有碎片，效率偏低（两遍扫描，指针需要调整）\n\n   <img src=\"./jvm/image-20231201151745264.png\" alt=\"image-20231201151745264\" style=\"zoom:80%;\" />\n\n   \n\n## 1.2 JVM内存分代模型\n\n1. 部分垃圾回收器使用的模型\n\n   > 除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型\n   >\n   > G1是逻辑分代，物理不分代\n   >\n   > 除此之外不仅逻辑分代，而且物理分代\n\n2. 新生代 + 老年代 + 永久代（1.7）Perm Generation/ 元数据区(1.8) Metaspace\n\n   1. 永久代 元数据 - Class\n   2. 永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存）\n   3. 字符串常量 1.7 - 永久代，1.8 - 堆\n   4. MethodArea逻辑概念 - 永久代、元数据\n\n3. 新生代 = Eden + 2个suvivor区 \n\n   1. YGC回收之后，大多数的对象会被回收，活着的进入s0\n   2. 再次YGC，活着的对象eden + s0 -> s1\n   3. 再次YGC，eden + s1 -> s0\n   4. 年龄足够 -> 老年代 （15 CMS 6）\n   5. s区装不下 -> 老年代\n\n4. 老年代\n\n   1. 顽固分子\n   2. 老年代满了FGC Full GC\n\n5. GC Tuning (Generation)\n\n   1. 尽量减少FGC\n   2. MinorGC = YGC\n   3. MajorGC+MinorGC = FGC\n\n## 1.3 GC常见评估指标\n\n1. **吞吐量**：吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。\n2. **暂停时间**：执行一次垃圾回收STW时间的大小\n\n**两者不可兼得**\n\n如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。\n\n## 1.4 垃圾回收器\n\n常见垃圾回收器及其组合（远古图片，现在还有一个不是分代模型的ZGC）\n\n<img src=\"./jvm/82a369cjhi.jpeg\" alt=\"82a369cjhi\" style=\"zoom:80%;\" />\n\n## 1.5 垃圾回收器及其算法\n\nSerial是**单线程**使用**标记复制算法**的垃圾回收器作用于**新生代**\n\nSerialOld是**单线程**使用**标记整理算法**的垃圾回收器作用于**老年代**\n\nParNew是**多线程**使用**标记复制算法**的垃圾回收器作用于**新生代**\n\n\n\nParallelScavenge是**吞吐量优先**使用**标记复制算法**的垃圾回收器作用于**新生代**（吞吐量优先垃圾回收器），不支持**多线程**\n\nParallelOld是**多线程**使用**标记整理算法**的垃圾回收器作用于**老年代**\n\nCMS是**低停顿**使用**标记清除+标记整理**算法的垃圾回收器作用于**老年代**\n\n\n\nG1是新一代不分区的垃圾回收器之一，使用**标记复制**算法，作用于**年轻代和老年代**，兼顾**低停顿和高吞吐量**，优先回收高价值的垃圾。\n\n**ZGC**：是一款**基于Region内存布局**的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。\n\nZGC的工作过程可以分为4个阶段：**并发标记-并发预备重分配-并发重分配-并发重映射**等。\n\nZGC几乎在所有地方并发执行的，除了**初始标记的是STW**的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。\n\n1.8 默认是ParallelScavenge+ParallelOld。\n\n1.9+默认是G1。\n\n### 三色标记法\n\n**三色**\n\n- **白色**：还没有遍历对象\n- **灰色**：已遍历到的对象，但是它直接引用的对象还没有遍历完\n- **黑色**：已遍历到的对象，它的直接引用也已遍历完\n\n**浮动垃圾**：灰色对象可能已经是垃圾了，但是还是当成正常对象存活到下一轮GC\n\n**三色标记法黑色被误认为白色**：\n\n1. 赋值器插入一条或多条从黑色对象到白色对象的新引用\n2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用\n\n**两种解决方式**：\n\n1. **增量更新法**：\n\n   对于这种漏标的情况，CMS垃圾收集器使用的是增量更新法，就是将引用变化后的引用情况进行记录，然后之后进行标记。也就是当E->G变成了E->null,D->G，会对D->G进行记录，用于在重新标记阶段对这种情况进行处理。\n\n2. **原始快照法**：\n\n   就是对于这种E->G，然后改成D->G，正常来说，应该可能会漏掉，因为D已经是黑色对象了，就不会遍历G了，G1垃圾收集器对这种情况的处理是保存原始快照，就是在并发标记过程中，引用的变动，都会对变动前的引用情况进行记录，会按照变动前的引用情况进行标记，也就是即便E->G变成了E->null,D->G变化了，还是会记录E->G的引用情况，用于在重新标记阶段对这种情况进行处理。\n\n### CMS（标记清除灰导致内存碎片化）\n\n#### 1. 初始标记\n\n在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。\n\n#### 2. 并发标记\n\n从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。\n\n#### 3. 重新标记\n\n由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（比如：由不可达变为可达对象的数据），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。\n\n#### 4. 并发清除\n\n阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。\n\n\n\n# 2. Class文件结构\n\nClass文件为二进制，可以用powershell命令\n\n```shell\nFormat-Hex D:\\java\\learn\\out\\production\\learn\\mix\\Main.class\n```\n\n以16进制查看文件\n\n<img src=\"./jvm/image-20231116194904286.png\" alt=\"image-20231116194904286\" style=\"zoom:75%;\" />\n\n文件的大致结构为（u2表示两个字节的无符号数)\n\n<img src=\"./jvm/image-20231116202440545.png\" alt=\"image-20231116202440545\" style=\"zoom:80%;\" />\n\n## 2.1 魔数(magic number)\n\n开头四个字节'CA FE BA BE' 为称为魔数，魔数是固定的，用来指定这个文件是Class文件\n\n## 2.2 Class文件版本\n\n四个字节，前两个为副版本，后两个为主版本。如00 00 00 3A表示Class文件版本为 58.0 (也就是java 14)\n\n## 2.3 常量池\n\n两个字节表示常量池的大小00 14表示常量池大小为20。由于常量池index从1开始，所以常量数量只有19个\n\n常量的第一个字节表示常量类型，每个常量类型有不同的长度\n\n常量池是class文件最重要的一部分，名称、类型等具体内容都会被存储在常量池中，在后续修饰字段、方法时只需要记录位置，根据位置就可以获取到具体的属性。\n\n**常见常量类型：**\n\n<img src=\"./jvm/image-20231116200128095.png\" alt=\"image-20231116200128095\" style=\"zoom:80%;\" />\n\n## 2.4 访问标志\n\n之后两个字节表示访问标志\n\n<img src=\"./jvm/image-20231116202718426.png\" alt=\"image-20231116202718426\" style=\"zoom:80%;\" />\n\n## 2.5 类索引、父类索引、接口索引集合\n\n    u2             this_class;//当前类\n    u2             super_class;//父类\n    u2             interfaces_count;//接口数量\n    u2             interfaces[interfaces_count];//一个类可以实现多个接口\n\n## 2.6 字段表集合\n\n<img src=\"./jvm/image-20231116203451353.png\" alt=\"image-20231116203451353\" style=\"zoom:80%;\" />\n\n**descriptor_index**用来描述类型\n\n## 2.6 方法表集合\n\n<img src=\"./jvm/image-20231116204902025.png\" alt=\"image-20231116204902025\" style=\"zoom:80%;\" />\n\n## 2.7 属性表\n\n详见《深入理解java虚拟机》\n\n# 3. java类加载器\n\n## 3.1 类加载\n\n<img src=\"./jvm/image-20231127105115660.png\" alt=\"image-20231127105115660\" style=\"zoom:80%;\" />\n\n### 加载\n\n装载阶段，简言之，查找并加载类的二进制数据，生成Class的实例，即类模版对象。\n在加载类时，Java虚拟机必须完成以下3件事情：\n\n- 通过类的全名，获取类的二进制数据流。\n- 解析类的二进制数据流为方法区内的数据结构（Java类模型）\n- 创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口\n\n**类模板对象**\n所谓类模板对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。\n\n反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。\n\n**类模型的位置**\n加载的类在JVM中创建相应的类结构，类结构会存储在方法区(JDK1.8之前：永久代；JDK1.8及之后：元空间)。\n\n**数组类的加载**\n\n创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。\n\n### 链接\n\n1. 验证\n\n   **目的：**保证加载的字节码是合法、合理并符合规范的\n\n   <img src=\"./jvm/image-20231205215113256.png\" alt=\"image-20231205215113256\" style=\"zoom:60%;\" />\n\n   其中格式验证会和装载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。\n   格式验证之外的验证操作将会在方法区中进行。（其他验证略）\n\n2. 准备\n\n   简言之，为类的静态变量分配内存，并将其初始化为默认值。\n   在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java虚拟机为各类型变量默认的初始值如表所示。\n\n   <img src=\"./jvm/image-20231205215707315.png\" alt=\"image-20231205215707315\" style=\"zoom:70%;\" />\n\n   注意：Java并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false。\n\n3. 解析\n\n   将类、接口、字段和方法的符号引用转为直接引用。\n\n   如`System.out.println();`转换过程\n\n   <img src=\"./jvm/image-20231206112755092.png\" alt=\"image-20231206112755092\" style=\"zoom:67%;\" />\n\n   Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行。\n\n### 初始化\n\n调用<clinit>初始化方法，\n\n```java\npublic class InitializationTest1 {\n    //场景1：对于非静态的字段，不管是否进行了显式赋值，都不会生成<clinit>()方法\n    public int num = 1;\n    //场景2：静态的字段，没有显式的赋值，不会生成<clinit>()方法\n    public static int num1;\n    //场景3：比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成<clinit>()方法\n    public static final int num2 = 1;\n}\n```\n\n**类的初始化时机**\n\n1. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。\n2. 当调用类的静态方法时，即当使用了字节码invokestatic指令。\n3. 当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。\n4. 当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(\"com.atguigu.java.Test\")\n5. 当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n6. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。\n7. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。\n\n### 卸载\n\n类的垃圾回收过程\n\n## 3.2 双亲委派机制\n\n作用：\n\n1. 防止类库中的类被重写\n2. 避免类被重复加载\n\n<img src=\"./jvm/image-20231117160926362.png\" alt=\"image-20231117160926362\" style=\"zoom:50%;\" />\n\n\n\nBootstrap加载`%JAVA_HOME%lib`下的jar包和class文件，ExtClassLoader加载`%JAVA_HOME%lib/lib/ext`文件夹下的jar包和class类。AppClassLoader负责加载`classpath`下的类文件。系统类加载器，线程上下文加载器贯穿三个类加载器。\n\n3个关键方法loadClass()、findClass()、defineClass()\n\nloadClass双亲委派模型具体的实现\n\nfindClass从指定路径中加载Class字节流\n\ndefineClass将Class字节流翻译为Class对象\n\n## 3.3 自定义类加载器\n\n重写loadClass()方法或者重写findClass()方法\n\n```java\n//重写findClass()方法, 遵循双亲委派模型, 子类先委托父类加载需要的类，父类从指定的路径加载类, 没有则交给子类加载\npublic class MyClassLoader extends ClassLoader{\n    private final String classPath;\n    private final String className;\n\n\n    public MyClassLoader(String classPath, String className) {\n        this.classPath = classPath;\n        this.className = className;\n    }\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        byte[] data = getData();\n        if (data != null) {\n            return defineClass(className,data,0,data.length);\n        }\n        return null;\n    }\n\n    private byte[] getData(){\n        String path = classPath;\n        try {\n            FileInputStream inputStream = new FileInputStream(path);\n            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            byte[] bytes = new byte[2048];\n            int num = 0;\n            while ((num = inputStream.read(bytes)) != -1){\n                byteArrayOutputStream.write(bytes, 0,num);\n            }\n            return byteArrayOutputStream.toByteArray();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n```\n\nloadClass()方法\n\n```java\nprotected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 = System.nanoTime();\n                    c = findClass(name);\n\n                    // this is the defining class loader; record the stats\n                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n```\n\n\n\n### 打破双亲委派机制\n\n双亲委派模型\n\n1. tomcat中部署多个应用时可能需要加载相同的类多次，双亲委派模型无法实现\n\n   <img src=\"./jvm/image-20231214111741606.png\" alt=\"image-20231214111741606\" style=\"zoom:70%;\" />\n\n   - 放置在/common目录中。类库可被Tomcat和所有的Web应用程序共同使用。\n\n   - 放置在/server目录中。类库可被Tomcat使用，对所有的Web应用程序都不可见。\n\n   - 放置在/shared目录中。类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。\n\n   - 放置在/WebApp/WEB-INF目录中。类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用\n\n     \n\n2. java中比较出名的SPI机制（线程上下文类加载器）\n\n   父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所指定的Classloader加载的类。这就改变了父ClassLoader不能使用子ClassLoader或是其他没有直接父子关系的classLoader加载的类的情况，即**改变了双亲委托模型**。\n\n   线程上下文类加载器就是当前线程的当前类加载器(Current Classloader)。\n\n   **在双亲委托模型下**，类加载是由下至上的，即下层的类加载器会委托上层进行加载。但是对于SPI来说，有些接口是Java核心库所提供的,而Java核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的jar包(厂商提供)， Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就**无法满足**SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。\n\n3. web应用热替换的实现（对程序动态性的最求）\n\n   \n\n### 沙箱安全机制\n\n对代码的权限进行校验，判断其是否有权限操作资源\n\n**基本组件**\n\n- **字节码校验器**：确保lava类文件遵循lava语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。\n- **类加载器**：防止恶意代码去干涉善意的代码，比如：双亲委派机制；守护了被信任的类库边界；将代码归入保护域，确定了代码的权限范围可以进行哪些资源操作\n- **存取控制器**：存取控制器可以控制核心API对操作系统的存取权限，用户可以设定控制策略。\n- **安全管理器**：安全管理器主要是核心API和操作系统之间的主要接口。比如实现权限控制，比存取控制器优先级高。\n- **安全软件包**：java.security下的类和扩展包下的类，允许用户为应用增加所需要安全特性：安全提供者、消息摘要、数字签名keytools、加密、鉴别。\n\n# 4. jvm内存模型\n\n<img src=\"./jvm/image-20231214193447991.png\" alt=\"image-20231214193447991\" style=\"zoom:80%;\" />\n\n## 4.1 程序计数器\n\n**作用**：记录当前线程的执行地址（记录字节码执行到哪了）\n\n没有规定任何OutOtMemoryError情况的区域\n\n## 4.2 栈\n\n虚拟栈和本地方法栈的区别在于，虚拟机栈执行的是java中的方法，本地方法栈中执行的是本地接口实现的方法，其内部结构差不多\n\n**栈的内部结构**：\n\n<img src=\"./jvm/image-20231214194507254.png\" alt=\"image-20231214194507254\" style=\"zoom:70%;\" />\n\n**可能抛出的异常：**\n\n- 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。\n- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常。\n\n### 栈帧\n\n一个方法对应一个栈帧\n\n<img src=\"./jvm/image-20231214195613362.png\" alt=\"image-20231214195613362\" style=\"zoom:80%;\" />\n\nJava方法有两种返回函数的方式，会导致栈帧被弹出\n\n1. 正常的函数返回，使用return指令；\n\n2. 抛出异常。\n\n### 局部变量表\n\n- 局部变量表，最基本的存储单元是Slot（变量槽）\n- 在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double)占用两个slot。\n  byte 、short 、char 在存储前被转换为int，boolean 也被转换为int，0 表示false ，非0 表示true。\n  long 和double 则占据两个Slot。\n- JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值\n- 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上\n- 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。(比如：访问long或double类型变量）\n- 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。\n\n局部变量超出作用域，其原本的slot将被重复利用\n\n### 操作数栈\n\n进行具体方法操作的初步逻辑，保存计算的中间结果\n\n一个栈深度为32bit，为一个slot（槽位）,long、double类型数据可能占两个槽位\n\n数据超过作用域后，所占槽位可以复用。\n\n**栈顶缓存技术：**\n\n基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。\n\n由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。\n\n## 4.3 堆\n\n<img src=\"./jvm/image-20231214221246377.png\" alt=\"image-20231214221246377\" style=\"zoom:80%;\" />\n\n按照分代模型，堆可分为年轻代、老年代，年轻代可分为Eden区、s0、s1区。默认比例为`Eden:s0:s1:Old = 8:1:1:20`\n\n**GC过程**\n\n1. YGC回收之后，大多数的对象会被回收，活着的进入s0\n2. 再次YGC，活着的对象eden + s0 -> s1\n3. 再次YGC，eden + s1 -> s0\n4. 年龄足够 -> 老年代 （15 CMS 6）\n5. s区装不下 -> 老年代\n\n在jdk1.7及之前会有一个堆中会有永久代的这个概念，不过永久代并不是垃圾回收的主要作用地。它主要是用来存放java中类的元数据（即java中成员变量的类型、作用范围等）所以一般把永久代称为方法区\n\n## 4.4 方法区（元空间）\n\n**存放内容：**\n\n1. 类型信息\n2. 域信息\n3. 方法信息\n4. static类变量（非final）\n\n**运行时常量池**\n\n作用：缩小字节码文件（存放指向常量池的应用而非直接的数据）\n\n内容：\n\n- 数量值\n- 字符串值\n- 类引用\n- 字段引用\n- 方法引用\n\n## 4.5 直接内存\n\n不是JVM定义的内存区域，直接向系统申请的内存，读写性能较高\n\n<img src=\"./jvm/image-20231217221608733.png\" alt=\"image-20231217221608733\" style=\"zoom:67%;\" />\n\n<img src=\"./jvm/image-20231217221643907.png\" alt=\"image-20231217221643907\" style=\"zoom:67%;\" />\n\n## 4.6 StringTable\n\njdk1.7时移到堆中，因为方法区的内存回收效率较低\n\n使用数组+链表实现\n\n# 5. 四种引用\n\n1. 强引用：就是普通的变量对对象的引用，强引用的对象不会被系统回收。\n2. 软引用：当内存空间足够时，软引用的对象不会被系统回收。当内存空间不足时，软引用的对象可能被 系统回收。通常用于内存敏感的程序中。在JDK 1.2版之后提供了SoftReference类来实现软引用。\n3. 弱引用：引用级别比软引用低，对于只有软引用的对象，不管内存是否足够， 都可能会被系统回收。在JDK 1.2版之后提供了WeakReference类来实现弱引用。\n4. 虚引用：虚引用主要用于跟踪对象被垃圾回收的状态，在垃圾回收时可以收到一个通知。。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。\n\n# 6. jvm指令及重排\n\n## i++与++i\n\n```java\n public static void main(String[] args) {\n        int x = 5;\n        int y = 0;\n        y=x++;\n        y=++x;\n    }\n\n//字节码:\n 0 iconst_5 \t//定义常数5到操作数栈\n 1 istore_1\t\t//将操作数栈顶数存到局部变量表第二个位置\n 2 iconst_0\n 3 istore_2\n 4 iload_1\t\t//将局部变量表2号位load到操作数栈中\n 5 iinc 1 by 1\t//对局部变量表2号位加1\n 8 istore_2\n     \n 9 iinc 1 by 1\t\n12 iload_1\n13 istore_2\n14 return\n//区别在于先加1，还是先把数据load到局部变量表中\n```\n\n按用途分为9类：\n\n1. 加载与存储指令\n\n   ```jvm\n    xload_<n> (x为i、l、f、d、a，n为 0 到 3)\n    xload (x为i、l、f、d、a) \n   ```\n\n   - i代表对int类型的数据操作\n   - l代表long类型的数据操作\n   - s代表short类型的数据操作\n   - b代表byte类型的数据操作\n   - c代表char类型的数据操作\n   - f代表float类型的数据操作\n   - d代表double类型的数据操作\n\n2. 算术指令\n\n3. 类型转换指令\n\n4. 对象的创建与访问指令\n\n5. 方法调用与返回指令\n\n6. 操作数栈管理指令\n\n7. 控制转移指令\n\n8. 异常处理指令\n\n9. 同步控制指令\n\n**指令重排主要是为了最大化的利用CPU资源**\n\n1. **编译器重排序**\n2. **指令集并行的重排序**\n3. **内存重排序**\n\n指令重排的原则（as - if - serial），不过多线程环境较复杂，编译器和指令优化无法识别数据依赖性，可能出现预料之外的错误。\n\n```java\n//输出结果可能为0\nprivate static int value;\n     private static boolean flag;\n\t//线程1执行\n     public static  void  init(){\n         value=8;     //语句1\n         flag=true;  //语句2\n     }\n\t//线程2执行\n     public static void getValue(){\n         if(flag){\n             System.out.println(value);\n         }\n     }\n```\n\n**解决指令重排引起的问题**（内存屏障）\n\n不同的CPU架构和操作系统都有各自对应的内存屏障指令，java为了简化这些杂乱的场景，自己封装了一套规范——java内存模型（JMM）。java中可以通过`Volatile`、`synchronized`、`final`来避免重排序而引起的错误。\n\n\n\n# 7. 常用参数\n\nJDK17 和 JDK8 部分参数有变化\n\n## 输出信息\n\njdk17 使用 -Xlog:gc:<file>来输出相关日志\n\n**输出GC信息**:-XX:+PrintGCDetails\n\n**输出GC信息**：-XX:+PrintGC\n\n**输出GC日志到文件中：**-Xloggc:<file>\n\n## 栈相关\n\n**栈内存大小：**-Xss size (即：-XX:ThreadStackSize)，栈内存越大，可创建线程数量就越少\n\n### **堆相关**：\n\n**新生代和老年代比例：** -XX:NewRatio = 2 (default 即 1：2)\n\n**Eden和s区比例：**-XX:SurvivorRatio=8（8:1:1）\n\n**设置堆空间的初始内存大小**：-Xms\n\n**设置堆空间的最大内存大小**：-Xmx\n\n## 命令行指令\n\n使用命令行指令：jinfo –flag 相关垃圾回收器参数 进程ID\n\n##  垃圾收集器设置\n\n **XX:+UseSerialGC**   \t\t新生代用Serial GC，且老年代用Serial Old GC\n\n**-XX:+UseParNewGC** \t年轻代使用ParNew收集器，老年代不受影响\n\n**-XX:ParallelGCThreads** \t限制线程数量，默认开启和CPU数据相同的线程数。\n\n**G1**：\n\n<img src=\"./jvm/image-20240326163359886.png\" alt=\"image-20240326163359886\" style=\"zoom:80%;\" />\n\n","source":"_posts/jvm.md","raw":"---\ntitle: jvm\ndate: 2024-09-10 16:34:06\ntags:\n    - jvm\ncategories:\n    - 后端开发\n---\n\n**主要内容**：\n\n1. jvm垃圾回收\n2. class文件\n3. 类加载过程\n4. jvm内存模型\n\n<!--more-->\n\n# 1. 垃圾回收\n\n## 1.1 基础\n\n### 垃圾的定义\n\n没有任何引用指向的一个对象或者多个对象（循环引用）\n\n### 垃圾定位\n\n1. 引用计数（ReferenceCount）\n\n   加一个引用计数器+1，减少一个计数器-1（易出现循环引用的问题）\n\n2. 根可达算法(RootSearching)\n\n   常见根：\n\n   - JVM statck 虚拟机栈\n   - native method statck 本地方法栈\n   - run-time constant pool 常量池\n   - static references in method area 方法区的静态引用 \n   - Clazz \n\n### GC算法\n\n1. 标记清除(mark sweep) - 位置不连续 产生碎片 效率偏低（两遍扫描）\n\n   <img src=\"./jvm/image-20231201151500158.png\" alt=\"image-20231201151500158\" style=\"zoom:80%;\" />\n\n   碎片空间可能导致大对象没有地方存放\n\n2. 拷贝算法 (copying) - 没有碎片，浪费空间\n\n   <img src=\"./jvm/image-20231201151606407.png\" alt=\"image-20231201151606407\" style=\"zoom:80%;\" />\n\n   将空间分成两半，gc时将使用一半的存活对象复制到另一半\n\n3. 标记压缩(mark compact) - 没有碎片，效率偏低（两遍扫描，指针需要调整）\n\n   <img src=\"./jvm/image-20231201151745264.png\" alt=\"image-20231201151745264\" style=\"zoom:80%;\" />\n\n   \n\n## 1.2 JVM内存分代模型\n\n1. 部分垃圾回收器使用的模型\n\n   > 除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型\n   >\n   > G1是逻辑分代，物理不分代\n   >\n   > 除此之外不仅逻辑分代，而且物理分代\n\n2. 新生代 + 老年代 + 永久代（1.7）Perm Generation/ 元数据区(1.8) Metaspace\n\n   1. 永久代 元数据 - Class\n   2. 永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存）\n   3. 字符串常量 1.7 - 永久代，1.8 - 堆\n   4. MethodArea逻辑概念 - 永久代、元数据\n\n3. 新生代 = Eden + 2个suvivor区 \n\n   1. YGC回收之后，大多数的对象会被回收，活着的进入s0\n   2. 再次YGC，活着的对象eden + s0 -> s1\n   3. 再次YGC，eden + s1 -> s0\n   4. 年龄足够 -> 老年代 （15 CMS 6）\n   5. s区装不下 -> 老年代\n\n4. 老年代\n\n   1. 顽固分子\n   2. 老年代满了FGC Full GC\n\n5. GC Tuning (Generation)\n\n   1. 尽量减少FGC\n   2. MinorGC = YGC\n   3. MajorGC+MinorGC = FGC\n\n## 1.3 GC常见评估指标\n\n1. **吞吐量**：吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。\n2. **暂停时间**：执行一次垃圾回收STW时间的大小\n\n**两者不可兼得**\n\n如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。\n\n## 1.4 垃圾回收器\n\n常见垃圾回收器及其组合（远古图片，现在还有一个不是分代模型的ZGC）\n\n<img src=\"./jvm/82a369cjhi.jpeg\" alt=\"82a369cjhi\" style=\"zoom:80%;\" />\n\n## 1.5 垃圾回收器及其算法\n\nSerial是**单线程**使用**标记复制算法**的垃圾回收器作用于**新生代**\n\nSerialOld是**单线程**使用**标记整理算法**的垃圾回收器作用于**老年代**\n\nParNew是**多线程**使用**标记复制算法**的垃圾回收器作用于**新生代**\n\n\n\nParallelScavenge是**吞吐量优先**使用**标记复制算法**的垃圾回收器作用于**新生代**（吞吐量优先垃圾回收器），不支持**多线程**\n\nParallelOld是**多线程**使用**标记整理算法**的垃圾回收器作用于**老年代**\n\nCMS是**低停顿**使用**标记清除+标记整理**算法的垃圾回收器作用于**老年代**\n\n\n\nG1是新一代不分区的垃圾回收器之一，使用**标记复制**算法，作用于**年轻代和老年代**，兼顾**低停顿和高吞吐量**，优先回收高价值的垃圾。\n\n**ZGC**：是一款**基于Region内存布局**的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。\n\nZGC的工作过程可以分为4个阶段：**并发标记-并发预备重分配-并发重分配-并发重映射**等。\n\nZGC几乎在所有地方并发执行的，除了**初始标记的是STW**的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。\n\n1.8 默认是ParallelScavenge+ParallelOld。\n\n1.9+默认是G1。\n\n### 三色标记法\n\n**三色**\n\n- **白色**：还没有遍历对象\n- **灰色**：已遍历到的对象，但是它直接引用的对象还没有遍历完\n- **黑色**：已遍历到的对象，它的直接引用也已遍历完\n\n**浮动垃圾**：灰色对象可能已经是垃圾了，但是还是当成正常对象存活到下一轮GC\n\n**三色标记法黑色被误认为白色**：\n\n1. 赋值器插入一条或多条从黑色对象到白色对象的新引用\n2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用\n\n**两种解决方式**：\n\n1. **增量更新法**：\n\n   对于这种漏标的情况，CMS垃圾收集器使用的是增量更新法，就是将引用变化后的引用情况进行记录，然后之后进行标记。也就是当E->G变成了E->null,D->G，会对D->G进行记录，用于在重新标记阶段对这种情况进行处理。\n\n2. **原始快照法**：\n\n   就是对于这种E->G，然后改成D->G，正常来说，应该可能会漏掉，因为D已经是黑色对象了，就不会遍历G了，G1垃圾收集器对这种情况的处理是保存原始快照，就是在并发标记过程中，引用的变动，都会对变动前的引用情况进行记录，会按照变动前的引用情况进行标记，也就是即便E->G变成了E->null,D->G变化了，还是会记录E->G的引用情况，用于在重新标记阶段对这种情况进行处理。\n\n### CMS（标记清除灰导致内存碎片化）\n\n#### 1. 初始标记\n\n在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。\n\n#### 2. 并发标记\n\n从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。\n\n#### 3. 重新标记\n\n由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（比如：由不可达变为可达对象的数据），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。\n\n#### 4. 并发清除\n\n阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。\n\n\n\n# 2. Class文件结构\n\nClass文件为二进制，可以用powershell命令\n\n```shell\nFormat-Hex D:\\java\\learn\\out\\production\\learn\\mix\\Main.class\n```\n\n以16进制查看文件\n\n<img src=\"./jvm/image-20231116194904286.png\" alt=\"image-20231116194904286\" style=\"zoom:75%;\" />\n\n文件的大致结构为（u2表示两个字节的无符号数)\n\n<img src=\"./jvm/image-20231116202440545.png\" alt=\"image-20231116202440545\" style=\"zoom:80%;\" />\n\n## 2.1 魔数(magic number)\n\n开头四个字节'CA FE BA BE' 为称为魔数，魔数是固定的，用来指定这个文件是Class文件\n\n## 2.2 Class文件版本\n\n四个字节，前两个为副版本，后两个为主版本。如00 00 00 3A表示Class文件版本为 58.0 (也就是java 14)\n\n## 2.3 常量池\n\n两个字节表示常量池的大小00 14表示常量池大小为20。由于常量池index从1开始，所以常量数量只有19个\n\n常量的第一个字节表示常量类型，每个常量类型有不同的长度\n\n常量池是class文件最重要的一部分，名称、类型等具体内容都会被存储在常量池中，在后续修饰字段、方法时只需要记录位置，根据位置就可以获取到具体的属性。\n\n**常见常量类型：**\n\n<img src=\"./jvm/image-20231116200128095.png\" alt=\"image-20231116200128095\" style=\"zoom:80%;\" />\n\n## 2.4 访问标志\n\n之后两个字节表示访问标志\n\n<img src=\"./jvm/image-20231116202718426.png\" alt=\"image-20231116202718426\" style=\"zoom:80%;\" />\n\n## 2.5 类索引、父类索引、接口索引集合\n\n    u2             this_class;//当前类\n    u2             super_class;//父类\n    u2             interfaces_count;//接口数量\n    u2             interfaces[interfaces_count];//一个类可以实现多个接口\n\n## 2.6 字段表集合\n\n<img src=\"./jvm/image-20231116203451353.png\" alt=\"image-20231116203451353\" style=\"zoom:80%;\" />\n\n**descriptor_index**用来描述类型\n\n## 2.6 方法表集合\n\n<img src=\"./jvm/image-20231116204902025.png\" alt=\"image-20231116204902025\" style=\"zoom:80%;\" />\n\n## 2.7 属性表\n\n详见《深入理解java虚拟机》\n\n# 3. java类加载器\n\n## 3.1 类加载\n\n<img src=\"./jvm/image-20231127105115660.png\" alt=\"image-20231127105115660\" style=\"zoom:80%;\" />\n\n### 加载\n\n装载阶段，简言之，查找并加载类的二进制数据，生成Class的实例，即类模版对象。\n在加载类时，Java虚拟机必须完成以下3件事情：\n\n- 通过类的全名，获取类的二进制数据流。\n- 解析类的二进制数据流为方法区内的数据结构（Java类模型）\n- 创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口\n\n**类模板对象**\n所谓类模板对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。\n\n反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。\n\n**类模型的位置**\n加载的类在JVM中创建相应的类结构，类结构会存储在方法区(JDK1.8之前：永久代；JDK1.8及之后：元空间)。\n\n**数组类的加载**\n\n创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。\n\n### 链接\n\n1. 验证\n\n   **目的：**保证加载的字节码是合法、合理并符合规范的\n\n   <img src=\"./jvm/image-20231205215113256.png\" alt=\"image-20231205215113256\" style=\"zoom:60%;\" />\n\n   其中格式验证会和装载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。\n   格式验证之外的验证操作将会在方法区中进行。（其他验证略）\n\n2. 准备\n\n   简言之，为类的静态变量分配内存，并将其初始化为默认值。\n   在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java虚拟机为各类型变量默认的初始值如表所示。\n\n   <img src=\"./jvm/image-20231205215707315.png\" alt=\"image-20231205215707315\" style=\"zoom:70%;\" />\n\n   注意：Java并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false。\n\n3. 解析\n\n   将类、接口、字段和方法的符号引用转为直接引用。\n\n   如`System.out.println();`转换过程\n\n   <img src=\"./jvm/image-20231206112755092.png\" alt=\"image-20231206112755092\" style=\"zoom:67%;\" />\n\n   Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行。\n\n### 初始化\n\n调用<clinit>初始化方法，\n\n```java\npublic class InitializationTest1 {\n    //场景1：对于非静态的字段，不管是否进行了显式赋值，都不会生成<clinit>()方法\n    public int num = 1;\n    //场景2：静态的字段，没有显式的赋值，不会生成<clinit>()方法\n    public static int num1;\n    //场景3：比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成<clinit>()方法\n    public static final int num2 = 1;\n}\n```\n\n**类的初始化时机**\n\n1. 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。\n2. 当调用类的静态方法时，即当使用了字节码invokestatic指令。\n3. 当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。\n4. 当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(\"com.atguigu.java.Test\")\n5. 当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n6. 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。\n7. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。\n\n### 卸载\n\n类的垃圾回收过程\n\n## 3.2 双亲委派机制\n\n作用：\n\n1. 防止类库中的类被重写\n2. 避免类被重复加载\n\n<img src=\"./jvm/image-20231117160926362.png\" alt=\"image-20231117160926362\" style=\"zoom:50%;\" />\n\n\n\nBootstrap加载`%JAVA_HOME%lib`下的jar包和class文件，ExtClassLoader加载`%JAVA_HOME%lib/lib/ext`文件夹下的jar包和class类。AppClassLoader负责加载`classpath`下的类文件。系统类加载器，线程上下文加载器贯穿三个类加载器。\n\n3个关键方法loadClass()、findClass()、defineClass()\n\nloadClass双亲委派模型具体的实现\n\nfindClass从指定路径中加载Class字节流\n\ndefineClass将Class字节流翻译为Class对象\n\n## 3.3 自定义类加载器\n\n重写loadClass()方法或者重写findClass()方法\n\n```java\n//重写findClass()方法, 遵循双亲委派模型, 子类先委托父类加载需要的类，父类从指定的路径加载类, 没有则交给子类加载\npublic class MyClassLoader extends ClassLoader{\n    private final String classPath;\n    private final String className;\n\n\n    public MyClassLoader(String classPath, String className) {\n        this.classPath = classPath;\n        this.className = className;\n    }\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        byte[] data = getData();\n        if (data != null) {\n            return defineClass(className,data,0,data.length);\n        }\n        return null;\n    }\n\n    private byte[] getData(){\n        String path = classPath;\n        try {\n            FileInputStream inputStream = new FileInputStream(path);\n            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            byte[] bytes = new byte[2048];\n            int num = 0;\n            while ((num = inputStream.read(bytes)) != -1){\n                byteArrayOutputStream.write(bytes, 0,num);\n            }\n            return byteArrayOutputStream.toByteArray();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n```\n\nloadClass()方法\n\n```java\nprotected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // First, check if the class has already been loaded\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    if (parent != null) {\n                        c = parent.loadClass(name, false);\n                    } else {\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 = System.nanoTime();\n                    c = findClass(name);\n\n                    // this is the defining class loader; record the stats\n                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n```\n\n\n\n### 打破双亲委派机制\n\n双亲委派模型\n\n1. tomcat中部署多个应用时可能需要加载相同的类多次，双亲委派模型无法实现\n\n   <img src=\"./jvm/image-20231214111741606.png\" alt=\"image-20231214111741606\" style=\"zoom:70%;\" />\n\n   - 放置在/common目录中。类库可被Tomcat和所有的Web应用程序共同使用。\n\n   - 放置在/server目录中。类库可被Tomcat使用，对所有的Web应用程序都不可见。\n\n   - 放置在/shared目录中。类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。\n\n   - 放置在/WebApp/WEB-INF目录中。类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用\n\n     \n\n2. java中比较出名的SPI机制（线程上下文类加载器）\n\n   父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所指定的Classloader加载的类。这就改变了父ClassLoader不能使用子ClassLoader或是其他没有直接父子关系的classLoader加载的类的情况，即**改变了双亲委托模型**。\n\n   线程上下文类加载器就是当前线程的当前类加载器(Current Classloader)。\n\n   **在双亲委托模型下**，类加载是由下至上的，即下层的类加载器会委托上层进行加载。但是对于SPI来说，有些接口是Java核心库所提供的,而Java核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的jar包(厂商提供)， Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就**无法满足**SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。\n\n3. web应用热替换的实现（对程序动态性的最求）\n\n   \n\n### 沙箱安全机制\n\n对代码的权限进行校验，判断其是否有权限操作资源\n\n**基本组件**\n\n- **字节码校验器**：确保lava类文件遵循lava语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。\n- **类加载器**：防止恶意代码去干涉善意的代码，比如：双亲委派机制；守护了被信任的类库边界；将代码归入保护域，确定了代码的权限范围可以进行哪些资源操作\n- **存取控制器**：存取控制器可以控制核心API对操作系统的存取权限，用户可以设定控制策略。\n- **安全管理器**：安全管理器主要是核心API和操作系统之间的主要接口。比如实现权限控制，比存取控制器优先级高。\n- **安全软件包**：java.security下的类和扩展包下的类，允许用户为应用增加所需要安全特性：安全提供者、消息摘要、数字签名keytools、加密、鉴别。\n\n# 4. jvm内存模型\n\n<img src=\"./jvm/image-20231214193447991.png\" alt=\"image-20231214193447991\" style=\"zoom:80%;\" />\n\n## 4.1 程序计数器\n\n**作用**：记录当前线程的执行地址（记录字节码执行到哪了）\n\n没有规定任何OutOtMemoryError情况的区域\n\n## 4.2 栈\n\n虚拟栈和本地方法栈的区别在于，虚拟机栈执行的是java中的方法，本地方法栈中执行的是本地接口实现的方法，其内部结构差不多\n\n**栈的内部结构**：\n\n<img src=\"./jvm/image-20231214194507254.png\" alt=\"image-20231214194507254\" style=\"zoom:70%;\" />\n\n**可能抛出的异常：**\n\n- 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。\n- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常。\n\n### 栈帧\n\n一个方法对应一个栈帧\n\n<img src=\"./jvm/image-20231214195613362.png\" alt=\"image-20231214195613362\" style=\"zoom:80%;\" />\n\nJava方法有两种返回函数的方式，会导致栈帧被弹出\n\n1. 正常的函数返回，使用return指令；\n\n2. 抛出异常。\n\n### 局部变量表\n\n- 局部变量表，最基本的存储单元是Slot（变量槽）\n- 在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double)占用两个slot。\n  byte 、short 、char 在存储前被转换为int，boolean 也被转换为int，0 表示false ，非0 表示true。\n  long 和double 则占据两个Slot。\n- JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值\n- 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上\n- 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。(比如：访问long或double类型变量）\n- 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。\n\n局部变量超出作用域，其原本的slot将被重复利用\n\n### 操作数栈\n\n进行具体方法操作的初步逻辑，保存计算的中间结果\n\n一个栈深度为32bit，为一个slot（槽位）,long、double类型数据可能占两个槽位\n\n数据超过作用域后，所占槽位可以复用。\n\n**栈顶缓存技术：**\n\n基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。\n\n由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。\n\n## 4.3 堆\n\n<img src=\"./jvm/image-20231214221246377.png\" alt=\"image-20231214221246377\" style=\"zoom:80%;\" />\n\n按照分代模型，堆可分为年轻代、老年代，年轻代可分为Eden区、s0、s1区。默认比例为`Eden:s0:s1:Old = 8:1:1:20`\n\n**GC过程**\n\n1. YGC回收之后，大多数的对象会被回收，活着的进入s0\n2. 再次YGC，活着的对象eden + s0 -> s1\n3. 再次YGC，eden + s1 -> s0\n4. 年龄足够 -> 老年代 （15 CMS 6）\n5. s区装不下 -> 老年代\n\n在jdk1.7及之前会有一个堆中会有永久代的这个概念，不过永久代并不是垃圾回收的主要作用地。它主要是用来存放java中类的元数据（即java中成员变量的类型、作用范围等）所以一般把永久代称为方法区\n\n## 4.4 方法区（元空间）\n\n**存放内容：**\n\n1. 类型信息\n2. 域信息\n3. 方法信息\n4. static类变量（非final）\n\n**运行时常量池**\n\n作用：缩小字节码文件（存放指向常量池的应用而非直接的数据）\n\n内容：\n\n- 数量值\n- 字符串值\n- 类引用\n- 字段引用\n- 方法引用\n\n## 4.5 直接内存\n\n不是JVM定义的内存区域，直接向系统申请的内存，读写性能较高\n\n<img src=\"./jvm/image-20231217221608733.png\" alt=\"image-20231217221608733\" style=\"zoom:67%;\" />\n\n<img src=\"./jvm/image-20231217221643907.png\" alt=\"image-20231217221643907\" style=\"zoom:67%;\" />\n\n## 4.6 StringTable\n\njdk1.7时移到堆中，因为方法区的内存回收效率较低\n\n使用数组+链表实现\n\n# 5. 四种引用\n\n1. 强引用：就是普通的变量对对象的引用，强引用的对象不会被系统回收。\n2. 软引用：当内存空间足够时，软引用的对象不会被系统回收。当内存空间不足时，软引用的对象可能被 系统回收。通常用于内存敏感的程序中。在JDK 1.2版之后提供了SoftReference类来实现软引用。\n3. 弱引用：引用级别比软引用低，对于只有软引用的对象，不管内存是否足够， 都可能会被系统回收。在JDK 1.2版之后提供了WeakReference类来实现弱引用。\n4. 虚引用：虚引用主要用于跟踪对象被垃圾回收的状态，在垃圾回收时可以收到一个通知。。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。\n\n# 6. jvm指令及重排\n\n## i++与++i\n\n```java\n public static void main(String[] args) {\n        int x = 5;\n        int y = 0;\n        y=x++;\n        y=++x;\n    }\n\n//字节码:\n 0 iconst_5 \t//定义常数5到操作数栈\n 1 istore_1\t\t//将操作数栈顶数存到局部变量表第二个位置\n 2 iconst_0\n 3 istore_2\n 4 iload_1\t\t//将局部变量表2号位load到操作数栈中\n 5 iinc 1 by 1\t//对局部变量表2号位加1\n 8 istore_2\n     \n 9 iinc 1 by 1\t\n12 iload_1\n13 istore_2\n14 return\n//区别在于先加1，还是先把数据load到局部变量表中\n```\n\n按用途分为9类：\n\n1. 加载与存储指令\n\n   ```jvm\n    xload_<n> (x为i、l、f、d、a，n为 0 到 3)\n    xload (x为i、l、f、d、a) \n   ```\n\n   - i代表对int类型的数据操作\n   - l代表long类型的数据操作\n   - s代表short类型的数据操作\n   - b代表byte类型的数据操作\n   - c代表char类型的数据操作\n   - f代表float类型的数据操作\n   - d代表double类型的数据操作\n\n2. 算术指令\n\n3. 类型转换指令\n\n4. 对象的创建与访问指令\n\n5. 方法调用与返回指令\n\n6. 操作数栈管理指令\n\n7. 控制转移指令\n\n8. 异常处理指令\n\n9. 同步控制指令\n\n**指令重排主要是为了最大化的利用CPU资源**\n\n1. **编译器重排序**\n2. **指令集并行的重排序**\n3. **内存重排序**\n\n指令重排的原则（as - if - serial），不过多线程环境较复杂，编译器和指令优化无法识别数据依赖性，可能出现预料之外的错误。\n\n```java\n//输出结果可能为0\nprivate static int value;\n     private static boolean flag;\n\t//线程1执行\n     public static  void  init(){\n         value=8;     //语句1\n         flag=true;  //语句2\n     }\n\t//线程2执行\n     public static void getValue(){\n         if(flag){\n             System.out.println(value);\n         }\n     }\n```\n\n**解决指令重排引起的问题**（内存屏障）\n\n不同的CPU架构和操作系统都有各自对应的内存屏障指令，java为了简化这些杂乱的场景，自己封装了一套规范——java内存模型（JMM）。java中可以通过`Volatile`、`synchronized`、`final`来避免重排序而引起的错误。\n\n\n\n# 7. 常用参数\n\nJDK17 和 JDK8 部分参数有变化\n\n## 输出信息\n\njdk17 使用 -Xlog:gc:<file>来输出相关日志\n\n**输出GC信息**:-XX:+PrintGCDetails\n\n**输出GC信息**：-XX:+PrintGC\n\n**输出GC日志到文件中：**-Xloggc:<file>\n\n## 栈相关\n\n**栈内存大小：**-Xss size (即：-XX:ThreadStackSize)，栈内存越大，可创建线程数量就越少\n\n### **堆相关**：\n\n**新生代和老年代比例：** -XX:NewRatio = 2 (default 即 1：2)\n\n**Eden和s区比例：**-XX:SurvivorRatio=8（8:1:1）\n\n**设置堆空间的初始内存大小**：-Xms\n\n**设置堆空间的最大内存大小**：-Xmx\n\n## 命令行指令\n\n使用命令行指令：jinfo –flag 相关垃圾回收器参数 进程ID\n\n##  垃圾收集器设置\n\n **XX:+UseSerialGC**   \t\t新生代用Serial GC，且老年代用Serial Old GC\n\n**-XX:+UseParNewGC** \t年轻代使用ParNew收集器，老年代不受影响\n\n**-XX:ParallelGCThreads** \t限制线程数量，默认开启和CPU数据相同的线程数。\n\n**G1**：\n\n<img src=\"./jvm/image-20240326163359886.png\" alt=\"image-20240326163359886\" style=\"zoom:80%;\" />\n\n","slug":"jvm","published":1,"updated":"2024-10-30T08:45:26.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6br000uskus8ei7291y","content":"<p><strong>主要内容</strong>：</p>\n<ol>\n<li>jvm垃圾回收</li>\n<li>class文件</li>\n<li>类加载过程</li>\n<li>jvm内存模型</li>\n</ol>\n<span id=\"more\"></span>\n\n<h1 id=\"1-垃圾回收\"><a href=\"#1-垃圾回收\" class=\"headerlink\" title=\"1. 垃圾回收\"></a>1. 垃圾回收</h1><h2 id=\"1-1-基础\"><a href=\"#1-1-基础\" class=\"headerlink\" title=\"1.1 基础\"></a>1.1 基础</h2><h3 id=\"垃圾的定义\"><a href=\"#垃圾的定义\" class=\"headerlink\" title=\"垃圾的定义\"></a>垃圾的定义</h3><p>没有任何引用指向的一个对象或者多个对象（循环引用）</p>\n<h3 id=\"垃圾定位\"><a href=\"#垃圾定位\" class=\"headerlink\" title=\"垃圾定位\"></a>垃圾定位</h3><ol>\n<li><p>引用计数（ReferenceCount）</p>\n<p>加一个引用计数器+1，减少一个计数器-1（易出现循环引用的问题）</p>\n</li>\n<li><p>根可达算法(RootSearching)</p>\n<p>常见根：</p>\n<ul>\n<li>JVM statck 虚拟机栈</li>\n<li>native method statck 本地方法栈</li>\n<li>run-time constant pool 常量池</li>\n<li>static references in method area 方法区的静态引用 </li>\n<li>Clazz</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"GC算法\"><a href=\"#GC算法\" class=\"headerlink\" title=\"GC算法\"></a>GC算法</h3><ol>\n<li><p>标记清除(mark sweep) - 位置不连续 产生碎片 效率偏低（两遍扫描）</p>\n<img src=\"/2024/09/10/jvm/image-20231201151500158.png\" alt=\"image-20231201151500158\" style=\"zoom:80%;\">\n\n<p>碎片空间可能导致大对象没有地方存放</p>\n</li>\n<li><p>拷贝算法 (copying) - 没有碎片，浪费空间</p>\n<img src=\"/2024/09/10/jvm/image-20231201151606407.png\" alt=\"image-20231201151606407\" style=\"zoom:80%;\">\n\n<p>将空间分成两半，gc时将使用一半的存活对象复制到另一半</p>\n</li>\n<li><p>标记压缩(mark compact) - 没有碎片，效率偏低（两遍扫描，指针需要调整）</p>\n<img src=\"/2024/09/10/jvm/image-20231201151745264.png\" alt=\"image-20231201151745264\" style=\"zoom:80%;\"></li>\n</ol>\n<h2 id=\"1-2-JVM内存分代模型\"><a href=\"#1-2-JVM内存分代模型\" class=\"headerlink\" title=\"1.2 JVM内存分代模型\"></a>1.2 JVM内存分代模型</h2><ol>\n<li><p>部分垃圾回收器使用的模型</p>\n<blockquote>\n<p>除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型</p>\n<p>G1是逻辑分代，物理不分代</p>\n<p>除此之外不仅逻辑分代，而且物理分代</p>\n</blockquote>\n</li>\n<li><p>新生代 + 老年代 + 永久代（1.7）Perm Generation&#x2F; 元数据区(1.8) Metaspace</p>\n<ol>\n<li>永久代 元数据 - Class</li>\n<li>永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存）</li>\n<li>字符串常量 1.7 - 永久代，1.8 - 堆</li>\n<li>MethodArea逻辑概念 - 永久代、元数据</li>\n</ol>\n</li>\n<li><p>新生代 &#x3D; Eden + 2个suvivor区 </p>\n<ol>\n<li>YGC回收之后，大多数的对象会被回收，活着的进入s0</li>\n<li>再次YGC，活着的对象eden + s0 -&gt; s1</li>\n<li>再次YGC，eden + s1 -&gt; s0</li>\n<li>年龄足够 -&gt; 老年代 （15 CMS 6）</li>\n<li>s区装不下 -&gt; 老年代</li>\n</ol>\n</li>\n<li><p>老年代</p>\n<ol>\n<li>顽固分子</li>\n<li>老年代满了FGC Full GC</li>\n</ol>\n</li>\n<li><p>GC Tuning (Generation)</p>\n<ol>\n<li>尽量减少FGC</li>\n<li>MinorGC &#x3D; YGC</li>\n<li>MajorGC+MinorGC &#x3D; FGC</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"1-3-GC常见评估指标\"><a href=\"#1-3-GC常见评估指标\" class=\"headerlink\" title=\"1.3 GC常见评估指标\"></a>1.3 GC常见评估指标</h2><ol>\n<li><strong>吞吐量</strong>：吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间 + 垃圾收集时间）。</li>\n<li><strong>暂停时间</strong>：执行一次垃圾回收STW时间的大小</li>\n</ol>\n<p><strong>两者不可兼得</strong></p>\n<p>如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p>\n<h2 id=\"1-4-垃圾回收器\"><a href=\"#1-4-垃圾回收器\" class=\"headerlink\" title=\"1.4 垃圾回收器\"></a>1.4 垃圾回收器</h2><p>常见垃圾回收器及其组合（远古图片，现在还有一个不是分代模型的ZGC）</p>\n<img src=\"/2024/09/10/jvm/82a369cjhi.jpeg\" alt=\"82a369cjhi\" style=\"zoom:80%;\">\n\n<h2 id=\"1-5-垃圾回收器及其算法\"><a href=\"#1-5-垃圾回收器及其算法\" class=\"headerlink\" title=\"1.5 垃圾回收器及其算法\"></a>1.5 垃圾回收器及其算法</h2><p>Serial是<strong>单线程</strong>使用<strong>标记复制算法</strong>的垃圾回收器作用于<strong>新生代</strong></p>\n<p>SerialOld是<strong>单线程</strong>使用<strong>标记整理算法</strong>的垃圾回收器作用于<strong>老年代</strong></p>\n<p>ParNew是<strong>多线程</strong>使用<strong>标记复制算法</strong>的垃圾回收器作用于<strong>新生代</strong></p>\n<p>ParallelScavenge是<strong>吞吐量优先</strong>使用<strong>标记复制算法</strong>的垃圾回收器作用于<strong>新生代</strong>（吞吐量优先垃圾回收器），不支持<strong>多线程</strong></p>\n<p>ParallelOld是<strong>多线程</strong>使用<strong>标记整理算法</strong>的垃圾回收器作用于<strong>老年代</strong></p>\n<p>CMS是<strong>低停顿</strong>使用<strong>标记清除+标记整理</strong>算法的垃圾回收器作用于<strong>老年代</strong></p>\n<p>G1是新一代不分区的垃圾回收器之一，使用<strong>标记复制</strong>算法，作用于<strong>年轻代和老年代</strong>，兼顾<strong>低停顿和高吞吐量</strong>，优先回收高价值的垃圾。</p>\n<p><strong>ZGC</strong>：是一款<strong>基于Region内存布局</strong>的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p>\n<p>ZGC的工作过程可以分为4个阶段：<strong>并发标记-并发预备重分配-并发重分配-并发重映射</strong>等。</p>\n<p>ZGC几乎在所有地方并发执行的，除了<strong>初始标记的是STW</strong>的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>\n<p>1.8 默认是ParallelScavenge+ParallelOld。</p>\n<p>1.9+默认是G1。</p>\n<h3 id=\"三色标记法\"><a href=\"#三色标记法\" class=\"headerlink\" title=\"三色标记法\"></a>三色标记法</h3><p><strong>三色</strong></p>\n<ul>\n<li><strong>白色</strong>：还没有遍历对象</li>\n<li><strong>灰色</strong>：已遍历到的对象，但是它直接引用的对象还没有遍历完</li>\n<li><strong>黑色</strong>：已遍历到的对象，它的直接引用也已遍历完</li>\n</ul>\n<p><strong>浮动垃圾</strong>：灰色对象可能已经是垃圾了，但是还是当成正常对象存活到下一轮GC</p>\n<p><strong>三色标记法黑色被误认为白色</strong>：</p>\n<ol>\n<li>赋值器插入一条或多条从黑色对象到白色对象的新引用</li>\n<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>\n</ol>\n<p><strong>两种解决方式</strong>：</p>\n<ol>\n<li><p><strong>增量更新法</strong>：</p>\n<p>对于这种漏标的情况，CMS垃圾收集器使用的是增量更新法，就是将引用变化后的引用情况进行记录，然后之后进行标记。也就是当E-&gt;G变成了E-&gt;null,D-&gt;G，会对D-&gt;G进行记录，用于在重新标记阶段对这种情况进行处理。</p>\n</li>\n<li><p><strong>原始快照法</strong>：</p>\n<p>就是对于这种E-&gt;G，然后改成D-&gt;G，正常来说，应该可能会漏掉，因为D已经是黑色对象了，就不会遍历G了，G1垃圾收集器对这种情况的处理是保存原始快照，就是在并发标记过程中，引用的变动，都会对变动前的引用情况进行记录，会按照变动前的引用情况进行标记，也就是即便E-&gt;G变成了E-&gt;null,D-&gt;G变化了，还是会记录E-&gt;G的引用情况，用于在重新标记阶段对这种情况进行处理。</p>\n</li>\n</ol>\n<h3 id=\"CMS（标记清除灰导致内存碎片化）\"><a href=\"#CMS（标记清除灰导致内存碎片化）\" class=\"headerlink\" title=\"CMS（标记清除灰导致内存碎片化）\"></a>CMS（标记清除灰导致内存碎片化）</h3><h4 id=\"1-初始标记\"><a href=\"#1-初始标记\" class=\"headerlink\" title=\"1. 初始标记\"></a>1. 初始标记</h4><p>在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>\n<h4 id=\"2-并发标记\"><a href=\"#2-并发标记\" class=\"headerlink\" title=\"2. 并发标记\"></a>2. 并发标记</h4><p>从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>\n<h4 id=\"3-重新标记\"><a href=\"#3-重新标记\" class=\"headerlink\" title=\"3. 重新标记\"></a>3. 重新标记</h4><p>由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（比如：由不可达变为可达对象的数据），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>\n<h4 id=\"4-并发清除\"><a href=\"#4-并发清除\" class=\"headerlink\" title=\"4. 并发清除\"></a>4. 并发清除</h4><p>阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p>\n<h1 id=\"2-Class文件结构\"><a href=\"#2-Class文件结构\" class=\"headerlink\" title=\"2. Class文件结构\"></a>2. Class文件结构</h1><p>Class文件为二进制，可以用powershell命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Format-Hex D:\\java\\learn\\out\\production\\learn\\mix\\Main.class</span><br></pre></td></tr></table></figure>\n\n<p>以16进制查看文件</p>\n<img src=\"/2024/09/10/jvm/image-20231116194904286.png\" alt=\"image-20231116194904286\" style=\"zoom:75%;\">\n\n<p>文件的大致结构为（u2表示两个字节的无符号数)</p>\n<img src=\"/2024/09/10/jvm/image-20231116202440545.png\" alt=\"image-20231116202440545\" style=\"zoom:80%;\">\n\n<h2 id=\"2-1-魔数-magic-number\"><a href=\"#2-1-魔数-magic-number\" class=\"headerlink\" title=\"2.1 魔数(magic number)\"></a>2.1 魔数(magic number)</h2><p>开头四个字节’CA FE BA BE’ 为称为魔数，魔数是固定的，用来指定这个文件是Class文件</p>\n<h2 id=\"2-2-Class文件版本\"><a href=\"#2-2-Class文件版本\" class=\"headerlink\" title=\"2.2 Class文件版本\"></a>2.2 Class文件版本</h2><p>四个字节，前两个为副版本，后两个为主版本。如00 00 00 3A表示Class文件版本为 58.0 (也就是java 14)</p>\n<h2 id=\"2-3-常量池\"><a href=\"#2-3-常量池\" class=\"headerlink\" title=\"2.3 常量池\"></a>2.3 常量池</h2><p>两个字节表示常量池的大小00 14表示常量池大小为20。由于常量池index从1开始，所以常量数量只有19个</p>\n<p>常量的第一个字节表示常量类型，每个常量类型有不同的长度</p>\n<p>常量池是class文件最重要的一部分，名称、类型等具体内容都会被存储在常量池中，在后续修饰字段、方法时只需要记录位置，根据位置就可以获取到具体的属性。</p>\n<p><strong>常见常量类型：</strong></p>\n<img src=\"/2024/09/10/jvm/image-20231116200128095.png\" alt=\"image-20231116200128095\" style=\"zoom:80%;\">\n\n<h2 id=\"2-4-访问标志\"><a href=\"#2-4-访问标志\" class=\"headerlink\" title=\"2.4 访问标志\"></a>2.4 访问标志</h2><p>之后两个字节表示访问标志</p>\n<img src=\"/2024/09/10/jvm/image-20231116202718426.png\" alt=\"image-20231116202718426\" style=\"zoom:80%;\">\n\n<h2 id=\"2-5-类索引、父类索引、接口索引集合\"><a href=\"#2-5-类索引、父类索引、接口索引集合\" class=\"headerlink\" title=\"2.5 类索引、父类索引、接口索引集合\"></a>2.5 类索引、父类索引、接口索引集合</h2><pre><code>u2             this_class;//当前类\nu2             super_class;//父类\nu2             interfaces_count;//接口数量\nu2             interfaces[interfaces_count];//一个类可以实现多个接口\n</code></pre>\n<h2 id=\"2-6-字段表集合\"><a href=\"#2-6-字段表集合\" class=\"headerlink\" title=\"2.6 字段表集合\"></a>2.6 字段表集合</h2><img src=\"/2024/09/10/jvm/image-20231116203451353.png\" alt=\"image-20231116203451353\" style=\"zoom:80%;\">\n\n<p><strong>descriptor_index</strong>用来描述类型</p>\n<h2 id=\"2-6-方法表集合\"><a href=\"#2-6-方法表集合\" class=\"headerlink\" title=\"2.6 方法表集合\"></a>2.6 方法表集合</h2><img src=\"/2024/09/10/jvm/image-20231116204902025.png\" alt=\"image-20231116204902025\" style=\"zoom:80%;\">\n\n<h2 id=\"2-7-属性表\"><a href=\"#2-7-属性表\" class=\"headerlink\" title=\"2.7 属性表\"></a>2.7 属性表</h2><p>详见《深入理解java虚拟机》</p>\n<h1 id=\"3-java类加载器\"><a href=\"#3-java类加载器\" class=\"headerlink\" title=\"3. java类加载器\"></a>3. java类加载器</h1><h2 id=\"3-1-类加载\"><a href=\"#3-1-类加载\" class=\"headerlink\" title=\"3.1 类加载\"></a>3.1 类加载</h2><img src=\"/2024/09/10/jvm/image-20231127105115660.png\" alt=\"image-20231127105115660\" style=\"zoom:80%;\">\n\n<h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>装载阶段，简言之，查找并加载类的二进制数据，生成Class的实例，即类模版对象。<br>在加载类时，Java虚拟机必须完成以下3件事情：</p>\n<ul>\n<li>通过类的全名，获取类的二进制数据流。</li>\n<li>解析类的二进制数据流为方法区内的数据结构（Java类模型）</li>\n<li>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>\n</ul>\n<p><strong>类模板对象</strong><br>所谓类模板对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</p>\n<p>反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。</p>\n<p><strong>类模型的位置</strong><br>加载的类在JVM中创建相应的类结构，类结构会存储在方法区(JDK1.8之前：永久代；JDK1.8及之后：元空间)。</p>\n<p><strong>数组类的加载</strong></p>\n<p>创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。</p>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><ol>\n<li><p>验证</p>\n<p><strong>目的：</strong>保证加载的字节码是合法、合理并符合规范的</p>\n<img src=\"/2024/09/10/jvm/image-20231205215113256.png\" alt=\"image-20231205215113256\" style=\"zoom:60%;\">\n\n<p>其中格式验证会和装载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。<br>格式验证之外的验证操作将会在方法区中进行。（其他验证略）</p>\n</li>\n<li><p>准备</p>\n<p>简言之，为类的静态变量分配内存，并将其初始化为默认值。<br>在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java虚拟机为各类型变量默认的初始值如表所示。</p>\n<img src=\"/2024/09/10/jvm/image-20231205215707315.png\" alt=\"image-20231205215707315\" style=\"zoom:70%;\">\n\n<p>注意：Java并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false。</p>\n</li>\n<li><p>解析</p>\n<p>将类、接口、字段和方法的符号引用转为直接引用。</p>\n<p>如<code>System.out.println();</code>转换过程</p>\n<img src=\"/2024/09/10/jvm/image-20231206112755092.png\" alt=\"image-20231206112755092\" style=\"zoom:67%;\">\n\n<p>Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>\n</li>\n</ol>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>调用<clinit>初始化方法，</clinit></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InitializationTest1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//场景1：对于非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//场景2：静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> num1;</span><br><span class=\"line\">    <span class=\"comment\">//场景3：比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">num2</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>类的初始化时机</strong></p>\n<ol>\n<li>当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。</li>\n<li>当调用类的静态方法时，即当使用了字节码invokestatic指令。</li>\n<li>当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。</li>\n<li>当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”)</li>\n<li>当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>\n<li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>\n</ol>\n<h3 id=\"卸载\"><a href=\"#卸载\" class=\"headerlink\" title=\"卸载\"></a>卸载</h3><p>类的垃圾回收过程</p>\n<h2 id=\"3-2-双亲委派机制\"><a href=\"#3-2-双亲委派机制\" class=\"headerlink\" title=\"3.2 双亲委派机制\"></a>3.2 双亲委派机制</h2><p>作用：</p>\n<ol>\n<li>防止类库中的类被重写</li>\n<li>避免类被重复加载</li>\n</ol>\n<img src=\"/2024/09/10/jvm/image-20231117160926362.png\" alt=\"image-20231117160926362\" style=\"zoom:50%;\">\n\n\n\n<p>Bootstrap加载<code>%JAVA_HOME%lib</code>下的jar包和class文件，ExtClassLoader加载<code>%JAVA_HOME%lib/lib/ext</code>文件夹下的jar包和class类。AppClassLoader负责加载<code>classpath</code>下的类文件。系统类加载器，线程上下文加载器贯穿三个类加载器。</p>\n<p>3个关键方法loadClass()、findClass()、defineClass()</p>\n<p>loadClass双亲委派模型具体的实现</p>\n<p>findClass从指定路径中加载Class字节流</p>\n<p>defineClass将Class字节流翻译为Class对象</p>\n<h2 id=\"3-3-自定义类加载器\"><a href=\"#3-3-自定义类加载器\" class=\"headerlink\" title=\"3.3 自定义类加载器\"></a>3.3 自定义类加载器</h2><p>重写loadClass()方法或者重写findClass()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重写findClass()方法, 遵循双亲委派模型, 子类先委托父类加载需要的类，父类从指定的路径加载类, 没有则交给子类加载</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassLoader</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String classPath;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String className;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyClassLoader</span><span class=\"params\">(String classPath, String className)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.classPath = classPath;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.className = className;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] data = getData();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defineClass(className,data,<span class=\"number\">0</span>,data.length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">byte</span>[] getData()&#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> classPath;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">FileInputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(path);</span><br><span class=\"line\">            <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">byteArrayOutputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">            <span class=\"type\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">2048</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((num = inputStream.read(bytes)) != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                byteArrayOutputStream.write(bytes, <span class=\"number\">0</span>,num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> byteArrayOutputStream.toByteArray();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>loadClass()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"type\">boolean</span> resolve)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> ClassNotFoundException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// First, check if the class has already been loaded</span></span><br><span class=\"line\">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">t0</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (parent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        c = parent.loadClass(name, <span class=\"literal\">false</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ClassNotFoundException thrown if class not found</span></span><br><span class=\"line\">                    <span class=\"comment\">// from the non-null parent class loader</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// If still not found, then invoke findClass in order</span></span><br><span class=\"line\">                    <span class=\"comment\">// to find the class.</span></span><br><span class=\"line\">                    <span class=\"type\">long</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                    c = findClass(name);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// this is the defining class loader; record the stats</span></span><br><span class=\"line\">                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                    PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">                resolveClass(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"打破双亲委派机制\"><a href=\"#打破双亲委派机制\" class=\"headerlink\" title=\"打破双亲委派机制\"></a>打破双亲委派机制</h3><p>双亲委派模型</p>\n<ol>\n<li><p>tomcat中部署多个应用时可能需要加载相同的类多次，双亲委派模型无法实现</p>\n<img src=\"/2024/09/10/jvm/image-20231214111741606.png\" alt=\"image-20231214111741606\" style=\"zoom:70%;\">\n\n<ul>\n<li><p>放置在&#x2F;common目录中。类库可被Tomcat和所有的Web应用程序共同使用。</p>\n</li>\n<li><p>放置在&#x2F;server目录中。类库可被Tomcat使用，对所有的Web应用程序都不可见。</p>\n</li>\n<li><p>放置在&#x2F;shared目录中。类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</p>\n</li>\n<li><p>放置在&#x2F;WebApp&#x2F;WEB-INF目录中。类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用</p>\n</li>\n</ul>\n</li>\n<li><p>java中比较出名的SPI机制（线程上下文类加载器）</p>\n<p>父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所指定的Classloader加载的类。这就改变了父ClassLoader不能使用子ClassLoader或是其他没有直接父子关系的classLoader加载的类的情况，即<strong>改变了双亲委托模型</strong>。</p>\n<p>线程上下文类加载器就是当前线程的当前类加载器(Current Classloader)。</p>\n<p><strong>在双亲委托模型下</strong>，类加载是由下至上的，即下层的类加载器会委托上层进行加载。但是对于SPI来说，有些接口是Java核心库所提供的,而Java核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的jar包(厂商提供)， Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就<strong>无法满足</strong>SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。</p>\n</li>\n<li><p>web应用热替换的实现（对程序动态性的最求）</p>\n</li>\n</ol>\n<h3 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h3><p>对代码的权限进行校验，判断其是否有权限操作资源</p>\n<p><strong>基本组件</strong></p>\n<ul>\n<li><strong>字节码校验器</strong>：确保lava类文件遵循lava语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。</li>\n<li><strong>类加载器</strong>：防止恶意代码去干涉善意的代码，比如：双亲委派机制；守护了被信任的类库边界；将代码归入保护域，确定了代码的权限范围可以进行哪些资源操作</li>\n<li><strong>存取控制器</strong>：存取控制器可以控制核心API对操作系统的存取权限，用户可以设定控制策略。</li>\n<li><strong>安全管理器</strong>：安全管理器主要是核心API和操作系统之间的主要接口。比如实现权限控制，比存取控制器优先级高。</li>\n<li><strong>安全软件包</strong>：java.security下的类和扩展包下的类，允许用户为应用增加所需要安全特性：安全提供者、消息摘要、数字签名keytools、加密、鉴别。</li>\n</ul>\n<h1 id=\"4-jvm内存模型\"><a href=\"#4-jvm内存模型\" class=\"headerlink\" title=\"4. jvm内存模型\"></a>4. jvm内存模型</h1><img src=\"/2024/09/10/jvm/image-20231214193447991.png\" alt=\"image-20231214193447991\" style=\"zoom:80%;\">\n\n<h2 id=\"4-1-程序计数器\"><a href=\"#4-1-程序计数器\" class=\"headerlink\" title=\"4.1 程序计数器\"></a>4.1 程序计数器</h2><p><strong>作用</strong>：记录当前线程的执行地址（记录字节码执行到哪了）</p>\n<p>没有规定任何OutOtMemoryError情况的区域</p>\n<h2 id=\"4-2-栈\"><a href=\"#4-2-栈\" class=\"headerlink\" title=\"4.2 栈\"></a>4.2 栈</h2><p>虚拟栈和本地方法栈的区别在于，虚拟机栈执行的是java中的方法，本地方法栈中执行的是本地接口实现的方法，其内部结构差不多</p>\n<p><strong>栈的内部结构</strong>：</p>\n<img src=\"/2024/09/10/jvm/image-20231214194507254.png\" alt=\"image-20231214194507254\" style=\"zoom:70%;\">\n\n<p><strong>可能抛出的异常：</strong></p>\n<ul>\n<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。</li>\n<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常。</li>\n</ul>\n<h3 id=\"栈帧\"><a href=\"#栈帧\" class=\"headerlink\" title=\"栈帧\"></a>栈帧</h3><p>一个方法对应一个栈帧</p>\n<img src=\"/2024/09/10/jvm/image-20231214195613362.png\" alt=\"image-20231214195613362\" style=\"zoom:80%;\">\n\n<p>Java方法有两种返回函数的方式，会导致栈帧被弹出</p>\n<ol>\n<li><p>正常的函数返回，使用return指令；</p>\n</li>\n<li><p>抛出异常。</p>\n</li>\n</ol>\n<h3 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h3><ul>\n<li>局部变量表，最基本的存储单元是Slot（变量槽）</li>\n<li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double)占用两个slot。<br>byte 、short 、char 在存储前被转换为int，boolean 也被转换为int，0 表示false ，非0 表示true。<br>long 和double 则占据两个Slot。</li>\n<li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>\n<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上</li>\n<li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。(比如：访问long或double类型变量）</li>\n<li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</li>\n</ul>\n<p>局部变量超出作用域，其原本的slot将被重复利用</p>\n<h3 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h3><p>进行具体方法操作的初步逻辑，保存计算的中间结果</p>\n<p>一个栈深度为32bit，为一个slot（槽位）,long、double类型数据可能占两个槽位</p>\n<p>数据超过作用域后，所占槽位可以复用。</p>\n<p><strong>栈顶缓存技术：</strong></p>\n<p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数。</p>\n<p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</p>\n<h2 id=\"4-3-堆\"><a href=\"#4-3-堆\" class=\"headerlink\" title=\"4.3 堆\"></a>4.3 堆</h2><img src=\"/2024/09/10/jvm/image-20231214221246377.png\" alt=\"image-20231214221246377\" style=\"zoom:80%;\">\n\n<p>按照分代模型，堆可分为年轻代、老年代，年轻代可分为Eden区、s0、s1区。默认比例为<code>Eden:s0:s1:Old = 8:1:1:20</code></p>\n<p><strong>GC过程</strong></p>\n<ol>\n<li>YGC回收之后，大多数的对象会被回收，活着的进入s0</li>\n<li>再次YGC，活着的对象eden + s0 -&gt; s1</li>\n<li>再次YGC，eden + s1 -&gt; s0</li>\n<li>年龄足够 -&gt; 老年代 （15 CMS 6）</li>\n<li>s区装不下 -&gt; 老年代</li>\n</ol>\n<p>在jdk1.7及之前会有一个堆中会有永久代的这个概念，不过永久代并不是垃圾回收的主要作用地。它主要是用来存放java中类的元数据（即java中成员变量的类型、作用范围等）所以一般把永久代称为方法区</p>\n<h2 id=\"4-4-方法区（元空间）\"><a href=\"#4-4-方法区（元空间）\" class=\"headerlink\" title=\"4.4 方法区（元空间）\"></a>4.4 方法区（元空间）</h2><p><strong>存放内容：</strong></p>\n<ol>\n<li>类型信息</li>\n<li>域信息</li>\n<li>方法信息</li>\n<li>static类变量（非final）</li>\n</ol>\n<p><strong>运行时常量池</strong></p>\n<p>作用：缩小字节码文件（存放指向常量池的应用而非直接的数据）</p>\n<p>内容：</p>\n<ul>\n<li>数量值</li>\n<li>字符串值</li>\n<li>类引用</li>\n<li>字段引用</li>\n<li>方法引用</li>\n</ul>\n<h2 id=\"4-5-直接内存\"><a href=\"#4-5-直接内存\" class=\"headerlink\" title=\"4.5 直接内存\"></a>4.5 直接内存</h2><p>不是JVM定义的内存区域，直接向系统申请的内存，读写性能较高</p>\n<img src=\"/2024/09/10/jvm/image-20231217221608733.png\" alt=\"image-20231217221608733\" style=\"zoom:67%;\">\n\n<img src=\"/2024/09/10/jvm/image-20231217221643907.png\" alt=\"image-20231217221643907\" style=\"zoom:67%;\">\n\n<h2 id=\"4-6-StringTable\"><a href=\"#4-6-StringTable\" class=\"headerlink\" title=\"4.6 StringTable\"></a>4.6 StringTable</h2><p>jdk1.7时移到堆中，因为方法区的内存回收效率较低</p>\n<p>使用数组+链表实现</p>\n<h1 id=\"5-四种引用\"><a href=\"#5-四种引用\" class=\"headerlink\" title=\"5. 四种引用\"></a>5. 四种引用</h1><ol>\n<li>强引用：就是普通的变量对对象的引用，强引用的对象不会被系统回收。</li>\n<li>软引用：当内存空间足够时，软引用的对象不会被系统回收。当内存空间不足时，软引用的对象可能被 系统回收。通常用于内存敏感的程序中。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>\n<li>弱引用：引用级别比软引用低，对于只有软引用的对象，不管内存是否足够， 都可能会被系统回收。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>\n<li>虚引用：虚引用主要用于跟踪对象被垃圾回收的状态，在垃圾回收时可以收到一个通知。。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li>\n</ol>\n<h1 id=\"6-jvm指令及重排\"><a href=\"#6-jvm指令及重排\" class=\"headerlink\" title=\"6. jvm指令及重排\"></a>6. jvm指令及重排</h1><h2 id=\"i-与-i\"><a href=\"#i-与-i\" class=\"headerlink\" title=\"i++与++i\"></a>i++与++i</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        y=x++;</span><br><span class=\"line\">        y=++x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//字节码:</span></span><br><span class=\"line\"> <span class=\"number\">0</span> iconst_5 \t<span class=\"comment\">//定义常数5到操作数栈</span></span><br><span class=\"line\"> <span class=\"number\">1</span> istore_1\t\t<span class=\"comment\">//将操作数栈顶数存到局部变量表第二个位置</span></span><br><span class=\"line\"> <span class=\"number\">2</span> iconst_0</span><br><span class=\"line\"> <span class=\"number\">3</span> istore_2</span><br><span class=\"line\"> <span class=\"number\">4</span> iload_1\t\t<span class=\"comment\">//将局部变量表2号位load到操作数栈中</span></span><br><span class=\"line\"> <span class=\"number\">5</span> iinc <span class=\"number\">1</span> by <span class=\"number\">1</span>\t<span class=\"comment\">//对局部变量表2号位加1</span></span><br><span class=\"line\"> <span class=\"number\">8</span> istore_2</span><br><span class=\"line\">     </span><br><span class=\"line\"> <span class=\"number\">9</span> iinc <span class=\"number\">1</span> by <span class=\"number\">1</span>\t</span><br><span class=\"line\"><span class=\"number\">12</span> iload_1</span><br><span class=\"line\"><span class=\"number\">13</span> istore_2</span><br><span class=\"line\"><span class=\"number\">14</span> <span class=\"keyword\">return</span></span><br><span class=\"line\"><span class=\"comment\">//区别在于先加1，还是先把数据load到局部变量表中</span></span><br></pre></td></tr></table></figure>\n\n<p>按用途分为9类：</p>\n<ol>\n<li><p>加载与存储指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xload_&lt;n&gt; (x为i、l、f、d、a，n为 0 到 3)</span><br><span class=\"line\">xload (x为i、l、f、d、a) </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>i代表对int类型的数据操作</li>\n<li>l代表long类型的数据操作</li>\n<li>s代表short类型的数据操作</li>\n<li>b代表byte类型的数据操作</li>\n<li>c代表char类型的数据操作</li>\n<li>f代表float类型的数据操作</li>\n<li>d代表double类型的数据操作</li>\n</ul>\n</li>\n<li><p>算术指令</p>\n</li>\n<li><p>类型转换指令</p>\n</li>\n<li><p>对象的创建与访问指令</p>\n</li>\n<li><p>方法调用与返回指令</p>\n</li>\n<li><p>操作数栈管理指令</p>\n</li>\n<li><p>控制转移指令</p>\n</li>\n<li><p>异常处理指令</p>\n</li>\n<li><p>同步控制指令</p>\n</li>\n</ol>\n<p><strong>指令重排主要是为了最大化的利用CPU资源</strong></p>\n<ol>\n<li><strong>编译器重排序</strong></li>\n<li><strong>指令集并行的重排序</strong></li>\n<li><strong>内存重排序</strong></li>\n</ol>\n<p>指令重排的原则（as - if - serial），不过多线程环境较复杂，编译器和指令优化无法识别数据依赖性，可能出现预料之外的错误。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//输出结果可能为0</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> value;</span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> flag;</span><br><span class=\"line\">\t<span class=\"comment\">//线程1执行</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  <span class=\"keyword\">void</span>  <span class=\"title function_\">init</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">         value=<span class=\"number\">8</span>;     <span class=\"comment\">//语句1</span></span><br><span class=\"line\">         flag=<span class=\"literal\">true</span>;  <span class=\"comment\">//语句2</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//线程2执行</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getValue</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">             System.out.println(value);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解决指令重排引起的问题</strong>（内存屏障）</p>\n<p>不同的CPU架构和操作系统都有各自对应的内存屏障指令，java为了简化这些杂乱的场景，自己封装了一套规范——java内存模型（JMM）。java中可以通过<code>Volatile</code>、<code>synchronized</code>、<code>final</code>来避免重排序而引起的错误。</p>\n<h1 id=\"7-常用参数\"><a href=\"#7-常用参数\" class=\"headerlink\" title=\"7. 常用参数\"></a>7. 常用参数</h1><p>JDK17 和 JDK8 部分参数有变化</p>\n<h2 id=\"输出信息\"><a href=\"#输出信息\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h2><p>jdk17 使用 -Xlog:gc:<file>来输出相关日志</file></p>\n<p><strong>输出GC信息</strong>:-XX:+PrintGCDetails</p>\n<p><strong>输出GC信息</strong>：-XX:+PrintGC</p>\n<p><strong>输出GC日志到文件中：</strong>-Xloggc:<file></file></p>\n<h2 id=\"栈相关\"><a href=\"#栈相关\" class=\"headerlink\" title=\"栈相关\"></a>栈相关</h2><p><strong>栈内存大小：</strong>-Xss size (即：-XX:ThreadStackSize)，栈内存越大，可创建线程数量就越少</p>\n<h3 id=\"堆相关：\"><a href=\"#堆相关：\" class=\"headerlink\" title=\"堆相关：\"></a><strong>堆相关</strong>：</h3><p><strong>新生代和老年代比例：</strong> -XX:NewRatio &#x3D; 2 (default 即 1：2)</p>\n<p><strong>Eden和s区比例：</strong>-XX:SurvivorRatio&#x3D;8（8:1:1）</p>\n<p><strong>设置堆空间的初始内存大小</strong>：-Xms</p>\n<p><strong>设置堆空间的最大内存大小</strong>：-Xmx</p>\n<h2 id=\"命令行指令\"><a href=\"#命令行指令\" class=\"headerlink\" title=\"命令行指令\"></a>命令行指令</h2><p>使用命令行指令：jinfo –flag 相关垃圾回收器参数 进程ID</p>\n<h2 id=\"垃圾收集器设置\"><a href=\"#垃圾收集器设置\" class=\"headerlink\" title=\"垃圾收集器设置\"></a>垃圾收集器设置</h2><p> <strong>XX:+UseSerialGC</strong>   \t\t新生代用Serial GC，且老年代用Serial Old GC</p>\n<p><strong>-XX:+UseParNewGC</strong> \t年轻代使用ParNew收集器，老年代不受影响</p>\n<p><strong>-XX:ParallelGCThreads</strong> \t限制线程数量，默认开启和CPU数据相同的线程数。</p>\n<p><strong>G1</strong>：</p>\n<img src=\"/2024/09/10/jvm/image-20240326163359886.png\" alt=\"image-20240326163359886\" style=\"zoom:80%;\">\n\n","site":{"data":{}},"length":7063,"excerpt":"<p><strong>主要内容</strong>：</p>\n<ol>\n<li>jvm垃圾回收</li>\n<li>class文件</li>\n<li>类加载过程</li>\n<li>jvm内存模型</li>\n</ol>","more":"<h1 id=\"1-垃圾回收\"><a href=\"#1-垃圾回收\" class=\"headerlink\" title=\"1. 垃圾回收\"></a>1. 垃圾回收</h1><h2 id=\"1-1-基础\"><a href=\"#1-1-基础\" class=\"headerlink\" title=\"1.1 基础\"></a>1.1 基础</h2><h3 id=\"垃圾的定义\"><a href=\"#垃圾的定义\" class=\"headerlink\" title=\"垃圾的定义\"></a>垃圾的定义</h3><p>没有任何引用指向的一个对象或者多个对象（循环引用）</p>\n<h3 id=\"垃圾定位\"><a href=\"#垃圾定位\" class=\"headerlink\" title=\"垃圾定位\"></a>垃圾定位</h3><ol>\n<li><p>引用计数（ReferenceCount）</p>\n<p>加一个引用计数器+1，减少一个计数器-1（易出现循环引用的问题）</p>\n</li>\n<li><p>根可达算法(RootSearching)</p>\n<p>常见根：</p>\n<ul>\n<li>JVM statck 虚拟机栈</li>\n<li>native method statck 本地方法栈</li>\n<li>run-time constant pool 常量池</li>\n<li>static references in method area 方法区的静态引用 </li>\n<li>Clazz</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"GC算法\"><a href=\"#GC算法\" class=\"headerlink\" title=\"GC算法\"></a>GC算法</h3><ol>\n<li><p>标记清除(mark sweep) - 位置不连续 产生碎片 效率偏低（两遍扫描）</p>\n<img src=\"/2024/09/10/jvm/image-20231201151500158.png\" alt=\"image-20231201151500158\" style=\"zoom:80%;\">\n\n<p>碎片空间可能导致大对象没有地方存放</p>\n</li>\n<li><p>拷贝算法 (copying) - 没有碎片，浪费空间</p>\n<img src=\"/2024/09/10/jvm/image-20231201151606407.png\" alt=\"image-20231201151606407\" style=\"zoom:80%;\">\n\n<p>将空间分成两半，gc时将使用一半的存活对象复制到另一半</p>\n</li>\n<li><p>标记压缩(mark compact) - 没有碎片，效率偏低（两遍扫描，指针需要调整）</p>\n<img src=\"/2024/09/10/jvm/image-20231201151745264.png\" alt=\"image-20231201151745264\" style=\"zoom:80%;\"></li>\n</ol>\n<h2 id=\"1-2-JVM内存分代模型\"><a href=\"#1-2-JVM内存分代模型\" class=\"headerlink\" title=\"1.2 JVM内存分代模型\"></a>1.2 JVM内存分代模型</h2><ol>\n<li><p>部分垃圾回收器使用的模型</p>\n<blockquote>\n<p>除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型</p>\n<p>G1是逻辑分代，物理不分代</p>\n<p>除此之外不仅逻辑分代，而且物理分代</p>\n</blockquote>\n</li>\n<li><p>新生代 + 老年代 + 永久代（1.7）Perm Generation&#x2F; 元数据区(1.8) Metaspace</p>\n<ol>\n<li>永久代 元数据 - Class</li>\n<li>永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存）</li>\n<li>字符串常量 1.7 - 永久代，1.8 - 堆</li>\n<li>MethodArea逻辑概念 - 永久代、元数据</li>\n</ol>\n</li>\n<li><p>新生代 &#x3D; Eden + 2个suvivor区 </p>\n<ol>\n<li>YGC回收之后，大多数的对象会被回收，活着的进入s0</li>\n<li>再次YGC，活着的对象eden + s0 -&gt; s1</li>\n<li>再次YGC，eden + s1 -&gt; s0</li>\n<li>年龄足够 -&gt; 老年代 （15 CMS 6）</li>\n<li>s区装不下 -&gt; 老年代</li>\n</ol>\n</li>\n<li><p>老年代</p>\n<ol>\n<li>顽固分子</li>\n<li>老年代满了FGC Full GC</li>\n</ol>\n</li>\n<li><p>GC Tuning (Generation)</p>\n<ol>\n<li>尽量减少FGC</li>\n<li>MinorGC &#x3D; YGC</li>\n<li>MajorGC+MinorGC &#x3D; FGC</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"1-3-GC常见评估指标\"><a href=\"#1-3-GC常见评估指标\" class=\"headerlink\" title=\"1.3 GC常见评估指标\"></a>1.3 GC常见评估指标</h2><ol>\n<li><strong>吞吐量</strong>：吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间 + 垃圾收集时间）。</li>\n<li><strong>暂停时间</strong>：执行一次垃圾回收STW时间的大小</li>\n</ol>\n<p><strong>两者不可兼得</strong></p>\n<p>如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</p>\n<h2 id=\"1-4-垃圾回收器\"><a href=\"#1-4-垃圾回收器\" class=\"headerlink\" title=\"1.4 垃圾回收器\"></a>1.4 垃圾回收器</h2><p>常见垃圾回收器及其组合（远古图片，现在还有一个不是分代模型的ZGC）</p>\n<img src=\"/2024/09/10/jvm/82a369cjhi.jpeg\" alt=\"82a369cjhi\" style=\"zoom:80%;\">\n\n<h2 id=\"1-5-垃圾回收器及其算法\"><a href=\"#1-5-垃圾回收器及其算法\" class=\"headerlink\" title=\"1.5 垃圾回收器及其算法\"></a>1.5 垃圾回收器及其算法</h2><p>Serial是<strong>单线程</strong>使用<strong>标记复制算法</strong>的垃圾回收器作用于<strong>新生代</strong></p>\n<p>SerialOld是<strong>单线程</strong>使用<strong>标记整理算法</strong>的垃圾回收器作用于<strong>老年代</strong></p>\n<p>ParNew是<strong>多线程</strong>使用<strong>标记复制算法</strong>的垃圾回收器作用于<strong>新生代</strong></p>\n<p>ParallelScavenge是<strong>吞吐量优先</strong>使用<strong>标记复制算法</strong>的垃圾回收器作用于<strong>新生代</strong>（吞吐量优先垃圾回收器），不支持<strong>多线程</strong></p>\n<p>ParallelOld是<strong>多线程</strong>使用<strong>标记整理算法</strong>的垃圾回收器作用于<strong>老年代</strong></p>\n<p>CMS是<strong>低停顿</strong>使用<strong>标记清除+标记整理</strong>算法的垃圾回收器作用于<strong>老年代</strong></p>\n<p>G1是新一代不分区的垃圾回收器之一，使用<strong>标记复制</strong>算法，作用于<strong>年轻代和老年代</strong>，兼顾<strong>低停顿和高吞吐量</strong>，优先回收高价值的垃圾。</p>\n<p><strong>ZGC</strong>：是一款<strong>基于Region内存布局</strong>的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p>\n<p>ZGC的工作过程可以分为4个阶段：<strong>并发标记-并发预备重分配-并发重分配-并发重映射</strong>等。</p>\n<p>ZGC几乎在所有地方并发执行的，除了<strong>初始标记的是STW</strong>的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>\n<p>1.8 默认是ParallelScavenge+ParallelOld。</p>\n<p>1.9+默认是G1。</p>\n<h3 id=\"三色标记法\"><a href=\"#三色标记法\" class=\"headerlink\" title=\"三色标记法\"></a>三色标记法</h3><p><strong>三色</strong></p>\n<ul>\n<li><strong>白色</strong>：还没有遍历对象</li>\n<li><strong>灰色</strong>：已遍历到的对象，但是它直接引用的对象还没有遍历完</li>\n<li><strong>黑色</strong>：已遍历到的对象，它的直接引用也已遍历完</li>\n</ul>\n<p><strong>浮动垃圾</strong>：灰色对象可能已经是垃圾了，但是还是当成正常对象存活到下一轮GC</p>\n<p><strong>三色标记法黑色被误认为白色</strong>：</p>\n<ol>\n<li>赋值器插入一条或多条从黑色对象到白色对象的新引用</li>\n<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>\n</ol>\n<p><strong>两种解决方式</strong>：</p>\n<ol>\n<li><p><strong>增量更新法</strong>：</p>\n<p>对于这种漏标的情况，CMS垃圾收集器使用的是增量更新法，就是将引用变化后的引用情况进行记录，然后之后进行标记。也就是当E-&gt;G变成了E-&gt;null,D-&gt;G，会对D-&gt;G进行记录，用于在重新标记阶段对这种情况进行处理。</p>\n</li>\n<li><p><strong>原始快照法</strong>：</p>\n<p>就是对于这种E-&gt;G，然后改成D-&gt;G，正常来说，应该可能会漏掉，因为D已经是黑色对象了，就不会遍历G了，G1垃圾收集器对这种情况的处理是保存原始快照，就是在并发标记过程中，引用的变动，都会对变动前的引用情况进行记录，会按照变动前的引用情况进行标记，也就是即便E-&gt;G变成了E-&gt;null,D-&gt;G变化了，还是会记录E-&gt;G的引用情况，用于在重新标记阶段对这种情况进行处理。</p>\n</li>\n</ol>\n<h3 id=\"CMS（标记清除灰导致内存碎片化）\"><a href=\"#CMS（标记清除灰导致内存碎片化）\" class=\"headerlink\" title=\"CMS（标记清除灰导致内存碎片化）\"></a>CMS（标记清除灰导致内存碎片化）</h3><h4 id=\"1-初始标记\"><a href=\"#1-初始标记\" class=\"headerlink\" title=\"1. 初始标记\"></a>1. 初始标记</h4><p>在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</p>\n<h4 id=\"2-并发标记\"><a href=\"#2-并发标记\" class=\"headerlink\" title=\"2. 并发标记\"></a>2. 并发标记</h4><p>从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>\n<h4 id=\"3-重新标记\"><a href=\"#3-重新标记\" class=\"headerlink\" title=\"3. 重新标记\"></a>3. 重新标记</h4><p>由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（比如：由不可达变为可达对象的数据），这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>\n<h4 id=\"4-并发清除\"><a href=\"#4-并发清除\" class=\"headerlink\" title=\"4. 并发清除\"></a>4. 并发清除</h4><p>阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</p>\n<h1 id=\"2-Class文件结构\"><a href=\"#2-Class文件结构\" class=\"headerlink\" title=\"2. Class文件结构\"></a>2. Class文件结构</h1><p>Class文件为二进制，可以用powershell命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Format-Hex D:\\java\\learn\\out\\production\\learn\\mix\\Main.class</span><br></pre></td></tr></table></figure>\n\n<p>以16进制查看文件</p>\n<img src=\"/2024/09/10/jvm/image-20231116194904286.png\" alt=\"image-20231116194904286\" style=\"zoom:75%;\">\n\n<p>文件的大致结构为（u2表示两个字节的无符号数)</p>\n<img src=\"/2024/09/10/jvm/image-20231116202440545.png\" alt=\"image-20231116202440545\" style=\"zoom:80%;\">\n\n<h2 id=\"2-1-魔数-magic-number\"><a href=\"#2-1-魔数-magic-number\" class=\"headerlink\" title=\"2.1 魔数(magic number)\"></a>2.1 魔数(magic number)</h2><p>开头四个字节’CA FE BA BE’ 为称为魔数，魔数是固定的，用来指定这个文件是Class文件</p>\n<h2 id=\"2-2-Class文件版本\"><a href=\"#2-2-Class文件版本\" class=\"headerlink\" title=\"2.2 Class文件版本\"></a>2.2 Class文件版本</h2><p>四个字节，前两个为副版本，后两个为主版本。如00 00 00 3A表示Class文件版本为 58.0 (也就是java 14)</p>\n<h2 id=\"2-3-常量池\"><a href=\"#2-3-常量池\" class=\"headerlink\" title=\"2.3 常量池\"></a>2.3 常量池</h2><p>两个字节表示常量池的大小00 14表示常量池大小为20。由于常量池index从1开始，所以常量数量只有19个</p>\n<p>常量的第一个字节表示常量类型，每个常量类型有不同的长度</p>\n<p>常量池是class文件最重要的一部分，名称、类型等具体内容都会被存储在常量池中，在后续修饰字段、方法时只需要记录位置，根据位置就可以获取到具体的属性。</p>\n<p><strong>常见常量类型：</strong></p>\n<img src=\"/2024/09/10/jvm/image-20231116200128095.png\" alt=\"image-20231116200128095\" style=\"zoom:80%;\">\n\n<h2 id=\"2-4-访问标志\"><a href=\"#2-4-访问标志\" class=\"headerlink\" title=\"2.4 访问标志\"></a>2.4 访问标志</h2><p>之后两个字节表示访问标志</p>\n<img src=\"/2024/09/10/jvm/image-20231116202718426.png\" alt=\"image-20231116202718426\" style=\"zoom:80%;\">\n\n<h2 id=\"2-5-类索引、父类索引、接口索引集合\"><a href=\"#2-5-类索引、父类索引、接口索引集合\" class=\"headerlink\" title=\"2.5 类索引、父类索引、接口索引集合\"></a>2.5 类索引、父类索引、接口索引集合</h2><pre><code>u2             this_class;//当前类\nu2             super_class;//父类\nu2             interfaces_count;//接口数量\nu2             interfaces[interfaces_count];//一个类可以实现多个接口\n</code></pre>\n<h2 id=\"2-6-字段表集合\"><a href=\"#2-6-字段表集合\" class=\"headerlink\" title=\"2.6 字段表集合\"></a>2.6 字段表集合</h2><img src=\"/2024/09/10/jvm/image-20231116203451353.png\" alt=\"image-20231116203451353\" style=\"zoom:80%;\">\n\n<p><strong>descriptor_index</strong>用来描述类型</p>\n<h2 id=\"2-6-方法表集合\"><a href=\"#2-6-方法表集合\" class=\"headerlink\" title=\"2.6 方法表集合\"></a>2.6 方法表集合</h2><img src=\"/2024/09/10/jvm/image-20231116204902025.png\" alt=\"image-20231116204902025\" style=\"zoom:80%;\">\n\n<h2 id=\"2-7-属性表\"><a href=\"#2-7-属性表\" class=\"headerlink\" title=\"2.7 属性表\"></a>2.7 属性表</h2><p>详见《深入理解java虚拟机》</p>\n<h1 id=\"3-java类加载器\"><a href=\"#3-java类加载器\" class=\"headerlink\" title=\"3. java类加载器\"></a>3. java类加载器</h1><h2 id=\"3-1-类加载\"><a href=\"#3-1-类加载\" class=\"headerlink\" title=\"3.1 类加载\"></a>3.1 类加载</h2><img src=\"/2024/09/10/jvm/image-20231127105115660.png\" alt=\"image-20231127105115660\" style=\"zoom:80%;\">\n\n<h3 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h3><p>装载阶段，简言之，查找并加载类的二进制数据，生成Class的实例，即类模版对象。<br>在加载类时，Java虚拟机必须完成以下3件事情：</p>\n<ul>\n<li>通过类的全名，获取类的二进制数据流。</li>\n<li>解析类的二进制数据流为方法区内的数据结构（Java类模型）</li>\n<li>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>\n</ul>\n<p><strong>类模板对象</strong><br>所谓类模板对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</p>\n<p>反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。</p>\n<p><strong>类模型的位置</strong><br>加载的类在JVM中创建相应的类结构，类结构会存储在方法区(JDK1.8之前：永久代；JDK1.8及之后：元空间)。</p>\n<p><strong>数组类的加载</strong></p>\n<p>创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。</p>\n<h3 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h3><ol>\n<li><p>验证</p>\n<p><strong>目的：</strong>保证加载的字节码是合法、合理并符合规范的</p>\n<img src=\"/2024/09/10/jvm/image-20231205215113256.png\" alt=\"image-20231205215113256\" style=\"zoom:60%;\">\n\n<p>其中格式验证会和装载阶段一起执行。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。<br>格式验证之外的验证操作将会在方法区中进行。（其他验证略）</p>\n</li>\n<li><p>准备</p>\n<p>简言之，为类的静态变量分配内存，并将其初始化为默认值。<br>在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java虚拟机为各类型变量默认的初始值如表所示。</p>\n<img src=\"/2024/09/10/jvm/image-20231205215707315.png\" alt=\"image-20231205215707315\" style=\"zoom:70%;\">\n\n<p>注意：Java并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false。</p>\n</li>\n<li><p>解析</p>\n<p>将类、接口、字段和方法的符号引用转为直接引用。</p>\n<p>如<code>System.out.println();</code>转换过程</p>\n<img src=\"/2024/09/10/jvm/image-20231206112755092.png\" alt=\"image-20231206112755092\" style=\"zoom:67%;\">\n\n<p>Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行。</p>\n</li>\n</ol>\n<h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>调用<clinit>初始化方法，</clinit></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InitializationTest1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//场景1：对于非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//场景2：静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> num1;</span><br><span class=\"line\">    <span class=\"comment\">//场景3：比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">num2</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>类的初始化时机</strong></p>\n<ol>\n<li>当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。</li>\n<li>当调用类的静态方法时，即当使用了字节码invokestatic指令。</li>\n<li>当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。</li>\n<li>当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”)</li>\n<li>当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>\n<li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>\n</ol>\n<h3 id=\"卸载\"><a href=\"#卸载\" class=\"headerlink\" title=\"卸载\"></a>卸载</h3><p>类的垃圾回收过程</p>\n<h2 id=\"3-2-双亲委派机制\"><a href=\"#3-2-双亲委派机制\" class=\"headerlink\" title=\"3.2 双亲委派机制\"></a>3.2 双亲委派机制</h2><p>作用：</p>\n<ol>\n<li>防止类库中的类被重写</li>\n<li>避免类被重复加载</li>\n</ol>\n<img src=\"/2024/09/10/jvm/image-20231117160926362.png\" alt=\"image-20231117160926362\" style=\"zoom:50%;\">\n\n\n\n<p>Bootstrap加载<code>%JAVA_HOME%lib</code>下的jar包和class文件，ExtClassLoader加载<code>%JAVA_HOME%lib/lib/ext</code>文件夹下的jar包和class类。AppClassLoader负责加载<code>classpath</code>下的类文件。系统类加载器，线程上下文加载器贯穿三个类加载器。</p>\n<p>3个关键方法loadClass()、findClass()、defineClass()</p>\n<p>loadClass双亲委派模型具体的实现</p>\n<p>findClass从指定路径中加载Class字节流</p>\n<p>defineClass将Class字节流翻译为Class对象</p>\n<h2 id=\"3-3-自定义类加载器\"><a href=\"#3-3-自定义类加载器\" class=\"headerlink\" title=\"3.3 自定义类加载器\"></a>3.3 自定义类加载器</h2><p>重写loadClass()方法或者重写findClass()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//重写findClass()方法, 遵循双亲委派模型, 子类先委托父类加载需要的类，父类从指定的路径加载类, 没有则交给子类加载</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyClassLoader</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ClassLoader</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String classPath;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String className;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyClassLoader</span><span class=\"params\">(String classPath, String className)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.classPath = classPath;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.className = className;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt; findClass(String name) <span class=\"keyword\">throws</span> ClassNotFoundException &#123;</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] data = getData();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> defineClass(className,data,<span class=\"number\">0</span>,data.length);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">byte</span>[] getData()&#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">path</span> <span class=\"operator\">=</span> classPath;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">FileInputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(path);</span><br><span class=\"line\">            <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">byteArrayOutputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">            <span class=\"type\">byte</span>[] bytes = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">2048</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((num = inputStream.read(bytes)) != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                byteArrayOutputStream.write(bytes, <span class=\"number\">0</span>,num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> byteArrayOutputStream.toByteArray();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>loadClass()方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; loadClass(String name, <span class=\"type\">boolean</span> resolve)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> ClassNotFoundException</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// First, check if the class has already been loaded</span></span><br><span class=\"line\">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"variable\">t0</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (parent != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                        c = parent.loadClass(name, <span class=\"literal\">false</span>);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        c = findBootstrapClassOrNull(name);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// ClassNotFoundException thrown if class not found</span></span><br><span class=\"line\">                    <span class=\"comment\">// from the non-null parent class loader</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// If still not found, then invoke findClass in order</span></span><br><span class=\"line\">                    <span class=\"comment\">// to find the class.</span></span><br><span class=\"line\">                    <span class=\"type\">long</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> System.nanoTime();</span><br><span class=\"line\">                    c = findClass(name);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// this is the defining class loader; record the stats</span></span><br><span class=\"line\">                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class=\"line\">                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class=\"line\">                    PerfCounter.getFindClasses().increment();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resolve) &#123;</span><br><span class=\"line\">                resolveClass(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"打破双亲委派机制\"><a href=\"#打破双亲委派机制\" class=\"headerlink\" title=\"打破双亲委派机制\"></a>打破双亲委派机制</h3><p>双亲委派模型</p>\n<ol>\n<li><p>tomcat中部署多个应用时可能需要加载相同的类多次，双亲委派模型无法实现</p>\n<img src=\"/2024/09/10/jvm/image-20231214111741606.png\" alt=\"image-20231214111741606\" style=\"zoom:70%;\">\n\n<ul>\n<li><p>放置在&#x2F;common目录中。类库可被Tomcat和所有的Web应用程序共同使用。</p>\n</li>\n<li><p>放置在&#x2F;server目录中。类库可被Tomcat使用，对所有的Web应用程序都不可见。</p>\n</li>\n<li><p>放置在&#x2F;shared目录中。类库可被所有的Web应用程序共同使用，但对Tomcat自己不可见。</p>\n</li>\n<li><p>放置在&#x2F;WebApp&#x2F;WEB-INF目录中。类库仅仅可以被该Web应用程序使用，对Tomcat和其他Web应用</p>\n</li>\n</ul>\n</li>\n<li><p>java中比较出名的SPI机制（线程上下文类加载器）</p>\n<p>父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所指定的Classloader加载的类。这就改变了父ClassLoader不能使用子ClassLoader或是其他没有直接父子关系的classLoader加载的类的情况，即<strong>改变了双亲委托模型</strong>。</p>\n<p>线程上下文类加载器就是当前线程的当前类加载器(Current Classloader)。</p>\n<p><strong>在双亲委托模型下</strong>，类加载是由下至上的，即下层的类加载器会委托上层进行加载。但是对于SPI来说，有些接口是Java核心库所提供的,而Java核心库是由启动类加载器来加载的，而这些接口的实现却来自于不同的jar包(厂商提供)， Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就<strong>无法满足</strong>SPI的要求。而通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。</p>\n</li>\n<li><p>web应用热替换的实现（对程序动态性的最求）</p>\n</li>\n</ol>\n<h3 id=\"沙箱安全机制\"><a href=\"#沙箱安全机制\" class=\"headerlink\" title=\"沙箱安全机制\"></a>沙箱安全机制</h3><p>对代码的权限进行校验，判断其是否有权限操作资源</p>\n<p><strong>基本组件</strong></p>\n<ul>\n<li><strong>字节码校验器</strong>：确保lava类文件遵循lava语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。</li>\n<li><strong>类加载器</strong>：防止恶意代码去干涉善意的代码，比如：双亲委派机制；守护了被信任的类库边界；将代码归入保护域，确定了代码的权限范围可以进行哪些资源操作</li>\n<li><strong>存取控制器</strong>：存取控制器可以控制核心API对操作系统的存取权限，用户可以设定控制策略。</li>\n<li><strong>安全管理器</strong>：安全管理器主要是核心API和操作系统之间的主要接口。比如实现权限控制，比存取控制器优先级高。</li>\n<li><strong>安全软件包</strong>：java.security下的类和扩展包下的类，允许用户为应用增加所需要安全特性：安全提供者、消息摘要、数字签名keytools、加密、鉴别。</li>\n</ul>\n<h1 id=\"4-jvm内存模型\"><a href=\"#4-jvm内存模型\" class=\"headerlink\" title=\"4. jvm内存模型\"></a>4. jvm内存模型</h1><img src=\"/2024/09/10/jvm/image-20231214193447991.png\" alt=\"image-20231214193447991\" style=\"zoom:80%;\">\n\n<h2 id=\"4-1-程序计数器\"><a href=\"#4-1-程序计数器\" class=\"headerlink\" title=\"4.1 程序计数器\"></a>4.1 程序计数器</h2><p><strong>作用</strong>：记录当前线程的执行地址（记录字节码执行到哪了）</p>\n<p>没有规定任何OutOtMemoryError情况的区域</p>\n<h2 id=\"4-2-栈\"><a href=\"#4-2-栈\" class=\"headerlink\" title=\"4.2 栈\"></a>4.2 栈</h2><p>虚拟栈和本地方法栈的区别在于，虚拟机栈执行的是java中的方法，本地方法栈中执行的是本地接口实现的方法，其内部结构差不多</p>\n<p><strong>栈的内部结构</strong>：</p>\n<img src=\"/2024/09/10/jvm/image-20231214194507254.png\" alt=\"image-20231214194507254\" style=\"zoom:70%;\">\n\n<p><strong>可能抛出的异常：</strong></p>\n<ul>\n<li>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。</li>\n<li>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常。</li>\n</ul>\n<h3 id=\"栈帧\"><a href=\"#栈帧\" class=\"headerlink\" title=\"栈帧\"></a>栈帧</h3><p>一个方法对应一个栈帧</p>\n<img src=\"/2024/09/10/jvm/image-20231214195613362.png\" alt=\"image-20231214195613362\" style=\"zoom:80%;\">\n\n<p>Java方法有两种返回函数的方式，会导致栈帧被弹出</p>\n<ol>\n<li><p>正常的函数返回，使用return指令；</p>\n</li>\n<li><p>抛出异常。</p>\n</li>\n</ol>\n<h3 id=\"局部变量表\"><a href=\"#局部变量表\" class=\"headerlink\" title=\"局部变量表\"></a>局部变量表</h3><ul>\n<li>局部变量表，最基本的存储单元是Slot（变量槽）</li>\n<li>在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double)占用两个slot。<br>byte 、short 、char 在存储前被转换为int，boolean 也被转换为int，0 表示false ，非0 表示true。<br>long 和double 则占据两个Slot。</li>\n<li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li>\n<li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上</li>\n<li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。(比如：访问long或double类型变量）</li>\n<li>如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。</li>\n</ul>\n<p>局部变量超出作用域，其原本的slot将被重复利用</p>\n<h3 id=\"操作数栈\"><a href=\"#操作数栈\" class=\"headerlink\" title=\"操作数栈\"></a>操作数栈</h3><p>进行具体方法操作的初步逻辑，保存计算的中间结果</p>\n<p>一个栈深度为32bit，为一个slot（槽位）,long、double类型数据可能占两个槽位</p>\n<p>数据超过作用域后，所占槽位可以复用。</p>\n<p><strong>栈顶缓存技术：</strong></p>\n<p>基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数。</p>\n<p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</p>\n<h2 id=\"4-3-堆\"><a href=\"#4-3-堆\" class=\"headerlink\" title=\"4.3 堆\"></a>4.3 堆</h2><img src=\"/2024/09/10/jvm/image-20231214221246377.png\" alt=\"image-20231214221246377\" style=\"zoom:80%;\">\n\n<p>按照分代模型，堆可分为年轻代、老年代，年轻代可分为Eden区、s0、s1区。默认比例为<code>Eden:s0:s1:Old = 8:1:1:20</code></p>\n<p><strong>GC过程</strong></p>\n<ol>\n<li>YGC回收之后，大多数的对象会被回收，活着的进入s0</li>\n<li>再次YGC，活着的对象eden + s0 -&gt; s1</li>\n<li>再次YGC，eden + s1 -&gt; s0</li>\n<li>年龄足够 -&gt; 老年代 （15 CMS 6）</li>\n<li>s区装不下 -&gt; 老年代</li>\n</ol>\n<p>在jdk1.7及之前会有一个堆中会有永久代的这个概念，不过永久代并不是垃圾回收的主要作用地。它主要是用来存放java中类的元数据（即java中成员变量的类型、作用范围等）所以一般把永久代称为方法区</p>\n<h2 id=\"4-4-方法区（元空间）\"><a href=\"#4-4-方法区（元空间）\" class=\"headerlink\" title=\"4.4 方法区（元空间）\"></a>4.4 方法区（元空间）</h2><p><strong>存放内容：</strong></p>\n<ol>\n<li>类型信息</li>\n<li>域信息</li>\n<li>方法信息</li>\n<li>static类变量（非final）</li>\n</ol>\n<p><strong>运行时常量池</strong></p>\n<p>作用：缩小字节码文件（存放指向常量池的应用而非直接的数据）</p>\n<p>内容：</p>\n<ul>\n<li>数量值</li>\n<li>字符串值</li>\n<li>类引用</li>\n<li>字段引用</li>\n<li>方法引用</li>\n</ul>\n<h2 id=\"4-5-直接内存\"><a href=\"#4-5-直接内存\" class=\"headerlink\" title=\"4.5 直接内存\"></a>4.5 直接内存</h2><p>不是JVM定义的内存区域，直接向系统申请的内存，读写性能较高</p>\n<img src=\"/2024/09/10/jvm/image-20231217221608733.png\" alt=\"image-20231217221608733\" style=\"zoom:67%;\">\n\n<img src=\"/2024/09/10/jvm/image-20231217221643907.png\" alt=\"image-20231217221643907\" style=\"zoom:67%;\">\n\n<h2 id=\"4-6-StringTable\"><a href=\"#4-6-StringTable\" class=\"headerlink\" title=\"4.6 StringTable\"></a>4.6 StringTable</h2><p>jdk1.7时移到堆中，因为方法区的内存回收效率较低</p>\n<p>使用数组+链表实现</p>\n<h1 id=\"5-四种引用\"><a href=\"#5-四种引用\" class=\"headerlink\" title=\"5. 四种引用\"></a>5. 四种引用</h1><ol>\n<li>强引用：就是普通的变量对对象的引用，强引用的对象不会被系统回收。</li>\n<li>软引用：当内存空间足够时，软引用的对象不会被系统回收。当内存空间不足时，软引用的对象可能被 系统回收。通常用于内存敏感的程序中。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>\n<li>弱引用：引用级别比软引用低，对于只有软引用的对象，不管内存是否足够， 都可能会被系统回收。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>\n<li>虚引用：虚引用主要用于跟踪对象被垃圾回收的状态，在垃圾回收时可以收到一个通知。。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li>\n</ol>\n<h1 id=\"6-jvm指令及重排\"><a href=\"#6-jvm指令及重排\" class=\"headerlink\" title=\"6. jvm指令及重排\"></a>6. jvm指令及重排</h1><h2 id=\"i-与-i\"><a href=\"#i-与-i\" class=\"headerlink\" title=\"i++与++i\"></a>i++与++i</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        y=x++;</span><br><span class=\"line\">        y=++x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//字节码:</span></span><br><span class=\"line\"> <span class=\"number\">0</span> iconst_5 \t<span class=\"comment\">//定义常数5到操作数栈</span></span><br><span class=\"line\"> <span class=\"number\">1</span> istore_1\t\t<span class=\"comment\">//将操作数栈顶数存到局部变量表第二个位置</span></span><br><span class=\"line\"> <span class=\"number\">2</span> iconst_0</span><br><span class=\"line\"> <span class=\"number\">3</span> istore_2</span><br><span class=\"line\"> <span class=\"number\">4</span> iload_1\t\t<span class=\"comment\">//将局部变量表2号位load到操作数栈中</span></span><br><span class=\"line\"> <span class=\"number\">5</span> iinc <span class=\"number\">1</span> by <span class=\"number\">1</span>\t<span class=\"comment\">//对局部变量表2号位加1</span></span><br><span class=\"line\"> <span class=\"number\">8</span> istore_2</span><br><span class=\"line\">     </span><br><span class=\"line\"> <span class=\"number\">9</span> iinc <span class=\"number\">1</span> by <span class=\"number\">1</span>\t</span><br><span class=\"line\"><span class=\"number\">12</span> iload_1</span><br><span class=\"line\"><span class=\"number\">13</span> istore_2</span><br><span class=\"line\"><span class=\"number\">14</span> <span class=\"keyword\">return</span></span><br><span class=\"line\"><span class=\"comment\">//区别在于先加1，还是先把数据load到局部变量表中</span></span><br></pre></td></tr></table></figure>\n\n<p>按用途分为9类：</p>\n<ol>\n<li><p>加载与存储指令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xload_&lt;n&gt; (x为i、l、f、d、a，n为 0 到 3)</span><br><span class=\"line\">xload (x为i、l、f、d、a) </span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>i代表对int类型的数据操作</li>\n<li>l代表long类型的数据操作</li>\n<li>s代表short类型的数据操作</li>\n<li>b代表byte类型的数据操作</li>\n<li>c代表char类型的数据操作</li>\n<li>f代表float类型的数据操作</li>\n<li>d代表double类型的数据操作</li>\n</ul>\n</li>\n<li><p>算术指令</p>\n</li>\n<li><p>类型转换指令</p>\n</li>\n<li><p>对象的创建与访问指令</p>\n</li>\n<li><p>方法调用与返回指令</p>\n</li>\n<li><p>操作数栈管理指令</p>\n</li>\n<li><p>控制转移指令</p>\n</li>\n<li><p>异常处理指令</p>\n</li>\n<li><p>同步控制指令</p>\n</li>\n</ol>\n<p><strong>指令重排主要是为了最大化的利用CPU资源</strong></p>\n<ol>\n<li><strong>编译器重排序</strong></li>\n<li><strong>指令集并行的重排序</strong></li>\n<li><strong>内存重排序</strong></li>\n</ol>\n<p>指令重排的原则（as - if - serial），不过多线程环境较复杂，编译器和指令优化无法识别数据依赖性，可能出现预料之外的错误。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//输出结果可能为0</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> value;</span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> flag;</span><br><span class=\"line\">\t<span class=\"comment\">//线程1执行</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span>  <span class=\"keyword\">void</span>  <span class=\"title function_\">init</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">         value=<span class=\"number\">8</span>;     <span class=\"comment\">//语句1</span></span><br><span class=\"line\">         flag=<span class=\"literal\">true</span>;  <span class=\"comment\">//语句2</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//线程2执行</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getValue</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">             System.out.println(value);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>解决指令重排引起的问题</strong>（内存屏障）</p>\n<p>不同的CPU架构和操作系统都有各自对应的内存屏障指令，java为了简化这些杂乱的场景，自己封装了一套规范——java内存模型（JMM）。java中可以通过<code>Volatile</code>、<code>synchronized</code>、<code>final</code>来避免重排序而引起的错误。</p>\n<h1 id=\"7-常用参数\"><a href=\"#7-常用参数\" class=\"headerlink\" title=\"7. 常用参数\"></a>7. 常用参数</h1><p>JDK17 和 JDK8 部分参数有变化</p>\n<h2 id=\"输出信息\"><a href=\"#输出信息\" class=\"headerlink\" title=\"输出信息\"></a>输出信息</h2><p>jdk17 使用 -Xlog:gc:<file>来输出相关日志</file></p>\n<p><strong>输出GC信息</strong>:-XX:+PrintGCDetails</p>\n<p><strong>输出GC信息</strong>：-XX:+PrintGC</p>\n<p><strong>输出GC日志到文件中：</strong>-Xloggc:<file></file></p>\n<h2 id=\"栈相关\"><a href=\"#栈相关\" class=\"headerlink\" title=\"栈相关\"></a>栈相关</h2><p><strong>栈内存大小：</strong>-Xss size (即：-XX:ThreadStackSize)，栈内存越大，可创建线程数量就越少</p>\n<h3 id=\"堆相关：\"><a href=\"#堆相关：\" class=\"headerlink\" title=\"堆相关：\"></a><strong>堆相关</strong>：</h3><p><strong>新生代和老年代比例：</strong> -XX:NewRatio &#x3D; 2 (default 即 1：2)</p>\n<p><strong>Eden和s区比例：</strong>-XX:SurvivorRatio&#x3D;8（8:1:1）</p>\n<p><strong>设置堆空间的初始内存大小</strong>：-Xms</p>\n<p><strong>设置堆空间的最大内存大小</strong>：-Xmx</p>\n<h2 id=\"命令行指令\"><a href=\"#命令行指令\" class=\"headerlink\" title=\"命令行指令\"></a>命令行指令</h2><p>使用命令行指令：jinfo –flag 相关垃圾回收器参数 进程ID</p>\n<h2 id=\"垃圾收集器设置\"><a href=\"#垃圾收集器设置\" class=\"headerlink\" title=\"垃圾收集器设置\"></a>垃圾收集器设置</h2><p> <strong>XX:+UseSerialGC</strong>   \t\t新生代用Serial GC，且老年代用Serial Old GC</p>\n<p><strong>-XX:+UseParNewGC</strong> \t年轻代使用ParNew收集器，老年代不受影响</p>\n<p><strong>-XX:ParallelGCThreads</strong> \t限制线程数量，默认开启和CPU数据相同的线程数。</p>\n<p><strong>G1</strong>：</p>\n<img src=\"/2024/09/10/jvm/image-20240326163359886.png\" alt=\"image-20240326163359886\" style=\"zoom:80%;\">"},{"title":"算法合集(持续更新)","date":"2024-10-07T05:28:55.000Z","_content":"\n算法基础\n\n<!--more-->\n\n# 1. 数学\n\n## 1.1 C<sub>n</sub><sup>m</sup>计算\n\n**思路**\n\n1. 用公式 **C<sub>n</sub><sup>m</sup> = C<sub>n-1</sub><sup>m</sup> + C<sub>n-1</sub><sup>m-1</sup>**\n\n   处理好边界值 C<sub>0</sub>^0^ = 1 , C~0~^1^ = 0 , C~1~^0^ = 1   \n\n   ```java\n   //\n   public static long calCnm1(int n, int m) {\n           if (n == m)\n               return 1;\n           if (n == 0)\n               return 0;\n           if (m == 0) {\n               return 1;\n           }\n           return calCnm1(n - 1, m) + calCnm1(n - 1, m - 1);\n       }\n   ```\n\n2. 直接用展开式阶乘计算\n\n   ```java\n   public static long calCnm2(int n, int m) {\n           if (m > n || m < 0) return 0;\n       //消除分子、分母重叠部分，只是为了简化计算，去掉这行也能运行\n           m = Math.min(m, n - m);\n           long result = 1;\n           for (int k = 1; k <= m; k++) {\n               result = result * (n - k + 1) / k;\n           }\n           return result;\n       }\n   ```\n\n## 1.2 快速幂\n\n**思路**：\n\n幂计算可以暴力O(n)复杂度直接for循环乘 x 得到，但是会重复计算部分值。\n\n考虑将n用位运算按二进制进行拆分 （例：5^9^ = 5<sup>2<sup>0</sup></sup> * 5<sup>2<sup>3</sup></sup> 即 5^9^ = 5^1^ * 5^8^）。5^1^*5^1^ = 5^2^   5^2^ * 5^2^ = 5^4^  5^4^ * 5^4^ = 5^8^ 这样可以将时间复杂度缩减到 O(log n)\n\n```java\npublic class fastPow {\n    static int MOD = 100000007;\n    public static void main(String[] args) {\n        System.out.println(pow(3, 4));\n    }\n    \n    public static long pow(int x, int n) {\n        long ans = 1;\n        while (n > 0) {\n            //对应二进制位为1则乘上结果\n            if ((n & 1) == 1) {\n                ans = ans * x % MOD;\n            }\n            //更新中间结果\n            x = x * x % MOD;\n            //位运算右移一位\n            n >>= 1;\n        }\n        return ans;\n    }\n}\n```\n\n# 2. 最短路径\n\n## 2.1 Dijkstra\n\n**前提**：路径无负值。\n\n**思路**（贪心）：\n\n1. 一点与其相邻点之间的距离最短的那一点一定是最短距离。\n\n   例：A的相邻点和距离分别为{B,C,D,E,F} ，{5,2,3,4,9}。那么A点到C点的最短距离一定是2。\n\n2. 求一点到另一点的最短路径，可以由一点和他相邻点的最短路径推出来。\n\n   接着上面的例子，假设C到F的距离是1，因为 9 > 2+1 那么A与其他点的距离为{B,C,E,F} {5,3,4,3}，那么A到F点的最短距离是3，到C点的最短距离也为3。\n\n路径信息不建议使用数组存放，数组会记录许多无效路径，可能超内存。\n\n1. 数组版\n\n   ```java\n   //LeetCode_1514为例，数组版会超时\n   public double djst1(int n, int start, int end, int[][] edges, double[] succProb) {\n       //dist存放其它节点与起点最近距离\n           double[] dist = new double[n];\n       //优先队列获取最小值，避免O(n)时间复杂度遍历dist数组\n          Queue<Integer> queue = new PriorityQueue<>((o1, o2) -> Double.compare(dist[o2], dist[o1]));\n           double[][] graph = new double[n][n];\n       //1.初始化\n           for (int i = 0; i < edges.length; i++) {\n               graph[edges[i][0]][edges[i][1]] = succProb[i];\n               graph[edges[i][1]][edges[i][0]] = succProb[i];\n               if (edges[i][0] == start) {\n                   dist[edges[i][1]] = succProb[i];\n                   queue.add(edges[i][1]);\n               } else if (edges[i][1] == start) {\n                   dist[edges[i][0]] = succProb[i];\n                   queue.add(edges[i][0]);\n               }\n           }\n       //2.具体更新距离逻辑\n           while (!queue.isEmpty()) {\n               int node = queue.poll();\n               for (int i = 0; i < n; i++) {\n                   //更新距离逻辑，可根据题目变化更改具体的判断逻辑，只要符合求最小值的逻辑即可\n                   if (graph[node][i] != 0 && dist[i] < graph[node][i] * dist[node]) {\n                       dist[i] = graph[node][i] * dist[node];\n                       queue.add(i);\n                   }\n               }\n           }\n           return dist[end];\n       }\n   ```\n\n2. 邻接矩阵版\n\n   ```java\n   public double djst2(int n, int start, int end, int[][] edges, double[] succProb) {\n           double[] dist = new double[n];\n            Queue<Integer> queue = new PriorityQueue<>((o1, o2) -> Double.compare(dist[o2], dist[o1]));\n           double[][] graph = new double[n][n];\n           for (int i = 0; i < edges.length; i++) {\n               graph[edges[i][0]][edges[i][1]] = succProb[i];\n               graph[edges[i][1]][edges[i][0]] = succProb[i];\n               if (edges[i][0] == start) {\n                   dist[edges[i][1]] = succProb[i];\n                   queue.add(edges[i][1]);\n               } else if (edges[i][1] == start) {\n                   dist[edges[i][0]] = succProb[i];\n                   queue.add(edges[i][0]);\n               }\n           }\n           while (!queue.isEmpty()) {\n               int node = queue.poll();\n               for (int i = 0; i < n; i++) {\n                   if (graph[node][i] != 0 && dist[i] < graph[node][i] * dist[node]) {\n                       dist[i] = graph[node][i] * dist[node];\n                       queue.add(i);\n                   }\n               }\n           }\n           return dist[end];\n       }\n   \n   class Pair {\n       double succProb;\n       int node;\n   \n       public Pair(double succProb, int node) {\n           this.succProb = succProb;\n           this.node = node;\n       }\n   }\n   ```\n\n## 2.2 Floyd\n\n**思路**：动态规划\n\n1. 节点i、j之间的最小值一定由i、k与k、j之间转移过来\n\n```java\npublic void floyd(int n,int[][] arr) {\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    arr[i][j] = Math.min(arr[i][j], arr[i][k] + arr[k][j]);\n                }\n            }\n        }\n    }\n```\n\nFloyd时间复杂度为O(n^3^)，Dijkstra为O(n^2^)，不过Floyd可以求每两点之前最小值，并且把min改成max就可以求最大路径了。\n\n# 3. 单例模式\n\n## 3.1 类直接持有单例\n\n```java\n/**\n * @description: 饿汉模式\n * @author：ruizhi\n * @date: 2024/10/26\n * @Copyright：\n */\npublic class SingletonPattern2 {\n    public static final SingletonPattern2 INSTANCE = new SingletonPattern2();\n    public SingletonPattern2 getInstance(){\n        return INSTANCE;\n    }\n}\n```\n\n\n\n```java\n/**\n * @description: 双检锁实现,懒汉模式\n * @author：ruizhi\n * @date: 2024/10/26\n * @Copyright：\n */\npublic class SingletonPattern1 {\n    //volatile 用于禁止JVM指令重排\n    public static volatile SingletonPattern1 INSTANCE;\n    //常规的双检锁校验\n    public SingletonPattern1 getINSTANCE() {\n        if(INSTANCE == null){\n            synchronized (SingletonPattern1.class){\n                if(INSTANCE == null){\n                    //具体的初始化逻辑\n                    INSTANCE = new SingletonPattern1();\n                    try{\n                        Thread.sleep(350L);\n                    }catch (InterruptedException e){\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        return INSTANCE;\n    }\n    private SingletonPattern1(){\n        //将构造方法改为静态，防止外部调用\n    }\n}\n```\n\n## 3.2 类间接持有属性\n\n```java\n/**\n * @description: 使用静态内部类持有单例对象\n * @author：ruizhi\n * @date: 2024/10/26\n * @Copyright：\n */\npublic class SingletonPattern4 {\n    private SingletonPattern4(){\n\n    }\n    public static class InnerSingleton {\n        private static SingletonPattern4 instance=new SingletonPattern4();// 自行创建实例\n    }\n\n    public static SingletonPattern4 getInstance() {\n        return InnerSingleton.instance;/\n    }\n}\n\n```\n\n```java\n/**\n * @description: 使用枚举持有单例对象，反序列化不会创建新对象\n * @author：ruizhi\n * @date: 2024/10/26\n * @Copyright：\n */\npublic class SingletonPattern3 {\n    private SingletonPattern3(){\n\n    }\n    private enum Singleton{\n        INSTANCE;\n\n        private final SingletonPattern3 instance;\n        Singleton(){\n            instance = new SingletonPattern3();\n        }\n        private SingletonPattern3 getInstance(){\n            return instance;\n        }\n    }\n    public static SingletonPattern3 getInstance(){\n        return Singleton.INSTANCE.getInstance();\n    }\n}\n\n```\n\n# 4. 二分 + BFS\n\n```java\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n/**\n * @description: 二分+BFS，DFS需重复判断depth会超时\n * @author：ruizhi\n * @date: 2024/10/27\n * @Copyright：\n */\n/*\n描述\n\n有一个NxN 大小的迷宫。初始状态下，配送员位于迷官的左上角，他希望前往迷宫的右下角。\n配送员只能沿着上下左右四个方向移动，从每个格子移动到相邻格子所需要的时间是1个单位，他必须用最多 K个(也可以少于 K 个)单位时间到达右下角格子。\n迷宫的每个格子都有辐射值，配送员必须穿着防护能力不低于相应辐射值的防护服，才能通过该格子。他希望知道，防护服的防护能力最少要达到多少，他才能顺利完成任务。注意:配送员需要通过迷官的左上角和右下角，因此防护服的防护能力必须大于等于这两个格子的辐射值。\n\n输入描述\n\n前两行各包含一个正整数，分别对应N和K，后 N 行各包含 N 整数，以空格分隔，表示地图上每个位置的辐射值。\n2≤N≤100 。K≥2N-2，以保证题目有解。所有辐射值都是非负整数，绝对值不超过 10^4\n\n输出描述\n\n一个整数，表示配送员穿着防护服的最低防护能力。\n\n用例输入\n\n5\n12\n0 0 0 0 0\n9 9 3 9 0\n0 0 0 0 0\n0 9 5 9 9\n0 0 0 0 0\n\n用例输出\n3\n */\npublic class ProtectiveEquipment_20240919_2 {\n    static int[][] dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int[][] arr = new int[n][n];\n        int right = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                arr[i][j] = in.nextInt();\n                right = Math.max(arr[i][j], right);\n            }\n        }\n        int left = Math.max(arr[0][0], arr[n - 1][n - 1]);\n        int result = right;\n        //结果可能区间二分判断\n        while (left <= right) {\n            int mid = left + ((right - left) >> 1);\n            if (check(mid, arr, n, k)) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        System.out.println(result);\n    }\n    /*\n    \t判断防护值为limit，k步内是否能走到右下角\n    */\n    public static boolean check(int limit, int[][] arr, int n, int k) {\n        boolean[][] used = new boolean[n][n];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{0, 0});\n        used[0][0] = true;\n        int depth = 0;\n        while (!queue.isEmpty() && depth < k) {\n            depth++;\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] pos = queue.poll();\n                for (int[] ints : dir) {\n                    int newI = pos[0] + ints[0];\n                    int newJ = pos[1] + ints[1];\n                    if (newI == n - 1 && newJ == n - 1)\n                        return true;\n                    if (newI >= 0 && newJ >= 0 && newI < n && newJ < n && !used[newI][newJ] && arr[newI][newJ] <= limit) {\n                        used[newI][newJ] = true;\n                        queue.add(new int[]{newI, newJ});\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n# 5. 并查集\n\n```java\n/**\n * @description: 并查集，主要是图的连通块相关的题目\n * @author：ruizhi\n * @date: 2024/10/28\n * @Copyright：\n */\npublic class UnionFind {\n    public void demo (int[][] edges,int n) {\n        int[] parent = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            parent[i] = i;\n        }\n        for (int i = 0; i < n; i++) {\n           //并查集生成过程\n            int[] edge = edges[i];\n            //连通边\n            int node1 = edge[0], node2 = edge[1];\n            //根节点不相同，则合并\n            if (find(parent, node1) != find(parent, node2)) {\n                union(parent, node1, node2);\n            }\n        }\n        //可以遍历数组来看有几个不同的根节点看连通块\n        //可以在遍历过程中看有几条对连通无效的边\n    }\n    public void union(int[] parent, int index1, int index2) {\n        parent[find(parent, index1)] = find(parent, index2);\n    }\n    //递归查找，并统一将子节点指向同一个根节点\n    public int find(int[] parent, int index) {\n        if (parent[index] != index) {\n            parent[index] = find(parent, parent[index]);\n        }\n        return parent[index];\n    }\n}\n```\n\n","source":"_posts/算法合集.md","raw":"---\ntitle: 算法合集(持续更新)\ndate: 2024-10-07 13:28:55\ntags:\n- 算法合集 \ncategories:\t\n- 算法\n---\n\n算法基础\n\n<!--more-->\n\n# 1. 数学\n\n## 1.1 C<sub>n</sub><sup>m</sup>计算\n\n**思路**\n\n1. 用公式 **C<sub>n</sub><sup>m</sup> = C<sub>n-1</sub><sup>m</sup> + C<sub>n-1</sub><sup>m-1</sup>**\n\n   处理好边界值 C<sub>0</sub>^0^ = 1 , C~0~^1^ = 0 , C~1~^0^ = 1   \n\n   ```java\n   //\n   public static long calCnm1(int n, int m) {\n           if (n == m)\n               return 1;\n           if (n == 0)\n               return 0;\n           if (m == 0) {\n               return 1;\n           }\n           return calCnm1(n - 1, m) + calCnm1(n - 1, m - 1);\n       }\n   ```\n\n2. 直接用展开式阶乘计算\n\n   ```java\n   public static long calCnm2(int n, int m) {\n           if (m > n || m < 0) return 0;\n       //消除分子、分母重叠部分，只是为了简化计算，去掉这行也能运行\n           m = Math.min(m, n - m);\n           long result = 1;\n           for (int k = 1; k <= m; k++) {\n               result = result * (n - k + 1) / k;\n           }\n           return result;\n       }\n   ```\n\n## 1.2 快速幂\n\n**思路**：\n\n幂计算可以暴力O(n)复杂度直接for循环乘 x 得到，但是会重复计算部分值。\n\n考虑将n用位运算按二进制进行拆分 （例：5^9^ = 5<sup>2<sup>0</sup></sup> * 5<sup>2<sup>3</sup></sup> 即 5^9^ = 5^1^ * 5^8^）。5^1^*5^1^ = 5^2^   5^2^ * 5^2^ = 5^4^  5^4^ * 5^4^ = 5^8^ 这样可以将时间复杂度缩减到 O(log n)\n\n```java\npublic class fastPow {\n    static int MOD = 100000007;\n    public static void main(String[] args) {\n        System.out.println(pow(3, 4));\n    }\n    \n    public static long pow(int x, int n) {\n        long ans = 1;\n        while (n > 0) {\n            //对应二进制位为1则乘上结果\n            if ((n & 1) == 1) {\n                ans = ans * x % MOD;\n            }\n            //更新中间结果\n            x = x * x % MOD;\n            //位运算右移一位\n            n >>= 1;\n        }\n        return ans;\n    }\n}\n```\n\n# 2. 最短路径\n\n## 2.1 Dijkstra\n\n**前提**：路径无负值。\n\n**思路**（贪心）：\n\n1. 一点与其相邻点之间的距离最短的那一点一定是最短距离。\n\n   例：A的相邻点和距离分别为{B,C,D,E,F} ，{5,2,3,4,9}。那么A点到C点的最短距离一定是2。\n\n2. 求一点到另一点的最短路径，可以由一点和他相邻点的最短路径推出来。\n\n   接着上面的例子，假设C到F的距离是1，因为 9 > 2+1 那么A与其他点的距离为{B,C,E,F} {5,3,4,3}，那么A到F点的最短距离是3，到C点的最短距离也为3。\n\n路径信息不建议使用数组存放，数组会记录许多无效路径，可能超内存。\n\n1. 数组版\n\n   ```java\n   //LeetCode_1514为例，数组版会超时\n   public double djst1(int n, int start, int end, int[][] edges, double[] succProb) {\n       //dist存放其它节点与起点最近距离\n           double[] dist = new double[n];\n       //优先队列获取最小值，避免O(n)时间复杂度遍历dist数组\n          Queue<Integer> queue = new PriorityQueue<>((o1, o2) -> Double.compare(dist[o2], dist[o1]));\n           double[][] graph = new double[n][n];\n       //1.初始化\n           for (int i = 0; i < edges.length; i++) {\n               graph[edges[i][0]][edges[i][1]] = succProb[i];\n               graph[edges[i][1]][edges[i][0]] = succProb[i];\n               if (edges[i][0] == start) {\n                   dist[edges[i][1]] = succProb[i];\n                   queue.add(edges[i][1]);\n               } else if (edges[i][1] == start) {\n                   dist[edges[i][0]] = succProb[i];\n                   queue.add(edges[i][0]);\n               }\n           }\n       //2.具体更新距离逻辑\n           while (!queue.isEmpty()) {\n               int node = queue.poll();\n               for (int i = 0; i < n; i++) {\n                   //更新距离逻辑，可根据题目变化更改具体的判断逻辑，只要符合求最小值的逻辑即可\n                   if (graph[node][i] != 0 && dist[i] < graph[node][i] * dist[node]) {\n                       dist[i] = graph[node][i] * dist[node];\n                       queue.add(i);\n                   }\n               }\n           }\n           return dist[end];\n       }\n   ```\n\n2. 邻接矩阵版\n\n   ```java\n   public double djst2(int n, int start, int end, int[][] edges, double[] succProb) {\n           double[] dist = new double[n];\n            Queue<Integer> queue = new PriorityQueue<>((o1, o2) -> Double.compare(dist[o2], dist[o1]));\n           double[][] graph = new double[n][n];\n           for (int i = 0; i < edges.length; i++) {\n               graph[edges[i][0]][edges[i][1]] = succProb[i];\n               graph[edges[i][1]][edges[i][0]] = succProb[i];\n               if (edges[i][0] == start) {\n                   dist[edges[i][1]] = succProb[i];\n                   queue.add(edges[i][1]);\n               } else if (edges[i][1] == start) {\n                   dist[edges[i][0]] = succProb[i];\n                   queue.add(edges[i][0]);\n               }\n           }\n           while (!queue.isEmpty()) {\n               int node = queue.poll();\n               for (int i = 0; i < n; i++) {\n                   if (graph[node][i] != 0 && dist[i] < graph[node][i] * dist[node]) {\n                       dist[i] = graph[node][i] * dist[node];\n                       queue.add(i);\n                   }\n               }\n           }\n           return dist[end];\n       }\n   \n   class Pair {\n       double succProb;\n       int node;\n   \n       public Pair(double succProb, int node) {\n           this.succProb = succProb;\n           this.node = node;\n       }\n   }\n   ```\n\n## 2.2 Floyd\n\n**思路**：动态规划\n\n1. 节点i、j之间的最小值一定由i、k与k、j之间转移过来\n\n```java\npublic void floyd(int n,int[][] arr) {\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    arr[i][j] = Math.min(arr[i][j], arr[i][k] + arr[k][j]);\n                }\n            }\n        }\n    }\n```\n\nFloyd时间复杂度为O(n^3^)，Dijkstra为O(n^2^)，不过Floyd可以求每两点之前最小值，并且把min改成max就可以求最大路径了。\n\n# 3. 单例模式\n\n## 3.1 类直接持有单例\n\n```java\n/**\n * @description: 饿汉模式\n * @author：ruizhi\n * @date: 2024/10/26\n * @Copyright：\n */\npublic class SingletonPattern2 {\n    public static final SingletonPattern2 INSTANCE = new SingletonPattern2();\n    public SingletonPattern2 getInstance(){\n        return INSTANCE;\n    }\n}\n```\n\n\n\n```java\n/**\n * @description: 双检锁实现,懒汉模式\n * @author：ruizhi\n * @date: 2024/10/26\n * @Copyright：\n */\npublic class SingletonPattern1 {\n    //volatile 用于禁止JVM指令重排\n    public static volatile SingletonPattern1 INSTANCE;\n    //常规的双检锁校验\n    public SingletonPattern1 getINSTANCE() {\n        if(INSTANCE == null){\n            synchronized (SingletonPattern1.class){\n                if(INSTANCE == null){\n                    //具体的初始化逻辑\n                    INSTANCE = new SingletonPattern1();\n                    try{\n                        Thread.sleep(350L);\n                    }catch (InterruptedException e){\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        return INSTANCE;\n    }\n    private SingletonPattern1(){\n        //将构造方法改为静态，防止外部调用\n    }\n}\n```\n\n## 3.2 类间接持有属性\n\n```java\n/**\n * @description: 使用静态内部类持有单例对象\n * @author：ruizhi\n * @date: 2024/10/26\n * @Copyright：\n */\npublic class SingletonPattern4 {\n    private SingletonPattern4(){\n\n    }\n    public static class InnerSingleton {\n        private static SingletonPattern4 instance=new SingletonPattern4();// 自行创建实例\n    }\n\n    public static SingletonPattern4 getInstance() {\n        return InnerSingleton.instance;/\n    }\n}\n\n```\n\n```java\n/**\n * @description: 使用枚举持有单例对象，反序列化不会创建新对象\n * @author：ruizhi\n * @date: 2024/10/26\n * @Copyright：\n */\npublic class SingletonPattern3 {\n    private SingletonPattern3(){\n\n    }\n    private enum Singleton{\n        INSTANCE;\n\n        private final SingletonPattern3 instance;\n        Singleton(){\n            instance = new SingletonPattern3();\n        }\n        private SingletonPattern3 getInstance(){\n            return instance;\n        }\n    }\n    public static SingletonPattern3 getInstance(){\n        return Singleton.INSTANCE.getInstance();\n    }\n}\n\n```\n\n# 4. 二分 + BFS\n\n```java\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n/**\n * @description: 二分+BFS，DFS需重复判断depth会超时\n * @author：ruizhi\n * @date: 2024/10/27\n * @Copyright：\n */\n/*\n描述\n\n有一个NxN 大小的迷宫。初始状态下，配送员位于迷官的左上角，他希望前往迷宫的右下角。\n配送员只能沿着上下左右四个方向移动，从每个格子移动到相邻格子所需要的时间是1个单位，他必须用最多 K个(也可以少于 K 个)单位时间到达右下角格子。\n迷宫的每个格子都有辐射值，配送员必须穿着防护能力不低于相应辐射值的防护服，才能通过该格子。他希望知道，防护服的防护能力最少要达到多少，他才能顺利完成任务。注意:配送员需要通过迷官的左上角和右下角，因此防护服的防护能力必须大于等于这两个格子的辐射值。\n\n输入描述\n\n前两行各包含一个正整数，分别对应N和K，后 N 行各包含 N 整数，以空格分隔，表示地图上每个位置的辐射值。\n2≤N≤100 。K≥2N-2，以保证题目有解。所有辐射值都是非负整数，绝对值不超过 10^4\n\n输出描述\n\n一个整数，表示配送员穿着防护服的最低防护能力。\n\n用例输入\n\n5\n12\n0 0 0 0 0\n9 9 3 9 0\n0 0 0 0 0\n0 9 5 9 9\n0 0 0 0 0\n\n用例输出\n3\n */\npublic class ProtectiveEquipment_20240919_2 {\n    static int[][] dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int[][] arr = new int[n][n];\n        int right = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                arr[i][j] = in.nextInt();\n                right = Math.max(arr[i][j], right);\n            }\n        }\n        int left = Math.max(arr[0][0], arr[n - 1][n - 1]);\n        int result = right;\n        //结果可能区间二分判断\n        while (left <= right) {\n            int mid = left + ((right - left) >> 1);\n            if (check(mid, arr, n, k)) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        System.out.println(result);\n    }\n    /*\n    \t判断防护值为limit，k步内是否能走到右下角\n    */\n    public static boolean check(int limit, int[][] arr, int n, int k) {\n        boolean[][] used = new boolean[n][n];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{0, 0});\n        used[0][0] = true;\n        int depth = 0;\n        while (!queue.isEmpty() && depth < k) {\n            depth++;\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] pos = queue.poll();\n                for (int[] ints : dir) {\n                    int newI = pos[0] + ints[0];\n                    int newJ = pos[1] + ints[1];\n                    if (newI == n - 1 && newJ == n - 1)\n                        return true;\n                    if (newI >= 0 && newJ >= 0 && newI < n && newJ < n && !used[newI][newJ] && arr[newI][newJ] <= limit) {\n                        used[newI][newJ] = true;\n                        queue.add(new int[]{newI, newJ});\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n# 5. 并查集\n\n```java\n/**\n * @description: 并查集，主要是图的连通块相关的题目\n * @author：ruizhi\n * @date: 2024/10/28\n * @Copyright：\n */\npublic class UnionFind {\n    public void demo (int[][] edges,int n) {\n        int[] parent = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            parent[i] = i;\n        }\n        for (int i = 0; i < n; i++) {\n           //并查集生成过程\n            int[] edge = edges[i];\n            //连通边\n            int node1 = edge[0], node2 = edge[1];\n            //根节点不相同，则合并\n            if (find(parent, node1) != find(parent, node2)) {\n                union(parent, node1, node2);\n            }\n        }\n        //可以遍历数组来看有几个不同的根节点看连通块\n        //可以在遍历过程中看有几条对连通无效的边\n    }\n    public void union(int[] parent, int index1, int index2) {\n        parent[find(parent, index1)] = find(parent, index2);\n    }\n    //递归查找，并统一将子节点指向同一个根节点\n    public int find(int[] parent, int index) {\n        if (parent[index] != index) {\n            parent[index] = find(parent, parent[index]);\n        }\n        return parent[index];\n    }\n}\n```\n\n","slug":"算法合集","published":1,"updated":"2024-10-28T02:15:08.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2vyo6bw001iskusax41absa","content":"<p>算法基础</p>\n<span id=\"more\"></span>\n\n<h1 id=\"1-数学\"><a href=\"#1-数学\" class=\"headerlink\" title=\"1. 数学\"></a>1. 数学</h1><h2 id=\"1-1-Cnm计算\"><a href=\"#1-1-Cnm计算\" class=\"headerlink\" title=\"1.1 Cnm计算\"></a>1.1 C<sub>n</sub><sup>m</sup>计算</h2><p><strong>思路</strong></p>\n<ol>\n<li><p>用公式 <strong>C<sub>n</sub><sup>m</sup> &#x3D; C<sub>n-1</sub><sup>m</sup> + C<sub>n-1</sub><sup>m-1</sup></strong></p>\n<p>处理好边界值 C<sub>0</sub>^0^ &#x3D; 1 , C<del>0</del>^1^ &#x3D; 0 , C<del>1</del>^0^ &#x3D; 1   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">calCnm1</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == m)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> calCnm1(n - <span class=\"number\">1</span>, m) + calCnm1(n - <span class=\"number\">1</span>, m - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接用展开式阶乘计算</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">calCnm2</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m &gt; n || m &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//消除分子、分母重叠部分，只是为了简化计算，去掉这行也能运行</span></span><br><span class=\"line\">        m = Math.min(m, n - m);</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; k &lt;= m; k++) &#123;</span><br><span class=\"line\">            result = result * (n - k + <span class=\"number\">1</span>) / k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"1-2-快速幂\"><a href=\"#1-2-快速幂\" class=\"headerlink\" title=\"1.2 快速幂\"></a>1.2 快速幂</h2><p><strong>思路</strong>：</p>\n<p>幂计算可以暴力O(n)复杂度直接for循环乘 x 得到，但是会重复计算部分值。</p>\n<p>考虑将n用位运算按二进制进行拆分 （例：5^9^ &#x3D; 5<sup>2<sup>0</sup></sup> * 5<sup>2<sup>3</sup></sup> 即 5^9^ &#x3D; 5^1^ * 5^8^）。5^1^*5^1^ &#x3D; 5^2^   5^2^ * 5^2^ &#x3D; 5^4^  5^4^ * 5^4^ &#x3D; 5^8^ 这样可以将时间复杂度缩减到 O(log n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">fastPow</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">MOD</span> <span class=\"operator\">=</span> <span class=\"number\">100000007</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(pow(<span class=\"number\">3</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">pow</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//对应二进制位为1则乘上结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans = ans * x % MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//更新中间结果</span></span><br><span class=\"line\">            x = x * x % MOD;</span><br><span class=\"line\">            <span class=\"comment\">//位运算右移一位</span></span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-最短路径\"><a href=\"#2-最短路径\" class=\"headerlink\" title=\"2. 最短路径\"></a>2. 最短路径</h1><h2 id=\"2-1-Dijkstra\"><a href=\"#2-1-Dijkstra\" class=\"headerlink\" title=\"2.1 Dijkstra\"></a>2.1 Dijkstra</h2><p><strong>前提</strong>：路径无负值。</p>\n<p><strong>思路</strong>（贪心）：</p>\n<ol>\n<li><p>一点与其相邻点之间的距离最短的那一点一定是最短距离。</p>\n<p>例：A的相邻点和距离分别为{B,C,D,E,F} ，{5,2,3,4,9}。那么A点到C点的最短距离一定是2。</p>\n</li>\n<li><p>求一点到另一点的最短路径，可以由一点和他相邻点的最短路径推出来。</p>\n<p>接着上面的例子，假设C到F的距离是1，因为 9 &gt; 2+1 那么A与其他点的距离为{B,C,E,F} {5,3,4,3}，那么A到F点的最短距离是3，到C点的最短距离也为3。</p>\n</li>\n</ol>\n<p>路径信息不建议使用数组存放，数组会记录许多无效路径，可能超内存。</p>\n<ol>\n<li><p>数组版</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//LeetCode_1514为例，数组版会超时</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">djst1</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span>[][] edges, <span class=\"type\">double</span>[] succProb)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//dist存放其它节点与起点最近距离</span></span><br><span class=\"line\">        <span class=\"type\">double</span>[] dist = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[n];</span><br><span class=\"line\">    <span class=\"comment\">//优先队列获取最小值，避免O(n)时间复杂度遍历dist数组</span></span><br><span class=\"line\">       Queue&lt;Integer&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; Double.compare(dist[o2], dist[o1]));</span><br><span class=\"line\">        <span class=\"type\">double</span>[][] graph = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[n][n];</span><br><span class=\"line\">    <span class=\"comment\">//1.初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class=\"line\">            graph[edges[i][<span class=\"number\">0</span>]][edges[i][<span class=\"number\">1</span>]] = succProb[i];</span><br><span class=\"line\">            graph[edges[i][<span class=\"number\">1</span>]][edges[i][<span class=\"number\">0</span>]] = succProb[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (edges[i][<span class=\"number\">0</span>] == start) &#123;</span><br><span class=\"line\">                dist[edges[i][<span class=\"number\">1</span>]] = succProb[i];</span><br><span class=\"line\">                queue.add(edges[i][<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (edges[i][<span class=\"number\">1</span>] == start) &#123;</span><br><span class=\"line\">                dist[edges[i][<span class=\"number\">0</span>]] = succProb[i];</span><br><span class=\"line\">                queue.add(edges[i][<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">//2.具体更新距离逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//更新距离逻辑，可根据题目变化更改具体的判断逻辑，只要符合求最小值的逻辑即可</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (graph[node][i] != <span class=\"number\">0</span> &amp;&amp; dist[i] &lt; graph[node][i] * dist[node]) &#123;</span><br><span class=\"line\">                    dist[i] = graph[node][i] * dist[node];</span><br><span class=\"line\">                    queue.add(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist[end];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>邻接矩阵版</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">djst2</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span>[][] edges, <span class=\"type\">double</span>[] succProb)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">double</span>[] dist = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[n];</span><br><span class=\"line\">         Queue&lt;Integer&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; Double.compare(dist[o2], dist[o1]));</span><br><span class=\"line\">        <span class=\"type\">double</span>[][] graph = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[n][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class=\"line\">            graph[edges[i][<span class=\"number\">0</span>]][edges[i][<span class=\"number\">1</span>]] = succProb[i];</span><br><span class=\"line\">            graph[edges[i][<span class=\"number\">1</span>]][edges[i][<span class=\"number\">0</span>]] = succProb[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (edges[i][<span class=\"number\">0</span>] == start) &#123;</span><br><span class=\"line\">                dist[edges[i][<span class=\"number\">1</span>]] = succProb[i];</span><br><span class=\"line\">                queue.add(edges[i][<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (edges[i][<span class=\"number\">1</span>] == start) &#123;</span><br><span class=\"line\">                dist[edges[i][<span class=\"number\">0</span>]] = succProb[i];</span><br><span class=\"line\">                queue.add(edges[i][<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (graph[node][i] != <span class=\"number\">0</span> &amp;&amp; dist[i] &lt; graph[node][i] * dist[node]) &#123;</span><br><span class=\"line\">                    dist[i] = graph[node][i] * dist[node];</span><br><span class=\"line\">                    queue.add(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist[end];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Pair</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> succProb;</span><br><span class=\"line\">    <span class=\"type\">int</span> node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Pair</span><span class=\"params\">(<span class=\"type\">double</span> succProb, <span class=\"type\">int</span> node)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.succProb = succProb;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.node = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-2-Floyd\"><a href=\"#2-2-Floyd\" class=\"headerlink\" title=\"2.2 Floyd\"></a>2.2 Floyd</h2><p><strong>思路</strong>：动态规划</p>\n<ol>\n<li>节点i、j之间的最小值一定由i、k与k、j之间转移过来</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">floyd</span><span class=\"params\">(<span class=\"type\">int</span> n,<span class=\"type\">int</span>[][] arr)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; k &lt; n; k++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                    arr[i][j] = Math.min(arr[i][j], arr[i][k] + arr[k][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Floyd时间复杂度为O(n^3^)，Dijkstra为O(n^2^)，不过Floyd可以求每两点之前最小值，并且把min改成max就可以求最大路径了。</p>\n<h1 id=\"3-单例模式\"><a href=\"#3-单例模式\" class=\"headerlink\" title=\"3. 单例模式\"></a>3. 单例模式</h1><h2 id=\"3-1-类直接持有单例\"><a href=\"#3-1-类直接持有单例\" class=\"headerlink\" title=\"3.1 类直接持有单例\"></a>3.1 类直接持有单例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 饿汉模式</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>：ruizhi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 2024/10/26</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Copyright</span>：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonPattern2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">SingletonPattern2</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SingletonPattern2</span>();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> SingletonPattern2 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 双检锁实现,懒汉模式</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>：ruizhi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 2024/10/26</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Copyright</span>：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonPattern1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//volatile 用于禁止JVM指令重排</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> SingletonPattern1 INSTANCE;</span><br><span class=\"line\">    <span class=\"comment\">//常规的双检锁校验</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> SingletonPattern1 <span class=\"title function_\">getINSTANCE</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(INSTANCE == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (SingletonPattern1.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(INSTANCE == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//具体的初始化逻辑</span></span><br><span class=\"line\">                    INSTANCE = <span class=\"keyword\">new</span> <span class=\"title class_\">SingletonPattern1</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                        Thread.sleep(<span class=\"number\">350L</span>);</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">SingletonPattern1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将构造方法改为静态，防止外部调用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-类间接持有属性\"><a href=\"#3-2-类间接持有属性\" class=\"headerlink\" title=\"3.2 类间接持有属性\"></a>3.2 类间接持有属性</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 使用静态内部类持有单例对象</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>：ruizhi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 2024/10/26</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Copyright</span>：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonPattern4</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">SingletonPattern4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InnerSingleton</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingletonPattern4 instance=<span class=\"keyword\">new</span> <span class=\"title class_\">SingletonPattern4</span>();<span class=\"comment\">// 自行创建实例</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonPattern4 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> InnerSingleton.instance;/</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 使用枚举持有单例对象，反序列化不会创建新对象</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>：ruizhi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 2024/10/26</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Copyright</span>：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonPattern3</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">SingletonPattern3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Singleton</span>&#123;</span><br><span class=\"line\">        INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SingletonPattern3 instance;</span><br><span class=\"line\">        Singleton()&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">SingletonPattern3</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> SingletonPattern3 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonPattern3 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Singleton.INSTANCE.getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-二分-BFS\"><a href=\"#4-二分-BFS\" class=\"headerlink\" title=\"4. 二分 + BFS\"></a>4. 二分 + BFS</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 二分+BFS，DFS需重复判断depth会超时</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>：ruizhi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 2024/10/27</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Copyright</span>：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">描述</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">有一个NxN 大小的迷宫。初始状态下，配送员位于迷官的左上角，他希望前往迷宫的右下角。</span></span><br><span class=\"line\"><span class=\"comment\">配送员只能沿着上下左右四个方向移动，从每个格子移动到相邻格子所需要的时间是1个单位，他必须用最多 K个(也可以少于 K 个)单位时间到达右下角格子。</span></span><br><span class=\"line\"><span class=\"comment\">迷宫的每个格子都有辐射值，配送员必须穿着防护能力不低于相应辐射值的防护服，才能通过该格子。他希望知道，防护服的防护能力最少要达到多少，他才能顺利完成任务。注意:配送员需要通过迷官的左上角和右下角，因此防护服的防护能力必须大于等于这两个格子的辐射值。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">输入描述</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">前两行各包含一个正整数，分别对应N和K，后 N 行各包含 N 整数，以空格分隔，表示地图上每个位置的辐射值。</span></span><br><span class=\"line\"><span class=\"comment\">2≤N≤100 。K≥2N-2，以保证题目有解。所有辐射值都是非负整数，绝对值不超过 10^4</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">输出描述</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">一个整数，表示配送员穿着防护服的最低防护能力。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">用例输入</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">5</span></span><br><span class=\"line\"><span class=\"comment\">12</span></span><br><span class=\"line\"><span class=\"comment\">0 0 0 0 0</span></span><br><span class=\"line\"><span class=\"comment\">9 9 3 9 0</span></span><br><span class=\"line\"><span class=\"comment\">0 0 0 0 0</span></span><br><span class=\"line\"><span class=\"comment\">0 9 5 9 9</span></span><br><span class=\"line\"><span class=\"comment\">0 0 0 0 0</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">用例输出</span></span><br><span class=\"line\"><span class=\"comment\">3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProtectiveEquipment_20240919_2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span>[][] dir = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[][]&#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n][n];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                arr[i][j] = in.nextInt();</span><br><span class=\"line\">                right = Math.max(arr[i][j], right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> Math.max(arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>], arr[n - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> right;</span><br><span class=\"line\">        <span class=\"comment\">//结果可能区间二分判断</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + ((right - left) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (check(mid, arr, n, k)) &#123;</span><br><span class=\"line\">                result = mid;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    \t判断防护值为limit，k步内是否能走到右下角</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">check</span><span class=\"params\">(<span class=\"type\">int</span> limit, <span class=\"type\">int</span>[][] arr, <span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] used = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][n];</span><br><span class=\"line\">        Queue&lt;<span class=\"type\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        queue.add(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">        used[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">depth</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty() &amp;&amp; depth &lt; k) &#123;</span><br><span class=\"line\">            depth++;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> queue.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span>[] pos = queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span>[] ints : dir) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">newI</span> <span class=\"operator\">=</span> pos[<span class=\"number\">0</span>] + ints[<span class=\"number\">0</span>];</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">newJ</span> <span class=\"operator\">=</span> pos[<span class=\"number\">1</span>] + ints[<span class=\"number\">1</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (newI == n - <span class=\"number\">1</span> &amp;&amp; newJ == n - <span class=\"number\">1</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (newI &gt;= <span class=\"number\">0</span> &amp;&amp; newJ &gt;= <span class=\"number\">0</span> &amp;&amp; newI &lt; n &amp;&amp; newJ &lt; n &amp;&amp; !used[newI][newJ] &amp;&amp; arr[newI][newJ] &lt;= limit) &#123;</span><br><span class=\"line\">                        used[newI][newJ] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        queue.add(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;newI, newJ&#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-并查集\"><a href=\"#5-并查集\" class=\"headerlink\" title=\"5. 并查集\"></a>5. 并查集</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 并查集，主要是图的连通块相关的题目</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>：ruizhi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 2024/10/28</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Copyright</span>：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UnionFind</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">demo</span> <span class=\"params\">(<span class=\"type\">int</span>[][] edges,<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] parent = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            parent[i] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">           <span class=\"comment\">//并查集生成过程</span></span><br><span class=\"line\">            <span class=\"type\">int</span>[] edge = edges[i];</span><br><span class=\"line\">            <span class=\"comment\">//连通边</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">node1</span> <span class=\"operator\">=</span> edge[<span class=\"number\">0</span>], node2 = edge[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"comment\">//根节点不相同，则合并</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (find(parent, node1) != find(parent, node2)) &#123;</span><br><span class=\"line\">                union(parent, node1, node2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//可以遍历数组来看有几个不同的根节点看连通块</span></span><br><span class=\"line\">        <span class=\"comment\">//可以在遍历过程中看有几条对连通无效的边</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">union</span><span class=\"params\">(<span class=\"type\">int</span>[] parent, <span class=\"type\">int</span> index1, <span class=\"type\">int</span> index2)</span> &#123;</span><br><span class=\"line\">        parent[find(parent, index1)] = find(parent, index2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//递归查找，并统一将子节点指向同一个根节点</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">find</span><span class=\"params\">(<span class=\"type\">int</span>[] parent, <span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent[index] != index) &#123;</span><br><span class=\"line\">            parent[index] = find(parent, parent[index]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"length":2134,"excerpt":"<p>算法基础</p>","more":"<h1 id=\"1-数学\"><a href=\"#1-数学\" class=\"headerlink\" title=\"1. 数学\"></a>1. 数学</h1><h2 id=\"1-1-Cnm计算\"><a href=\"#1-1-Cnm计算\" class=\"headerlink\" title=\"1.1 Cnm计算\"></a>1.1 C<sub>n</sub><sup>m</sup>计算</h2><p><strong>思路</strong></p>\n<ol>\n<li><p>用公式 <strong>C<sub>n</sub><sup>m</sup> &#x3D; C<sub>n-1</sub><sup>m</sup> + C<sub>n-1</sub><sup>m-1</sup></strong></p>\n<p>处理好边界值 C<sub>0</sub>^0^ &#x3D; 1 , C<del>0</del>^1^ &#x3D; 0 , C<del>1</del>^0^ &#x3D; 1   </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">calCnm1</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == m)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> calCnm1(n - <span class=\"number\">1</span>, m) + calCnm1(n - <span class=\"number\">1</span>, m - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接用展开式阶乘计算</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">calCnm2</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m &gt; n || m &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//消除分子、分母重叠部分，只是为了简化计算，去掉这行也能运行</span></span><br><span class=\"line\">        m = Math.min(m, n - m);</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; k &lt;= m; k++) &#123;</span><br><span class=\"line\">            result = result * (n - k + <span class=\"number\">1</span>) / k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"1-2-快速幂\"><a href=\"#1-2-快速幂\" class=\"headerlink\" title=\"1.2 快速幂\"></a>1.2 快速幂</h2><p><strong>思路</strong>：</p>\n<p>幂计算可以暴力O(n)复杂度直接for循环乘 x 得到，但是会重复计算部分值。</p>\n<p>考虑将n用位运算按二进制进行拆分 （例：5^9^ &#x3D; 5<sup>2<sup>0</sup></sup> * 5<sup>2<sup>3</sup></sup> 即 5^9^ &#x3D; 5^1^ * 5^8^）。5^1^*5^1^ &#x3D; 5^2^   5^2^ * 5^2^ &#x3D; 5^4^  5^4^ * 5^4^ &#x3D; 5^8^ 这样可以将时间复杂度缩减到 O(log n)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">fastPow</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">MOD</span> <span class=\"operator\">=</span> <span class=\"number\">100000007</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(pow(<span class=\"number\">3</span>, <span class=\"number\">4</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">long</span> <span class=\"title function_\">pow</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//对应二进制位为1则乘上结果</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((n &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans = ans * x % MOD;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//更新中间结果</span></span><br><span class=\"line\">            x = x * x % MOD;</span><br><span class=\"line\">            <span class=\"comment\">//位运算右移一位</span></span><br><span class=\"line\">            n &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-最短路径\"><a href=\"#2-最短路径\" class=\"headerlink\" title=\"2. 最短路径\"></a>2. 最短路径</h1><h2 id=\"2-1-Dijkstra\"><a href=\"#2-1-Dijkstra\" class=\"headerlink\" title=\"2.1 Dijkstra\"></a>2.1 Dijkstra</h2><p><strong>前提</strong>：路径无负值。</p>\n<p><strong>思路</strong>（贪心）：</p>\n<ol>\n<li><p>一点与其相邻点之间的距离最短的那一点一定是最短距离。</p>\n<p>例：A的相邻点和距离分别为{B,C,D,E,F} ，{5,2,3,4,9}。那么A点到C点的最短距离一定是2。</p>\n</li>\n<li><p>求一点到另一点的最短路径，可以由一点和他相邻点的最短路径推出来。</p>\n<p>接着上面的例子，假设C到F的距离是1，因为 9 &gt; 2+1 那么A与其他点的距离为{B,C,E,F} {5,3,4,3}，那么A到F点的最短距离是3，到C点的最短距离也为3。</p>\n</li>\n</ol>\n<p>路径信息不建议使用数组存放，数组会记录许多无效路径，可能超内存。</p>\n<ol>\n<li><p>数组版</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//LeetCode_1514为例，数组版会超时</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">djst1</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span>[][] edges, <span class=\"type\">double</span>[] succProb)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//dist存放其它节点与起点最近距离</span></span><br><span class=\"line\">        <span class=\"type\">double</span>[] dist = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[n];</span><br><span class=\"line\">    <span class=\"comment\">//优先队列获取最小值，避免O(n)时间复杂度遍历dist数组</span></span><br><span class=\"line\">       Queue&lt;Integer&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; Double.compare(dist[o2], dist[o1]));</span><br><span class=\"line\">        <span class=\"type\">double</span>[][] graph = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[n][n];</span><br><span class=\"line\">    <span class=\"comment\">//1.初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class=\"line\">            graph[edges[i][<span class=\"number\">0</span>]][edges[i][<span class=\"number\">1</span>]] = succProb[i];</span><br><span class=\"line\">            graph[edges[i][<span class=\"number\">1</span>]][edges[i][<span class=\"number\">0</span>]] = succProb[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (edges[i][<span class=\"number\">0</span>] == start) &#123;</span><br><span class=\"line\">                dist[edges[i][<span class=\"number\">1</span>]] = succProb[i];</span><br><span class=\"line\">                queue.add(edges[i][<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (edges[i][<span class=\"number\">1</span>] == start) &#123;</span><br><span class=\"line\">                dist[edges[i][<span class=\"number\">0</span>]] = succProb[i];</span><br><span class=\"line\">                queue.add(edges[i][<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\">//2.具体更新距离逻辑</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//更新距离逻辑，可根据题目变化更改具体的判断逻辑，只要符合求最小值的逻辑即可</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (graph[node][i] != <span class=\"number\">0</span> &amp;&amp; dist[i] &lt; graph[node][i] * dist[node]) &#123;</span><br><span class=\"line\">                    dist[i] = graph[node][i] * dist[node];</span><br><span class=\"line\">                    queue.add(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist[end];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>邻接矩阵版</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">djst2</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span>[][] edges, <span class=\"type\">double</span>[] succProb)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">double</span>[] dist = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[n];</span><br><span class=\"line\">         Queue&lt;Integer&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; Double.compare(dist[o2], dist[o1]));</span><br><span class=\"line\">        <span class=\"type\">double</span>[][] graph = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[n][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class=\"line\">            graph[edges[i][<span class=\"number\">0</span>]][edges[i][<span class=\"number\">1</span>]] = succProb[i];</span><br><span class=\"line\">            graph[edges[i][<span class=\"number\">1</span>]][edges[i][<span class=\"number\">0</span>]] = succProb[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (edges[i][<span class=\"number\">0</span>] == start) &#123;</span><br><span class=\"line\">                dist[edges[i][<span class=\"number\">1</span>]] = succProb[i];</span><br><span class=\"line\">                queue.add(edges[i][<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (edges[i][<span class=\"number\">1</span>] == start) &#123;</span><br><span class=\"line\">                dist[edges[i][<span class=\"number\">0</span>]] = succProb[i];</span><br><span class=\"line\">                queue.add(edges[i][<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (graph[node][i] != <span class=\"number\">0</span> &amp;&amp; dist[i] &lt; graph[node][i] * dist[node]) &#123;</span><br><span class=\"line\">                    dist[i] = graph[node][i] * dist[node];</span><br><span class=\"line\">                    queue.add(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist[end];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Pair</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> succProb;</span><br><span class=\"line\">    <span class=\"type\">int</span> node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Pair</span><span class=\"params\">(<span class=\"type\">double</span> succProb, <span class=\"type\">int</span> node)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.succProb = succProb;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.node = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-2-Floyd\"><a href=\"#2-2-Floyd\" class=\"headerlink\" title=\"2.2 Floyd\"></a>2.2 Floyd</h2><p><strong>思路</strong>：动态规划</p>\n<ol>\n<li>节点i、j之间的最小值一定由i、k与k、j之间转移过来</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">floyd</span><span class=\"params\">(<span class=\"type\">int</span> n,<span class=\"type\">int</span>[][] arr)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; k &lt; n; k++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                    arr[i][j] = Math.min(arr[i][j], arr[i][k] + arr[k][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Floyd时间复杂度为O(n^3^)，Dijkstra为O(n^2^)，不过Floyd可以求每两点之前最小值，并且把min改成max就可以求最大路径了。</p>\n<h1 id=\"3-单例模式\"><a href=\"#3-单例模式\" class=\"headerlink\" title=\"3. 单例模式\"></a>3. 单例模式</h1><h2 id=\"3-1-类直接持有单例\"><a href=\"#3-1-类直接持有单例\" class=\"headerlink\" title=\"3.1 类直接持有单例\"></a>3.1 类直接持有单例</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 饿汉模式</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>：ruizhi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 2024/10/26</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Copyright</span>：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonPattern2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">SingletonPattern2</span> <span class=\"variable\">INSTANCE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SingletonPattern2</span>();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> SingletonPattern2 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 双检锁实现,懒汉模式</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>：ruizhi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 2024/10/26</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Copyright</span>：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonPattern1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//volatile 用于禁止JVM指令重排</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> SingletonPattern1 INSTANCE;</span><br><span class=\"line\">    <span class=\"comment\">//常规的双检锁校验</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> SingletonPattern1 <span class=\"title function_\">getINSTANCE</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(INSTANCE == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (SingletonPattern1.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(INSTANCE == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//具体的初始化逻辑</span></span><br><span class=\"line\">                    INSTANCE = <span class=\"keyword\">new</span> <span class=\"title class_\">SingletonPattern1</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                        Thread.sleep(<span class=\"number\">350L</span>);</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">catch</span> (InterruptedException e)&#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">SingletonPattern1</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将构造方法改为静态，防止外部调用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-类间接持有属性\"><a href=\"#3-2-类间接持有属性\" class=\"headerlink\" title=\"3.2 类间接持有属性\"></a>3.2 类间接持有属性</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 使用静态内部类持有单例对象</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>：ruizhi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 2024/10/26</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Copyright</span>：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonPattern4</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">SingletonPattern4</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">InnerSingleton</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> SingletonPattern4 instance=<span class=\"keyword\">new</span> <span class=\"title class_\">SingletonPattern4</span>();<span class=\"comment\">// 自行创建实例</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonPattern4 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> InnerSingleton.instance;/</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 使用枚举持有单例对象，反序列化不会创建新对象</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>：ruizhi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 2024/10/26</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Copyright</span>：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SingletonPattern3</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">SingletonPattern3</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">enum</span> <span class=\"title class_\">Singleton</span>&#123;</span><br><span class=\"line\">        INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SingletonPattern3 instance;</span><br><span class=\"line\">        Singleton()&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> <span class=\"title class_\">SingletonPattern3</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> SingletonPattern3 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SingletonPattern3 <span class=\"title function_\">getInstance</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Singleton.INSTANCE.getInstance();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-二分-BFS\"><a href=\"#4-二分-BFS\" class=\"headerlink\" title=\"4. 二分 + BFS\"></a>4. 二分 + BFS</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 二分+BFS，DFS需重复判断depth会超时</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>：ruizhi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 2024/10/27</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Copyright</span>：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">描述</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">有一个NxN 大小的迷宫。初始状态下，配送员位于迷官的左上角，他希望前往迷宫的右下角。</span></span><br><span class=\"line\"><span class=\"comment\">配送员只能沿着上下左右四个方向移动，从每个格子移动到相邻格子所需要的时间是1个单位，他必须用最多 K个(也可以少于 K 个)单位时间到达右下角格子。</span></span><br><span class=\"line\"><span class=\"comment\">迷宫的每个格子都有辐射值，配送员必须穿着防护能力不低于相应辐射值的防护服，才能通过该格子。他希望知道，防护服的防护能力最少要达到多少，他才能顺利完成任务。注意:配送员需要通过迷官的左上角和右下角，因此防护服的防护能力必须大于等于这两个格子的辐射值。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">输入描述</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">前两行各包含一个正整数，分别对应N和K，后 N 行各包含 N 整数，以空格分隔，表示地图上每个位置的辐射值。</span></span><br><span class=\"line\"><span class=\"comment\">2≤N≤100 。K≥2N-2，以保证题目有解。所有辐射值都是非负整数，绝对值不超过 10^4</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">输出描述</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">一个整数，表示配送员穿着防护服的最低防护能力。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">用例输入</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">5</span></span><br><span class=\"line\"><span class=\"comment\">12</span></span><br><span class=\"line\"><span class=\"comment\">0 0 0 0 0</span></span><br><span class=\"line\"><span class=\"comment\">9 9 3 9 0</span></span><br><span class=\"line\"><span class=\"comment\">0 0 0 0 0</span></span><br><span class=\"line\"><span class=\"comment\">0 9 5 9 9</span></span><br><span class=\"line\"><span class=\"comment\">0 0 0 0 0</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">用例输出</span></span><br><span class=\"line\"><span class=\"comment\">3</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ProtectiveEquipment_20240919_2</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span>[][] dir = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[][]&#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n][n];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                arr[i][j] = in.nextInt();</span><br><span class=\"line\">                right = Math.max(arr[i][j], right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> Math.max(arr[<span class=\"number\">0</span>][<span class=\"number\">0</span>], arr[n - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> right;</span><br><span class=\"line\">        <span class=\"comment\">//结果可能区间二分判断</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + ((right - left) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (check(mid, arr, n, k)) &#123;</span><br><span class=\"line\">                result = mid;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    \t判断防护值为limit，k步内是否能走到右下角</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">check</span><span class=\"params\">(<span class=\"type\">int</span> limit, <span class=\"type\">int</span>[][] arr, <span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] used = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][n];</span><br><span class=\"line\">        Queue&lt;<span class=\"type\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        queue.add(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">        used[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">depth</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty() &amp;&amp; depth &lt; k) &#123;</span><br><span class=\"line\">            depth++;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> queue.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span>[] pos = queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span>[] ints : dir) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">newI</span> <span class=\"operator\">=</span> pos[<span class=\"number\">0</span>] + ints[<span class=\"number\">0</span>];</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">newJ</span> <span class=\"operator\">=</span> pos[<span class=\"number\">1</span>] + ints[<span class=\"number\">1</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (newI == n - <span class=\"number\">1</span> &amp;&amp; newJ == n - <span class=\"number\">1</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (newI &gt;= <span class=\"number\">0</span> &amp;&amp; newJ &gt;= <span class=\"number\">0</span> &amp;&amp; newI &lt; n &amp;&amp; newJ &lt; n &amp;&amp; !used[newI][newJ] &amp;&amp; arr[newI][newJ] &lt;= limit) &#123;</span><br><span class=\"line\">                        used[newI][newJ] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        queue.add(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;newI, newJ&#125;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-并查集\"><a href=\"#5-并查集\" class=\"headerlink\" title=\"5. 并查集\"></a>5. 并查集</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description</span>: 并查集，主要是图的连通块相关的题目</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span>：ruizhi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span>: 2024/10/28</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Copyright</span>：</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UnionFind</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">demo</span> <span class=\"params\">(<span class=\"type\">int</span>[][] edges,<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] parent = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            parent[i] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">           <span class=\"comment\">//并查集生成过程</span></span><br><span class=\"line\">            <span class=\"type\">int</span>[] edge = edges[i];</span><br><span class=\"line\">            <span class=\"comment\">//连通边</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">node1</span> <span class=\"operator\">=</span> edge[<span class=\"number\">0</span>], node2 = edge[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"comment\">//根节点不相同，则合并</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (find(parent, node1) != find(parent, node2)) &#123;</span><br><span class=\"line\">                union(parent, node1, node2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//可以遍历数组来看有几个不同的根节点看连通块</span></span><br><span class=\"line\">        <span class=\"comment\">//可以在遍历过程中看有几条对连通无效的边</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">union</span><span class=\"params\">(<span class=\"type\">int</span>[] parent, <span class=\"type\">int</span> index1, <span class=\"type\">int</span> index2)</span> &#123;</span><br><span class=\"line\">        parent[find(parent, index1)] = find(parent, index2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//递归查找，并统一将子节点指向同一个根节点</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">find</span><span class=\"params\">(<span class=\"type\">int</span>[] parent, <span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent[index] != index) &#123;</span><br><span class=\"line\">            parent[index] = find(parent, parent[index]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"SpringBoot日志基础","date":"2024-09-03T08:09:34.000Z","_content":"\n文章主要介绍SpringBoot日志门面与系统，详细说明LogBack\n\n<!--more-->\n\n# 1.日志简述\n\n1. 现在大部分项目中使用的日志库可以分为**日志门面**和**日志库**（有点接口和实现类的感觉）\n2. 使用日志库和其它组件一样分为**配置**和**api的使用**\n\n## 1.1 日志门面\n\n### 1.1.1 common-logging\n\ncommon-logging 是 apache 的一个开源项目。也称Jakarta Commons Logging，缩写 JCL。\n\ncommon-logging 的功能是提供日志功能的 API 接口，本身并不提供日志的具体实现（当然，common-logging 内部有一个 Simple logger 的简单实现，但是功能很弱，直接忽略），而是在运行时动态的绑定日志实现组件来工作（如 log4j、java.util.loggin）。\n\n### 1.1.2 slf4j\n\n全称为 Simple Logging Facade for Java，即 java 简单日志门面。\n\nslf4j是项目中用的比较多的日志门户。类似于 Common-Logging，slf4j 是对不同日志框架提供的一个 API 封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。但是，slf4j 在编译时静态绑定真正的 Log 库。使用 SLF4J 时，如果你需要使用某一种日志实现，那么你必须选择正确的 SLF4J 的 jar 包的集合（各种桥接包）。\n\n## 1.2 日志系统\n\n### 1.2.1 不常用的日志系统\n\n1. **java.util.logging（JUL）**\n   官方提供的日志系统\n\n2. **Log4j**\n\n   Log4j 应该说是 Java 领域资格最老，应用最广的日志工具。Log4j 是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX 系统日志等。\n\n   Log4j 的短板在于性能，在Logback 和 Log4j2 出来之后，Log4j的使用也减少了。\n\n### 1.2.2 Logback\n\nLogback 是由 log4j 创始人 Ceki Gulcu 设计的又一个开源日志组件，是作为 Log4j 的继承者来开发的，提供了性能更好的实现，异步 logger，Filter等更多的特性。\n\nlogback 当前分成三个模块：logback-core、logback-classic 和 logback-access。\n\n+ logback-core - 是其它两个模块的基础模块。\n+ logback-classic - 是 log4j 的一个 改良版本。此外 logback-classic 完整实现 SLF4J API 使你可以很方便地更换成其它日志系统如 log4j 或 JDK14 Logging。\n+ logback-access - 访问模块与 Servlet 容器集成提供通过 Http 来访问日志的功能。\n\n官网地址: http://logback.qos.ch/\n\n### 1.2.3 Log4j2\n\n维护 Log4j 的人为了性能又搞出了 Log4j2。\n\nLog4j2 和 Log4j1.x 并不兼容，设计上很大程度上模仿了 SLF4J/Logback，性能上也获得了很大的提升。\n\nLog4j2 也做了 Facade/Implementation 分离的设计，分成了 log4j-api 和 log4j-core。\n\n\n\n# 2. logback\n\n[放个官方教程](https://logback.qos.ch/manual/index.html)\n\nlogback是由原来log4j1的团队编写的，成为了log4j1的替代品，是项目中使用较多的日志系统\n\n[官方给出使用logback而不是log4j1的原因](https://logback.qos.ch/reasonsToSwitch.html)\n\n## 2.1 依赖导入\n\nSpringBoot项目默认的日志实现就是logback，可以不导入任何依赖使用，如果不是Spring应用可以通过以下方式导入\n\n```xml\n<dependency>\n  <groupId>ch.qos.logback</groupId>\n  <artifactId>logback-classic</artifactId>\n  <version>1.5.6</version>\n</dependency>\n```\n\n项目中日志经常配合AOP使用，这里需要导入一下AOP的依赖\n\n```xml\n<!--aop的starter，也可以直接导入org.aspectj相关的包-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n## 2.2 简单使用\n\n```java\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\n//建议导入slf4j中的类，优先使用日志门面(阿里开发规范)\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@Aspect\n@Component\npublic class WebLogAspect {\n    public static final Logger logger= LoggerFactory.getLogger(WebLogAspect.class);\n    //所有请求都会经过ServletRequest的service方法\n    @Around(\"execution(public void javax.servlet.http.HttpServlet.service(..)))\")\n    public Object log(ProceedingJoinPoint jp) throws Throwable {\n        Object[] args = jp.getArgs();\n        HttpServletRequest request = (HttpServletRequest) args[0];\n        HttpServletResponse response = (HttpServletResponse) args[1];\n         String url = request.getRequestURL().toString();\n        String method = request.getMethod();\n        long startTime = System.currentTimeMillis();\n        try{\n            jp.proceed(new Object[]{request,response});\n        }catch (Throwable e){\n            throw e;\n        }\n        long time = (System.currentTimeMillis() - startTime);\n        logger.info(\"请求路径为{},请求参数为{}\",url,method);\n        logger.info(\"响应状态码为{}\",response.getStatus());\n        logger.info(\"接口响应时间为{}ms\",time);\n        return null;\n    }\n}\n```\n\n这个切面会拦截所有请求，然后打印出请求的路径、参数，响应的状态码以及响应时间。AOP以及javaWeb的内容不是本文的重点，我们重点关注一下`Logger`\n\n现在问题来了，这个`Logger`到底是什么？从`WebLogAspect.class`中getLogger是什么意思？logger.info()又是什么方法？\n\n为了解答这些问题我们先来看看logback日志打印的一些组件（其实log4j1、logback、log4j2中组件都差不多，只是配置文件写法可能有点差异）\n\n## 2.3 组件说明\n\n### 2.3.1 Logger\n\nlogback中的记录器都会缓存在一个Map中（就像Spring缓存Bean那样），记录器Logger是有层级、有继承关系的（具体见LoggerContext）。\n\nLogback的Logger是slf4j中Logger的实现，下面是logback中Logger的实现以及Logger的一些属性\n\n```java\npackage ch.qos.logback.classic;\n\npublic final class Logger implements org.slf4j.Logger, LocationAwareLogger, AppenderAttachable<ILoggingEvent>, Serializable {\n    public static final String FQCN = Logger.class.getName();\n    private String name;\n    private transient Level level;\n    private transient int effectiveLevelInt;\n    private transient Logger parent;\n    private transient List<Logger> childrenList;\n    //持有Appender\n    private transient AppenderAttachableImpl<ILoggingEvent> aai;\n    private transient boolean additive = true;\n    final transient LoggerContext loggerContext;\n}\n```\n\n#### Logger中的属性\n\n- **name**：上面我们知道记录器是缓存在Map中的，这个**name**就是Map的**key**\n\n  `LoggerFactory.getLogger()`的入参有两个，**name** 和 **class**，传入class的时候，name就是类的全限定名\n\n- **Level**：我们知道日志是有级别的，比如上面调用的`info`，级别关系如下\n\n  **TRACE** < **DEBUG** < **INFO** < **WARN** < **ERROR** < **FATAL** < **OFF**\n\n  Logger中的Level表示这个Logger能支持打印的最低级别，默认是 **DEBUG**，当调用低于Level级别日志打印方法时会没有显示（可以把上面代码改成trace()方法试试）\n\n- **parent**与**childrenList**\n\n  用来维护Logger层级关系的属性，`getLogger()`时会先从Map里面拿，取不到的时候再创建，Logger创建时会检测有无父Logger，没有的话会创建父Logger，然后会检测父Logger有无父Logger，循环往上直到碰到顶级Logger（name为ROOT的Logger）。\n\n  **举例**：\n\n  ```java\n  //我项目中的类的全限定名是org.example.demo.aspect.WebLogAspect\n  public static final Logger logger= LoggerFactory.getLogger(WebLogAspect.class);\n  ```\n\n  那么创建的时候就会先检测是否有**name**为**\"WebLogAspect\"**的Logger，没有的话再检测是否有 **name**为 **aspect**的Logger，又没有的话会检测是否有 **name**为 **demo**的Logger ... 直到检测到没有 **name**为**org**的Logger ，**org的父类是 \"ROOT\"**，这时会根据ROOT中的属性来创建 **\"org\"**，根据 **\"org\"**创建 **\"example\"**直到 **\"WebLogAspect\"**被创建\n\n  系统默认的属性都会放在**\"ROOT\"**中，比如上面说的Level默认是DEBUG\n\n### 2.3.2 appender\n\nLogger会将输出日志的任务交给Appender（附加器）来完成，不同的Appender会将日志打印到不同的地方，比如控制台附加器、文件附加器、网络附加器\n\nLogback中的appender是一个接口，以下是官网扒下来的结构图\n\n![官网扒下来的图](./SpringBoot日志基础/image-20240530151255937.png)\n\n除了`UnsynchronizedAppenderBase`，Appender的基本实现还有一个`AppenderBase`，这两者的区别看名字就能猜到\n\n```java\n//AppenderBase的实现，加上了同步字段synchronized\npublic synchronized void doAppend(E eventObject) {...}\n//`UnsynchronizedAppenderBase的实现\npublic void doAppend(E eventObject) {...}\n```\n\n#### Logger与Appender的关联\n\n```java\npublic final class Logger implements org.slf4j.Logger, LocationAwareLogger, AppenderAttachable<ILoggingEvent>, Serializable {\n    \n    private transient AppenderAttachableImpl<ILoggingEvent> aai;\n    \n    //日志打印方法经过层层处理，最终会调用这个方法\n     public int appendLoopOnAppenders(E e) {\n        int size = 0;\n        Appender<E>[] appenderArray = (Appender[])this.appenderList.asTypedArray();\n        int len = appenderArray.length;\n         //调用每个Appender执行doAppend方法\n        for(int i = 0; i < len; ++i) {\n            appenderArray[i].doAppend(e);\n            ++size;\n        }\n\n        return size;\n    }\n}\npublic class AppenderAttachableImpl<E> implements AppenderAttachable<E> {\n    //Appender的持有，COWArrayList是logback自定义的List\n    private final COWArrayList<Appender<E>> appenderList = new COWArrayList(new Appender[0]);\n}\n```\n\n### 2.3.3 信息的过滤以及处理\n\n#### filter\n\nFilter是用来决定附加器是否输出日志的，与Appender的关系如下\n\n```java\npublic abstract class UnsynchronizedAppenderBase<E> extends ContextAwareBase implements Appender<E> {\n    //存放Filter的属性 (有亿点点眼熟)\n\tprivate FilterAttachableImpl<E> fai = new FilterAttachableImpl();\n}\n```\n\n每个过滤器都会返回一个枚举值，枚举的值有：DENY、NEUTRAL、ACCEPT。\n\n附加器会根据过滤器的返回值来判断是否输出日志：\n\n- DENY：不输出日志\n- NEUTRAL：中立\n- ACCPET：输出日志\n\n多个过滤器的情况下，会以链式的方式进行过滤，当过滤器的返回值为 **DENY**、**ACCPET**时，会直接决定附加器是否打印日志；当过滤器返回值为 **NEUTRAL**时会执行判断下一个过滤器，直达出现返回值为 **DENY**、**ACCPET**或者没有过滤器结束，最后一个过滤器的返回值为 **NEUTRAL**也会打印日志\n\n#### encoder\n\nEncoders are responsible for transforming an incoming event into a byte array（官方原话，负责将需要打印的event转成字节数组）\n\n```java\npublic interface Encoder<E> extends ContextAware, LifeCycle {\n    byte[] headerBytes();\n\n    byte[] encode(E var1);\n\n    byte[] footerBytes();\n}\n```\n\n通俗的来说Encoder是用来将信息格式化输出的\n\n## 2.4 配置文件\n\n### 2.4.1 spring 配置文件\n\n先来看看Spring配置文件中能配置的属性（application的配置粒度不够细，并且不利于更换日志系统，所以项目一般不会直接在application中配置日志信息）\n\n```yaml\nlogging:\n  level:\n    #配置全部的调试级别\n    #root: trace\n    #配置具体包路径下的调试级别\n    com.example.springboot03: trace\n  pattern:\n    #默认控制台输出格式\n    console: '%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSSXXX}})'\n    dateformat: yyyy-MM-dd HH:mm:ss\n  file:\n    #设置文件名称，没有设置路径的话，默认在项目相对路径下生成 （name优先级 > path优先级）\n    name: F:/WorkSpaceSpringBoot/my.log\n    #不可以指定文件名称，必须指定物理文件夹路径，默认使用 spring.log 进行输出\n    #path: F:/WorkSpaceSpringBoot/\n  logback:\n    rolling policy:\n      #启动是否清空日志文件，默认false\n      clean-history-on-start: false\n      #保存文件的默认命名格式\n      file-name-pattern: '${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz'\n      #最大日志文件大小 日志文件多大归档一次(单位必须大写)\n      max-file-size: 2KB\n      # 日志保存天数\n      max-history: 7\n      # 日志保存总大小 超出就删除旧的文档,按时间先后删除 (0B就是没有限制)\n      total-size-cap: 4KB\n```\n\n### 2.4.2 logback配置文件(可以说是logback的核心了)\n\n文件名为\"logback-spring.xml\"\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration debug=\"false\">\n\n    <!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径-->\n    <property name=\"LOG_HOME\" value=\"/home\" />\n\n    <!--控制台日志， 控制台输出 -->\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度,%msg：日志消息，%n是换行符-->\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n    <!--文件日志， 按照每天生成日志文件 -->\n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <!--日志文件输出的文件名-->\n            <FileNamePattern>${LOG_HOME}/TestWeb.log.%d{yyyy-MM-dd}.log</FileNamePattern>\n            <!--日志文件保留天数-->\n            <MaxHistory>30</MaxHistory>\n        </rollingPolicy>\n        <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度，%msg：日志消息，%n是换行符-->\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n            <!-- 设置编码格式，以防中文乱码 -->\n            <charset class=\"java.nio.charset.Charset\">UTF-8</charset>\n        </encoder>\n        <!--日志文件最大的大小-->\n        <triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\">\n            <MaxFileSize>10MB</MaxFileSize>\n        </triggeringPolicy>\n    </appender>\n    \n    \n    <!--修改框架中的Logger-->\n    <logger name=\"com.apache.ibatis\" level=\"TRACE\"/>\n    <logger name=\"java.sql.Connection\" level=\"DEBUG\"/>\n    <logger name=\"java.sql.Statement\" level=\"DEBUG\"/>\n    <logger name=\"java.sql.PreparedStatement\" level=\"DEBUG\"/>\n\n    <!-- 修改root会修改所有的Logger,包括框架中的日志打印 -->\n    <root level=\"DEBUG\">\n        <appender-ref ref=\"STDOUT\" />\n        <appender-ref ref=\"FILE\"/>\n    </root>\n</configuration>\n```\n\n\n\n# 参考\n\n[Logback Manual](https://logback.qos.ch/manual/index.html)\n","source":"_posts/SpringBoot日志基础.md","raw":"---\ntitle: SpringBoot日志基础\ndate: 2024-09-03 16:09:34\ntags:\n  - SpringBoot\n  - 日志\ncategories:\n  - 后端开发 \n---\n\n文章主要介绍SpringBoot日志门面与系统，详细说明LogBack\n\n<!--more-->\n\n# 1.日志简述\n\n1. 现在大部分项目中使用的日志库可以分为**日志门面**和**日志库**（有点接口和实现类的感觉）\n2. 使用日志库和其它组件一样分为**配置**和**api的使用**\n\n## 1.1 日志门面\n\n### 1.1.1 common-logging\n\ncommon-logging 是 apache 的一个开源项目。也称Jakarta Commons Logging，缩写 JCL。\n\ncommon-logging 的功能是提供日志功能的 API 接口，本身并不提供日志的具体实现（当然，common-logging 内部有一个 Simple logger 的简单实现，但是功能很弱，直接忽略），而是在运行时动态的绑定日志实现组件来工作（如 log4j、java.util.loggin）。\n\n### 1.1.2 slf4j\n\n全称为 Simple Logging Facade for Java，即 java 简单日志门面。\n\nslf4j是项目中用的比较多的日志门户。类似于 Common-Logging，slf4j 是对不同日志框架提供的一个 API 封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。但是，slf4j 在编译时静态绑定真正的 Log 库。使用 SLF4J 时，如果你需要使用某一种日志实现，那么你必须选择正确的 SLF4J 的 jar 包的集合（各种桥接包）。\n\n## 1.2 日志系统\n\n### 1.2.1 不常用的日志系统\n\n1. **java.util.logging（JUL）**\n   官方提供的日志系统\n\n2. **Log4j**\n\n   Log4j 应该说是 Java 领域资格最老，应用最广的日志工具。Log4j 是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX 系统日志等。\n\n   Log4j 的短板在于性能，在Logback 和 Log4j2 出来之后，Log4j的使用也减少了。\n\n### 1.2.2 Logback\n\nLogback 是由 log4j 创始人 Ceki Gulcu 设计的又一个开源日志组件，是作为 Log4j 的继承者来开发的，提供了性能更好的实现，异步 logger，Filter等更多的特性。\n\nlogback 当前分成三个模块：logback-core、logback-classic 和 logback-access。\n\n+ logback-core - 是其它两个模块的基础模块。\n+ logback-classic - 是 log4j 的一个 改良版本。此外 logback-classic 完整实现 SLF4J API 使你可以很方便地更换成其它日志系统如 log4j 或 JDK14 Logging。\n+ logback-access - 访问模块与 Servlet 容器集成提供通过 Http 来访问日志的功能。\n\n官网地址: http://logback.qos.ch/\n\n### 1.2.3 Log4j2\n\n维护 Log4j 的人为了性能又搞出了 Log4j2。\n\nLog4j2 和 Log4j1.x 并不兼容，设计上很大程度上模仿了 SLF4J/Logback，性能上也获得了很大的提升。\n\nLog4j2 也做了 Facade/Implementation 分离的设计，分成了 log4j-api 和 log4j-core。\n\n\n\n# 2. logback\n\n[放个官方教程](https://logback.qos.ch/manual/index.html)\n\nlogback是由原来log4j1的团队编写的，成为了log4j1的替代品，是项目中使用较多的日志系统\n\n[官方给出使用logback而不是log4j1的原因](https://logback.qos.ch/reasonsToSwitch.html)\n\n## 2.1 依赖导入\n\nSpringBoot项目默认的日志实现就是logback，可以不导入任何依赖使用，如果不是Spring应用可以通过以下方式导入\n\n```xml\n<dependency>\n  <groupId>ch.qos.logback</groupId>\n  <artifactId>logback-classic</artifactId>\n  <version>1.5.6</version>\n</dependency>\n```\n\n项目中日志经常配合AOP使用，这里需要导入一下AOP的依赖\n\n```xml\n<!--aop的starter，也可以直接导入org.aspectj相关的包-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n## 2.2 简单使用\n\n```java\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\n//建议导入slf4j中的类，优先使用日志门面(阿里开发规范)\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n@Aspect\n@Component\npublic class WebLogAspect {\n    public static final Logger logger= LoggerFactory.getLogger(WebLogAspect.class);\n    //所有请求都会经过ServletRequest的service方法\n    @Around(\"execution(public void javax.servlet.http.HttpServlet.service(..)))\")\n    public Object log(ProceedingJoinPoint jp) throws Throwable {\n        Object[] args = jp.getArgs();\n        HttpServletRequest request = (HttpServletRequest) args[0];\n        HttpServletResponse response = (HttpServletResponse) args[1];\n         String url = request.getRequestURL().toString();\n        String method = request.getMethod();\n        long startTime = System.currentTimeMillis();\n        try{\n            jp.proceed(new Object[]{request,response});\n        }catch (Throwable e){\n            throw e;\n        }\n        long time = (System.currentTimeMillis() - startTime);\n        logger.info(\"请求路径为{},请求参数为{}\",url,method);\n        logger.info(\"响应状态码为{}\",response.getStatus());\n        logger.info(\"接口响应时间为{}ms\",time);\n        return null;\n    }\n}\n```\n\n这个切面会拦截所有请求，然后打印出请求的路径、参数，响应的状态码以及响应时间。AOP以及javaWeb的内容不是本文的重点，我们重点关注一下`Logger`\n\n现在问题来了，这个`Logger`到底是什么？从`WebLogAspect.class`中getLogger是什么意思？logger.info()又是什么方法？\n\n为了解答这些问题我们先来看看logback日志打印的一些组件（其实log4j1、logback、log4j2中组件都差不多，只是配置文件写法可能有点差异）\n\n## 2.3 组件说明\n\n### 2.3.1 Logger\n\nlogback中的记录器都会缓存在一个Map中（就像Spring缓存Bean那样），记录器Logger是有层级、有继承关系的（具体见LoggerContext）。\n\nLogback的Logger是slf4j中Logger的实现，下面是logback中Logger的实现以及Logger的一些属性\n\n```java\npackage ch.qos.logback.classic;\n\npublic final class Logger implements org.slf4j.Logger, LocationAwareLogger, AppenderAttachable<ILoggingEvent>, Serializable {\n    public static final String FQCN = Logger.class.getName();\n    private String name;\n    private transient Level level;\n    private transient int effectiveLevelInt;\n    private transient Logger parent;\n    private transient List<Logger> childrenList;\n    //持有Appender\n    private transient AppenderAttachableImpl<ILoggingEvent> aai;\n    private transient boolean additive = true;\n    final transient LoggerContext loggerContext;\n}\n```\n\n#### Logger中的属性\n\n- **name**：上面我们知道记录器是缓存在Map中的，这个**name**就是Map的**key**\n\n  `LoggerFactory.getLogger()`的入参有两个，**name** 和 **class**，传入class的时候，name就是类的全限定名\n\n- **Level**：我们知道日志是有级别的，比如上面调用的`info`，级别关系如下\n\n  **TRACE** < **DEBUG** < **INFO** < **WARN** < **ERROR** < **FATAL** < **OFF**\n\n  Logger中的Level表示这个Logger能支持打印的最低级别，默认是 **DEBUG**，当调用低于Level级别日志打印方法时会没有显示（可以把上面代码改成trace()方法试试）\n\n- **parent**与**childrenList**\n\n  用来维护Logger层级关系的属性，`getLogger()`时会先从Map里面拿，取不到的时候再创建，Logger创建时会检测有无父Logger，没有的话会创建父Logger，然后会检测父Logger有无父Logger，循环往上直到碰到顶级Logger（name为ROOT的Logger）。\n\n  **举例**：\n\n  ```java\n  //我项目中的类的全限定名是org.example.demo.aspect.WebLogAspect\n  public static final Logger logger= LoggerFactory.getLogger(WebLogAspect.class);\n  ```\n\n  那么创建的时候就会先检测是否有**name**为**\"WebLogAspect\"**的Logger，没有的话再检测是否有 **name**为 **aspect**的Logger，又没有的话会检测是否有 **name**为 **demo**的Logger ... 直到检测到没有 **name**为**org**的Logger ，**org的父类是 \"ROOT\"**，这时会根据ROOT中的属性来创建 **\"org\"**，根据 **\"org\"**创建 **\"example\"**直到 **\"WebLogAspect\"**被创建\n\n  系统默认的属性都会放在**\"ROOT\"**中，比如上面说的Level默认是DEBUG\n\n### 2.3.2 appender\n\nLogger会将输出日志的任务交给Appender（附加器）来完成，不同的Appender会将日志打印到不同的地方，比如控制台附加器、文件附加器、网络附加器\n\nLogback中的appender是一个接口，以下是官网扒下来的结构图\n\n![官网扒下来的图](./SpringBoot日志基础/image-20240530151255937.png)\n\n除了`UnsynchronizedAppenderBase`，Appender的基本实现还有一个`AppenderBase`，这两者的区别看名字就能猜到\n\n```java\n//AppenderBase的实现，加上了同步字段synchronized\npublic synchronized void doAppend(E eventObject) {...}\n//`UnsynchronizedAppenderBase的实现\npublic void doAppend(E eventObject) {...}\n```\n\n#### Logger与Appender的关联\n\n```java\npublic final class Logger implements org.slf4j.Logger, LocationAwareLogger, AppenderAttachable<ILoggingEvent>, Serializable {\n    \n    private transient AppenderAttachableImpl<ILoggingEvent> aai;\n    \n    //日志打印方法经过层层处理，最终会调用这个方法\n     public int appendLoopOnAppenders(E e) {\n        int size = 0;\n        Appender<E>[] appenderArray = (Appender[])this.appenderList.asTypedArray();\n        int len = appenderArray.length;\n         //调用每个Appender执行doAppend方法\n        for(int i = 0; i < len; ++i) {\n            appenderArray[i].doAppend(e);\n            ++size;\n        }\n\n        return size;\n    }\n}\npublic class AppenderAttachableImpl<E> implements AppenderAttachable<E> {\n    //Appender的持有，COWArrayList是logback自定义的List\n    private final COWArrayList<Appender<E>> appenderList = new COWArrayList(new Appender[0]);\n}\n```\n\n### 2.3.3 信息的过滤以及处理\n\n#### filter\n\nFilter是用来决定附加器是否输出日志的，与Appender的关系如下\n\n```java\npublic abstract class UnsynchronizedAppenderBase<E> extends ContextAwareBase implements Appender<E> {\n    //存放Filter的属性 (有亿点点眼熟)\n\tprivate FilterAttachableImpl<E> fai = new FilterAttachableImpl();\n}\n```\n\n每个过滤器都会返回一个枚举值，枚举的值有：DENY、NEUTRAL、ACCEPT。\n\n附加器会根据过滤器的返回值来判断是否输出日志：\n\n- DENY：不输出日志\n- NEUTRAL：中立\n- ACCPET：输出日志\n\n多个过滤器的情况下，会以链式的方式进行过滤，当过滤器的返回值为 **DENY**、**ACCPET**时，会直接决定附加器是否打印日志；当过滤器返回值为 **NEUTRAL**时会执行判断下一个过滤器，直达出现返回值为 **DENY**、**ACCPET**或者没有过滤器结束，最后一个过滤器的返回值为 **NEUTRAL**也会打印日志\n\n#### encoder\n\nEncoders are responsible for transforming an incoming event into a byte array（官方原话，负责将需要打印的event转成字节数组）\n\n```java\npublic interface Encoder<E> extends ContextAware, LifeCycle {\n    byte[] headerBytes();\n\n    byte[] encode(E var1);\n\n    byte[] footerBytes();\n}\n```\n\n通俗的来说Encoder是用来将信息格式化输出的\n\n## 2.4 配置文件\n\n### 2.4.1 spring 配置文件\n\n先来看看Spring配置文件中能配置的属性（application的配置粒度不够细，并且不利于更换日志系统，所以项目一般不会直接在application中配置日志信息）\n\n```yaml\nlogging:\n  level:\n    #配置全部的调试级别\n    #root: trace\n    #配置具体包路径下的调试级别\n    com.example.springboot03: trace\n  pattern:\n    #默认控制台输出格式\n    console: '%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSSXXX}})'\n    dateformat: yyyy-MM-dd HH:mm:ss\n  file:\n    #设置文件名称，没有设置路径的话，默认在项目相对路径下生成 （name优先级 > path优先级）\n    name: F:/WorkSpaceSpringBoot/my.log\n    #不可以指定文件名称，必须指定物理文件夹路径，默认使用 spring.log 进行输出\n    #path: F:/WorkSpaceSpringBoot/\n  logback:\n    rolling policy:\n      #启动是否清空日志文件，默认false\n      clean-history-on-start: false\n      #保存文件的默认命名格式\n      file-name-pattern: '${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz'\n      #最大日志文件大小 日志文件多大归档一次(单位必须大写)\n      max-file-size: 2KB\n      # 日志保存天数\n      max-history: 7\n      # 日志保存总大小 超出就删除旧的文档,按时间先后删除 (0B就是没有限制)\n      total-size-cap: 4KB\n```\n\n### 2.4.2 logback配置文件(可以说是logback的核心了)\n\n文件名为\"logback-spring.xml\"\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration debug=\"false\">\n\n    <!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径-->\n    <property name=\"LOG_HOME\" value=\"/home\" />\n\n    <!--控制台日志， 控制台输出 -->\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度,%msg：日志消息，%n是换行符-->\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n        </encoder>\n    </appender>\n\n    <!--文件日志， 按照每天生成日志文件 -->\n    <appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n            <!--日志文件输出的文件名-->\n            <FileNamePattern>${LOG_HOME}/TestWeb.log.%d{yyyy-MM-dd}.log</FileNamePattern>\n            <!--日志文件保留天数-->\n            <MaxHistory>30</MaxHistory>\n        </rollingPolicy>\n        <encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\">\n            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度，%msg：日志消息，%n是换行符-->\n            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>\n            <!-- 设置编码格式，以防中文乱码 -->\n            <charset class=\"java.nio.charset.Charset\">UTF-8</charset>\n        </encoder>\n        <!--日志文件最大的大小-->\n        <triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\">\n            <MaxFileSize>10MB</MaxFileSize>\n        </triggeringPolicy>\n    </appender>\n    \n    \n    <!--修改框架中的Logger-->\n    <logger name=\"com.apache.ibatis\" level=\"TRACE\"/>\n    <logger name=\"java.sql.Connection\" level=\"DEBUG\"/>\n    <logger name=\"java.sql.Statement\" level=\"DEBUG\"/>\n    <logger name=\"java.sql.PreparedStatement\" level=\"DEBUG\"/>\n\n    <!-- 修改root会修改所有的Logger,包括框架中的日志打印 -->\n    <root level=\"DEBUG\">\n        <appender-ref ref=\"STDOUT\" />\n        <appender-ref ref=\"FILE\"/>\n    </root>\n</configuration>\n```\n\n\n\n# 参考\n\n[Logback Manual](https://logback.qos.ch/manual/index.html)\n","slug":"SpringBoot日志基础","published":1,"updated":"2024-10-30T14:27:46.928Z","_id":"cm2vz0zei0000isushx4ebb8i","comments":1,"layout":"post","photos":[],"link":"","content":"<p>文章主要介绍SpringBoot日志门面与系统，详细说明LogBack</p>\n<span id=\"more\"></span>\n\n<h1 id=\"1-日志简述\"><a href=\"#1-日志简述\" class=\"headerlink\" title=\"1.日志简述\"></a>1.日志简述</h1><ol>\n<li>现在大部分项目中使用的日志库可以分为<strong>日志门面</strong>和<strong>日志库</strong>（有点接口和实现类的感觉）</li>\n<li>使用日志库和其它组件一样分为<strong>配置</strong>和<strong>api的使用</strong></li>\n</ol>\n<h2 id=\"1-1-日志门面\"><a href=\"#1-1-日志门面\" class=\"headerlink\" title=\"1.1 日志门面\"></a>1.1 日志门面</h2><h3 id=\"1-1-1-common-logging\"><a href=\"#1-1-1-common-logging\" class=\"headerlink\" title=\"1.1.1 common-logging\"></a>1.1.1 common-logging</h3><p>common-logging 是 apache 的一个开源项目。也称Jakarta Commons Logging，缩写 JCL。</p>\n<p>common-logging 的功能是提供日志功能的 API 接口，本身并不提供日志的具体实现（当然，common-logging 内部有一个 Simple logger 的简单实现，但是功能很弱，直接忽略），而是在运行时动态的绑定日志实现组件来工作（如 log4j、java.util.loggin）。</p>\n<h3 id=\"1-1-2-slf4j\"><a href=\"#1-1-2-slf4j\" class=\"headerlink\" title=\"1.1.2 slf4j\"></a>1.1.2 slf4j</h3><p>全称为 Simple Logging Facade for Java，即 java 简单日志门面。</p>\n<p>slf4j是项目中用的比较多的日志门户。类似于 Common-Logging，slf4j 是对不同日志框架提供的一个 API 封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。但是，slf4j 在编译时静态绑定真正的 Log 库。使用 SLF4J 时，如果你需要使用某一种日志实现，那么你必须选择正确的 SLF4J 的 jar 包的集合（各种桥接包）。</p>\n<h2 id=\"1-2-日志系统\"><a href=\"#1-2-日志系统\" class=\"headerlink\" title=\"1.2 日志系统\"></a>1.2 日志系统</h2><h3 id=\"1-2-1-不常用的日志系统\"><a href=\"#1-2-1-不常用的日志系统\" class=\"headerlink\" title=\"1.2.1 不常用的日志系统\"></a>1.2.1 不常用的日志系统</h3><ol>\n<li><p><strong>java.util.logging（JUL）</strong><br>官方提供的日志系统</p>\n</li>\n<li><p><strong>Log4j</strong></p>\n<p>Log4j 应该说是 Java 领域资格最老，应用最广的日志工具。Log4j 是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX 系统日志等。</p>\n<p>Log4j 的短板在于性能，在Logback 和 Log4j2 出来之后，Log4j的使用也减少了。</p>\n</li>\n</ol>\n<h3 id=\"1-2-2-Logback\"><a href=\"#1-2-2-Logback\" class=\"headerlink\" title=\"1.2.2 Logback\"></a>1.2.2 Logback</h3><p>Logback 是由 log4j 创始人 Ceki Gulcu 设计的又一个开源日志组件，是作为 Log4j 的继承者来开发的，提供了性能更好的实现，异步 logger，Filter等更多的特性。</p>\n<p>logback 当前分成三个模块：logback-core、logback-classic 和 logback-access。</p>\n<ul>\n<li>logback-core - 是其它两个模块的基础模块。</li>\n<li>logback-classic - 是 log4j 的一个 改良版本。此外 logback-classic 完整实现 SLF4J API 使你可以很方便地更换成其它日志系统如 log4j 或 JDK14 Logging。</li>\n<li>logback-access - 访问模块与 Servlet 容器集成提供通过 Http 来访问日志的功能。</li>\n</ul>\n<p>官网地址: <a href=\"http://logback.qos.ch/\">http://logback.qos.ch/</a></p>\n<h3 id=\"1-2-3-Log4j2\"><a href=\"#1-2-3-Log4j2\" class=\"headerlink\" title=\"1.2.3 Log4j2\"></a>1.2.3 Log4j2</h3><p>维护 Log4j 的人为了性能又搞出了 Log4j2。</p>\n<p>Log4j2 和 Log4j1.x 并不兼容，设计上很大程度上模仿了 SLF4J&#x2F;Logback，性能上也获得了很大的提升。</p>\n<p>Log4j2 也做了 Facade&#x2F;Implementation 分离的设计，分成了 log4j-api 和 log4j-core。</p>\n<h1 id=\"2-logback\"><a href=\"#2-logback\" class=\"headerlink\" title=\"2. logback\"></a>2. logback</h1><p><a href=\"https://logback.qos.ch/manual/index.html\">放个官方教程</a></p>\n<p>logback是由原来log4j1的团队编写的，成为了log4j1的替代品，是项目中使用较多的日志系统</p>\n<p><a href=\"https://logback.qos.ch/reasonsToSwitch.html\">官方给出使用logback而不是log4j1的原因</a></p>\n<h2 id=\"2-1-依赖导入\"><a href=\"#2-1-依赖导入\" class=\"headerlink\" title=\"2.1 依赖导入\"></a>2.1 依赖导入</h2><p>SpringBoot项目默认的日志实现就是logback，可以不导入任何依赖使用，如果不是Spring应用可以通过以下方式导入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>ch.qos.logback<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>logback-classic<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.5.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>项目中日志经常配合AOP使用，这里需要导入一下AOP的依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--aop的starter，也可以直接导入org.aspectj相关的包--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-简单使用\"><a href=\"#2-2-简单使用\" class=\"headerlink\" title=\"2.2 简单使用\"></a>2.2 简单使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Around;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=\"line\"><span class=\"comment\">//建议导入slf4j中的类，优先使用日志门面(阿里开发规范)</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebLogAspect</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger= LoggerFactory.getLogger(WebLogAspect.class);</span><br><span class=\"line\">    <span class=\"comment\">//所有请求都会经过ServletRequest的service方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(public void javax.servlet.http.HttpServlet.service(..)))</span><span class=\"string\">&quot;)</span></span><br><span class=\"line\"><span class=\"string\">    public Object log(ProceedingJoinPoint jp) throws Throwable &#123;</span></span><br><span class=\"line\"><span class=\"string\">        Object[] args = jp.getArgs();</span></span><br><span class=\"line\"><span class=\"string\">        HttpServletRequest request = (HttpServletRequest) args[0];</span></span><br><span class=\"line\"><span class=\"string\">        HttpServletResponse response = (HttpServletResponse) args[1];</span></span><br><span class=\"line\"><span class=\"string\">         String url = request.getRequestURL().toString();</span></span><br><span class=\"line\"><span class=\"string\">        String method = request.getMethod();</span></span><br><span class=\"line\"><span class=\"string\">        long startTime = System.currentTimeMillis();</span></span><br><span class=\"line\"><span class=\"string\">        try&#123;</span></span><br><span class=\"line\"><span class=\"string\">            jp.proceed(new Object[]&#123;request,response&#125;);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;catch (Throwable e)&#123;</span></span><br><span class=\"line\"><span class=\"string\">            throw e;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        long time = (System.currentTimeMillis() - startTime);</span></span><br><span class=\"line\"><span class=\"string\">        logger.info(&quot;</span>请求路径为&#123;&#125;,请求参数为&#123;&#125;<span class=\"string\">&quot;,url,method);</span></span><br><span class=\"line\"><span class=\"string\">        logger.info(&quot;</span>响应状态码为&#123;&#125;<span class=\"string\">&quot;,response.getStatus());</span></span><br><span class=\"line\"><span class=\"string\">        logger.info(&quot;</span>接口响应时间为&#123;&#125;ms<span class=\"string\">&quot;,time);</span></span><br><span class=\"line\"><span class=\"string\">        return null;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个切面会拦截所有请求，然后打印出请求的路径、参数，响应的状态码以及响应时间。AOP以及javaWeb的内容不是本文的重点，我们重点关注一下<code>Logger</code></p>\n<p>现在问题来了，这个<code>Logger</code>到底是什么？从<code>WebLogAspect.class</code>中getLogger是什么意思？logger.info()又是什么方法？</p>\n<p>为了解答这些问题我们先来看看logback日志打印的一些组件（其实log4j1、logback、log4j2中组件都差不多，只是配置文件写法可能有点差异）</p>\n<h2 id=\"2-3-组件说明\"><a href=\"#2-3-组件说明\" class=\"headerlink\" title=\"2.3 组件说明\"></a>2.3 组件说明</h2><h3 id=\"2-3-1-Logger\"><a href=\"#2-3-1-Logger\" class=\"headerlink\" title=\"2.3.1 Logger\"></a>2.3.1 Logger</h3><p>logback中的记录器都会缓存在一个Map中（就像Spring缓存Bean那样），记录器Logger是有层级、有继承关系的（具体见LoggerContext）。</p>\n<p>Logback的Logger是slf4j中Logger的实现，下面是logback中Logger的实现以及Logger的一些属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ch.qos.logback.classic;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">org</span>.slf4j.Logger, LocationAwareLogger, AppenderAttachable&lt;ILoggingEvent&gt;, Serializable &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">FQCN</span> <span class=\"operator\">=</span> Logger.class.getName();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Level level;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"type\">int</span> effectiveLevelInt;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Logger parent;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> List&lt;Logger&gt; childrenList;</span><br><span class=\"line\">    <span class=\"comment\">//持有Appender</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> AppenderAttachableImpl&lt;ILoggingEvent&gt; aai;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"type\">boolean</span> <span class=\"variable\">additive</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> LoggerContext loggerContext;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Logger中的属性\"><a href=\"#Logger中的属性\" class=\"headerlink\" title=\"Logger中的属性\"></a>Logger中的属性</h4><ul>\n<li><p><strong>name</strong>：上面我们知道记录器是缓存在Map中的，这个<strong>name</strong>就是Map的<strong>key</strong></p>\n<p><code>LoggerFactory.getLogger()</code>的入参有两个，<strong>name</strong> 和 <strong>class</strong>，传入class的时候，name就是类的全限定名</p>\n</li>\n<li><p><strong>Level</strong>：我们知道日志是有级别的，比如上面调用的<code>info</code>，级别关系如下</p>\n<p><strong>TRACE</strong> &lt; <strong>DEBUG</strong> &lt; <strong>INFO</strong> &lt; <strong>WARN</strong> &lt; <strong>ERROR</strong> &lt; <strong>FATAL</strong> &lt; <strong>OFF</strong></p>\n<p>Logger中的Level表示这个Logger能支持打印的最低级别，默认是 <strong>DEBUG</strong>，当调用低于Level级别日志打印方法时会没有显示（可以把上面代码改成trace()方法试试）</p>\n</li>\n<li><p><strong>parent</strong>与<strong>childrenList</strong></p>\n<p>用来维护Logger层级关系的属性，<code>getLogger()</code>时会先从Map里面拿，取不到的时候再创建，Logger创建时会检测有无父Logger，没有的话会创建父Logger，然后会检测父Logger有无父Logger，循环往上直到碰到顶级Logger（name为ROOT的Logger）。</p>\n<p><strong>举例</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我项目中的类的全限定名是org.example.demo.aspect.WebLogAspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger= LoggerFactory.getLogger(WebLogAspect.class);</span><br></pre></td></tr></table></figure>\n\n<p>那么创建的时候就会先检测是否有<strong>name</strong>为**”WebLogAspect”<strong>的Logger，没有的话再检测是否有 <strong>name</strong>为 <strong>aspect</strong>的Logger，又没有的话会检测是否有 <strong>name</strong>为 <strong>demo</strong>的Logger … 直到检测到没有 <strong>name</strong>为</strong>org<strong>的Logger ，</strong>org的父类是 “ROOT”**，这时会根据ROOT中的属性来创建 **”org”**，根据 **”org”**创建 **”example”**直到 **”WebLogAspect”**被创建</p>\n<p>系统默认的属性都会放在**”ROOT”**中，比如上面说的Level默认是DEBUG</p>\n</li>\n</ul>\n<h3 id=\"2-3-2-appender\"><a href=\"#2-3-2-appender\" class=\"headerlink\" title=\"2.3.2 appender\"></a>2.3.2 appender</h3><p>Logger会将输出日志的任务交给Appender（附加器）来完成，不同的Appender会将日志打印到不同的地方，比如控制台附加器、文件附加器、网络附加器</p>\n<p>Logback中的appender是一个接口，以下是官网扒下来的结构图</p>\n<p><img src=\"/2024/09/03/SpringBoot%E6%97%A5%E5%BF%97%E5%9F%BA%E7%A1%80/image-20240530151255937.png\" alt=\"官网扒下来的图\"></p>\n<p>除了<code>UnsynchronizedAppenderBase</code>，Appender的基本实现还有一个<code>AppenderBase</code>，这两者的区别看名字就能猜到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AppenderBase的实现，加上了同步字段synchronized</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doAppend</span><span class=\"params\">(E eventObject)</span> &#123;...&#125;</span><br><span class=\"line\"><span class=\"comment\">//`UnsynchronizedAppenderBase的实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doAppend</span><span class=\"params\">(E eventObject)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Logger与Appender的关联\"><a href=\"#Logger与Appender的关联\" class=\"headerlink\" title=\"Logger与Appender的关联\"></a>Logger与Appender的关联</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">org</span>.slf4j.Logger, LocationAwareLogger, AppenderAttachable&lt;ILoggingEvent&gt;, Serializable &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> AppenderAttachableImpl&lt;ILoggingEvent&gt; aai;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//日志打印方法经过层层处理，最终会调用这个方法</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">appendLoopOnAppenders</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Appender&lt;E&gt;[] appenderArray = (Appender[])<span class=\"built_in\">this</span>.appenderList.asTypedArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> appenderArray.length;</span><br><span class=\"line\">         <span class=\"comment\">//调用每个Appender执行doAppend方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">            appenderArray[i].doAppend(e);</span><br><span class=\"line\">            ++size;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppenderAttachableImpl</span>&lt;E&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">AppenderAttachable</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//Appender的持有，COWArrayList是logback自定义的List</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> COWArrayList&lt;Appender&lt;E&gt;&gt; appenderList = <span class=\"keyword\">new</span> <span class=\"title class_\">COWArrayList</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Appender</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-3-信息的过滤以及处理\"><a href=\"#2-3-3-信息的过滤以及处理\" class=\"headerlink\" title=\"2.3.3 信息的过滤以及处理\"></a>2.3.3 信息的过滤以及处理</h3><h4 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h4><p>Filter是用来决定附加器是否输出日志的，与Appender的关系如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UnsynchronizedAppenderBase</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">ContextAwareBase</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Appender</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//存放Filter的属性 (有亿点点眼熟)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> FilterAttachableImpl&lt;E&gt; fai = <span class=\"keyword\">new</span> <span class=\"title class_\">FilterAttachableImpl</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个过滤器都会返回一个枚举值，枚举的值有：DENY、NEUTRAL、ACCEPT。</p>\n<p>附加器会根据过滤器的返回值来判断是否输出日志：</p>\n<ul>\n<li>DENY：不输出日志</li>\n<li>NEUTRAL：中立</li>\n<li>ACCPET：输出日志</li>\n</ul>\n<p>多个过滤器的情况下，会以链式的方式进行过滤，当过滤器的返回值为 <strong>DENY</strong>、<strong>ACCPET</strong>时，会直接决定附加器是否打印日志；当过滤器返回值为 <strong>NEUTRAL</strong>时会执行判断下一个过滤器，直达出现返回值为 <strong>DENY</strong>、<strong>ACCPET</strong>或者没有过滤器结束，最后一个过滤器的返回值为 <strong>NEUTRAL</strong>也会打印日志</p>\n<h4 id=\"encoder\"><a href=\"#encoder\" class=\"headerlink\" title=\"encoder\"></a>encoder</h4><p>Encoders are responsible for transforming an incoming event into a byte array（官方原话，负责将需要打印的event转成字节数组）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Encoder</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">ContextAware</span>, LifeCycle &#123;</span><br><span class=\"line\">    <span class=\"type\">byte</span>[] headerBytes();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] encode(E var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] footerBytes();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通俗的来说Encoder是用来将信息格式化输出的</p>\n<h2 id=\"2-4-配置文件\"><a href=\"#2-4-配置文件\" class=\"headerlink\" title=\"2.4 配置文件\"></a>2.4 配置文件</h2><h3 id=\"2-4-1-spring-配置文件\"><a href=\"#2-4-1-spring-配置文件\" class=\"headerlink\" title=\"2.4.1 spring 配置文件\"></a>2.4.1 spring 配置文件</h3><p>先来看看Spring配置文件中能配置的属性（application的配置粒度不够细，并且不利于更换日志系统，所以项目一般不会直接在application中配置日志信息）</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">logging:</span></span><br><span class=\"line\">  <span class=\"attr\">level:</span></span><br><span class=\"line\">    <span class=\"comment\">#配置全部的调试级别</span></span><br><span class=\"line\">    <span class=\"comment\">#root: trace</span></span><br><span class=\"line\">    <span class=\"comment\">#配置具体包路径下的调试级别</span></span><br><span class=\"line\">    <span class=\"attr\">com.example.springboot03:</span> <span class=\"string\">trace</span></span><br><span class=\"line\">  <span class=\"attr\">pattern:</span></span><br><span class=\"line\">    <span class=\"comment\">#默认控制台输出格式</span></span><br><span class=\"line\">    <span class=\"attr\">console:</span> <span class=\"string\">&#x27;%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSSXXX&#125;&#125;)&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">dateformat:</span> <span class=\"string\">yyyy-MM-dd</span> <span class=\"string\">HH:mm:ss</span></span><br><span class=\"line\">  <span class=\"attr\">file:</span></span><br><span class=\"line\">    <span class=\"comment\">#设置文件名称，没有设置路径的话，默认在项目相对路径下生成 （name优先级 &gt; path优先级）</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">F:/WorkSpaceSpringBoot/my.log</span></span><br><span class=\"line\">    <span class=\"comment\">#不可以指定文件名称，必须指定物理文件夹路径，默认使用 spring.log 进行输出</span></span><br><span class=\"line\">    <span class=\"comment\">#path: F:/WorkSpaceSpringBoot/</span></span><br><span class=\"line\">  <span class=\"attr\">logback:</span></span><br><span class=\"line\">    <span class=\"attr\">rolling policy:</span></span><br><span class=\"line\">      <span class=\"comment\">#启动是否清空日志文件，默认false</span></span><br><span class=\"line\">      <span class=\"attr\">clean-history-on-start:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">      <span class=\"comment\">#保存文件的默认命名格式</span></span><br><span class=\"line\">      <span class=\"attr\">file-name-pattern:</span> <span class=\"string\">&#x27;$&#123;LOG_FILE&#125;.%d&#123;yyyy-MM-dd&#125;.%i.gz&#x27;</span></span><br><span class=\"line\">      <span class=\"comment\">#最大日志文件大小 日志文件多大归档一次(单位必须大写)</span></span><br><span class=\"line\">      <span class=\"attr\">max-file-size:</span> <span class=\"string\">2KB</span></span><br><span class=\"line\">      <span class=\"comment\"># 日志保存天数</span></span><br><span class=\"line\">      <span class=\"attr\">max-history:</span> <span class=\"number\">7</span></span><br><span class=\"line\">      <span class=\"comment\"># 日志保存总大小 超出就删除旧的文档,按时间先后删除 (0B就是没有限制)</span></span><br><span class=\"line\">      <span class=\"attr\">total-size-cap:</span> <span class=\"string\">4KB</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-2-logback配置文件-可以说是logback的核心了\"><a href=\"#2-4-2-logback配置文件-可以说是logback的核心了\" class=\"headerlink\" title=\"2.4.2 logback配置文件(可以说是logback的核心了)\"></a>2.4.2 logback配置文件(可以说是logback的核心了)</h3><p>文件名为”logback-spring.xml”</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;LOG_HOME&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/home&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--控制台日志， 控制台输出 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;STDOUT&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度,%msg：日志消息，%n是换行符--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--文件日志， 按照每天生成日志文件 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;FILE&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--日志文件输出的文件名--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log<span class=\"tag\">&lt;/<span class=\"name\">FileNamePattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--日志文件保留天数--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">MaxHistory</span>&gt;</span>30<span class=\"tag\">&lt;/<span class=\"name\">MaxHistory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度，%msg：日志消息，%n是换行符--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 设置编码格式，以防中文乱码 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">charset</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;java.nio.charset.Charset&quot;</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--日志文件最大的大小--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">triggeringPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">MaxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">MaxFileSize</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">triggeringPolicy</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!--修改框架中的Logger--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;com.apache.ibatis&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;TRACE&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;java.sql.Connection&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;java.sql.Statement&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;java.sql.PreparedStatement&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 修改root会修改所有的Logger,包括框架中的日志打印 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;FILE&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://logback.qos.ch/manual/index.html\">Logback Manual</a></p>\n","site":{"data":{}},"length":2833,"excerpt":"<p>文章主要介绍SpringBoot日志门面与系统，详细说明LogBack</p>","more":"<h1 id=\"1-日志简述\"><a href=\"#1-日志简述\" class=\"headerlink\" title=\"1.日志简述\"></a>1.日志简述</h1><ol>\n<li>现在大部分项目中使用的日志库可以分为<strong>日志门面</strong>和<strong>日志库</strong>（有点接口和实现类的感觉）</li>\n<li>使用日志库和其它组件一样分为<strong>配置</strong>和<strong>api的使用</strong></li>\n</ol>\n<h2 id=\"1-1-日志门面\"><a href=\"#1-1-日志门面\" class=\"headerlink\" title=\"1.1 日志门面\"></a>1.1 日志门面</h2><h3 id=\"1-1-1-common-logging\"><a href=\"#1-1-1-common-logging\" class=\"headerlink\" title=\"1.1.1 common-logging\"></a>1.1.1 common-logging</h3><p>common-logging 是 apache 的一个开源项目。也称Jakarta Commons Logging，缩写 JCL。</p>\n<p>common-logging 的功能是提供日志功能的 API 接口，本身并不提供日志的具体实现（当然，common-logging 内部有一个 Simple logger 的简单实现，但是功能很弱，直接忽略），而是在运行时动态的绑定日志实现组件来工作（如 log4j、java.util.loggin）。</p>\n<h3 id=\"1-1-2-slf4j\"><a href=\"#1-1-2-slf4j\" class=\"headerlink\" title=\"1.1.2 slf4j\"></a>1.1.2 slf4j</h3><p>全称为 Simple Logging Facade for Java，即 java 简单日志门面。</p>\n<p>slf4j是项目中用的比较多的日志门户。类似于 Common-Logging，slf4j 是对不同日志框架提供的一个 API 封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案。但是，slf4j 在编译时静态绑定真正的 Log 库。使用 SLF4J 时，如果你需要使用某一种日志实现，那么你必须选择正确的 SLF4J 的 jar 包的集合（各种桥接包）。</p>\n<h2 id=\"1-2-日志系统\"><a href=\"#1-2-日志系统\" class=\"headerlink\" title=\"1.2 日志系统\"></a>1.2 日志系统</h2><h3 id=\"1-2-1-不常用的日志系统\"><a href=\"#1-2-1-不常用的日志系统\" class=\"headerlink\" title=\"1.2.1 不常用的日志系统\"></a>1.2.1 不常用的日志系统</h3><ol>\n<li><p><strong>java.util.logging（JUL）</strong><br>官方提供的日志系统</p>\n</li>\n<li><p><strong>Log4j</strong></p>\n<p>Log4j 应该说是 Java 领域资格最老，应用最广的日志工具。Log4j 是高度可配置的，并可通过在运行时的外部文件配置。它根据记录的优先级别，并提供机制，以指示记录信息到许多的目的地，诸如：数据库，文件，控制台，UNIX 系统日志等。</p>\n<p>Log4j 的短板在于性能，在Logback 和 Log4j2 出来之后，Log4j的使用也减少了。</p>\n</li>\n</ol>\n<h3 id=\"1-2-2-Logback\"><a href=\"#1-2-2-Logback\" class=\"headerlink\" title=\"1.2.2 Logback\"></a>1.2.2 Logback</h3><p>Logback 是由 log4j 创始人 Ceki Gulcu 设计的又一个开源日志组件，是作为 Log4j 的继承者来开发的，提供了性能更好的实现，异步 logger，Filter等更多的特性。</p>\n<p>logback 当前分成三个模块：logback-core、logback-classic 和 logback-access。</p>\n<ul>\n<li>logback-core - 是其它两个模块的基础模块。</li>\n<li>logback-classic - 是 log4j 的一个 改良版本。此外 logback-classic 完整实现 SLF4J API 使你可以很方便地更换成其它日志系统如 log4j 或 JDK14 Logging。</li>\n<li>logback-access - 访问模块与 Servlet 容器集成提供通过 Http 来访问日志的功能。</li>\n</ul>\n<p>官网地址: <a href=\"http://logback.qos.ch/\">http://logback.qos.ch/</a></p>\n<h3 id=\"1-2-3-Log4j2\"><a href=\"#1-2-3-Log4j2\" class=\"headerlink\" title=\"1.2.3 Log4j2\"></a>1.2.3 Log4j2</h3><p>维护 Log4j 的人为了性能又搞出了 Log4j2。</p>\n<p>Log4j2 和 Log4j1.x 并不兼容，设计上很大程度上模仿了 SLF4J&#x2F;Logback，性能上也获得了很大的提升。</p>\n<p>Log4j2 也做了 Facade&#x2F;Implementation 分离的设计，分成了 log4j-api 和 log4j-core。</p>\n<h1 id=\"2-logback\"><a href=\"#2-logback\" class=\"headerlink\" title=\"2. logback\"></a>2. logback</h1><p><a href=\"https://logback.qos.ch/manual/index.html\">放个官方教程</a></p>\n<p>logback是由原来log4j1的团队编写的，成为了log4j1的替代品，是项目中使用较多的日志系统</p>\n<p><a href=\"https://logback.qos.ch/reasonsToSwitch.html\">官方给出使用logback而不是log4j1的原因</a></p>\n<h2 id=\"2-1-依赖导入\"><a href=\"#2-1-依赖导入\" class=\"headerlink\" title=\"2.1 依赖导入\"></a>2.1 依赖导入</h2><p>SpringBoot项目默认的日志实现就是logback，可以不导入任何依赖使用，如果不是Spring应用可以通过以下方式导入</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>ch.qos.logback<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>logback-classic<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.5.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>项目中日志经常配合AOP使用，这里需要导入一下AOP的依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--aop的starter，也可以直接导入org.aspectj相关的包--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-简单使用\"><a href=\"#2-2-简单使用\" class=\"headerlink\" title=\"2.2 简单使用\"></a>2.2 简单使用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Around;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=\"line\"><span class=\"comment\">//建议导入slf4j中的类，优先使用日志门面(阿里开发规范)</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WebLogAspect</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger= LoggerFactory.getLogger(WebLogAspect.class);</span><br><span class=\"line\">    <span class=\"comment\">//所有请求都会经过ServletRequest的service方法</span></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(public void javax.servlet.http.HttpServlet.service(..)))</span><span class=\"string\">&quot;)</span></span><br><span class=\"line\"><span class=\"string\">    public Object log(ProceedingJoinPoint jp) throws Throwable &#123;</span></span><br><span class=\"line\"><span class=\"string\">        Object[] args = jp.getArgs();</span></span><br><span class=\"line\"><span class=\"string\">        HttpServletRequest request = (HttpServletRequest) args[0];</span></span><br><span class=\"line\"><span class=\"string\">        HttpServletResponse response = (HttpServletResponse) args[1];</span></span><br><span class=\"line\"><span class=\"string\">         String url = request.getRequestURL().toString();</span></span><br><span class=\"line\"><span class=\"string\">        String method = request.getMethod();</span></span><br><span class=\"line\"><span class=\"string\">        long startTime = System.currentTimeMillis();</span></span><br><span class=\"line\"><span class=\"string\">        try&#123;</span></span><br><span class=\"line\"><span class=\"string\">            jp.proceed(new Object[]&#123;request,response&#125;);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;catch (Throwable e)&#123;</span></span><br><span class=\"line\"><span class=\"string\">            throw e;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        long time = (System.currentTimeMillis() - startTime);</span></span><br><span class=\"line\"><span class=\"string\">        logger.info(&quot;</span>请求路径为&#123;&#125;,请求参数为&#123;&#125;<span class=\"string\">&quot;,url,method);</span></span><br><span class=\"line\"><span class=\"string\">        logger.info(&quot;</span>响应状态码为&#123;&#125;<span class=\"string\">&quot;,response.getStatus());</span></span><br><span class=\"line\"><span class=\"string\">        logger.info(&quot;</span>接口响应时间为&#123;&#125;ms<span class=\"string\">&quot;,time);</span></span><br><span class=\"line\"><span class=\"string\">        return null;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个切面会拦截所有请求，然后打印出请求的路径、参数，响应的状态码以及响应时间。AOP以及javaWeb的内容不是本文的重点，我们重点关注一下<code>Logger</code></p>\n<p>现在问题来了，这个<code>Logger</code>到底是什么？从<code>WebLogAspect.class</code>中getLogger是什么意思？logger.info()又是什么方法？</p>\n<p>为了解答这些问题我们先来看看logback日志打印的一些组件（其实log4j1、logback、log4j2中组件都差不多，只是配置文件写法可能有点差异）</p>\n<h2 id=\"2-3-组件说明\"><a href=\"#2-3-组件说明\" class=\"headerlink\" title=\"2.3 组件说明\"></a>2.3 组件说明</h2><h3 id=\"2-3-1-Logger\"><a href=\"#2-3-1-Logger\" class=\"headerlink\" title=\"2.3.1 Logger\"></a>2.3.1 Logger</h3><p>logback中的记录器都会缓存在一个Map中（就像Spring缓存Bean那样），记录器Logger是有层级、有继承关系的（具体见LoggerContext）。</p>\n<p>Logback的Logger是slf4j中Logger的实现，下面是logback中Logger的实现以及Logger的一些属性</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ch.qos.logback.classic;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">org</span>.slf4j.Logger, LocationAwareLogger, AppenderAttachable&lt;ILoggingEvent&gt;, Serializable &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">FQCN</span> <span class=\"operator\">=</span> Logger.class.getName();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Level level;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"type\">int</span> effectiveLevelInt;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Logger parent;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> List&lt;Logger&gt; childrenList;</span><br><span class=\"line\">    <span class=\"comment\">//持有Appender</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> AppenderAttachableImpl&lt;ILoggingEvent&gt; aai;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"type\">boolean</span> <span class=\"variable\">additive</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> LoggerContext loggerContext;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Logger中的属性\"><a href=\"#Logger中的属性\" class=\"headerlink\" title=\"Logger中的属性\"></a>Logger中的属性</h4><ul>\n<li><p><strong>name</strong>：上面我们知道记录器是缓存在Map中的，这个<strong>name</strong>就是Map的<strong>key</strong></p>\n<p><code>LoggerFactory.getLogger()</code>的入参有两个，<strong>name</strong> 和 <strong>class</strong>，传入class的时候，name就是类的全限定名</p>\n</li>\n<li><p><strong>Level</strong>：我们知道日志是有级别的，比如上面调用的<code>info</code>，级别关系如下</p>\n<p><strong>TRACE</strong> &lt; <strong>DEBUG</strong> &lt; <strong>INFO</strong> &lt; <strong>WARN</strong> &lt; <strong>ERROR</strong> &lt; <strong>FATAL</strong> &lt; <strong>OFF</strong></p>\n<p>Logger中的Level表示这个Logger能支持打印的最低级别，默认是 <strong>DEBUG</strong>，当调用低于Level级别日志打印方法时会没有显示（可以把上面代码改成trace()方法试试）</p>\n</li>\n<li><p><strong>parent</strong>与<strong>childrenList</strong></p>\n<p>用来维护Logger层级关系的属性，<code>getLogger()</code>时会先从Map里面拿，取不到的时候再创建，Logger创建时会检测有无父Logger，没有的话会创建父Logger，然后会检测父Logger有无父Logger，循环往上直到碰到顶级Logger（name为ROOT的Logger）。</p>\n<p><strong>举例</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我项目中的类的全限定名是org.example.demo.aspect.WebLogAspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger= LoggerFactory.getLogger(WebLogAspect.class);</span><br></pre></td></tr></table></figure>\n\n<p>那么创建的时候就会先检测是否有<strong>name</strong>为**”WebLogAspect”<strong>的Logger，没有的话再检测是否有 <strong>name</strong>为 <strong>aspect</strong>的Logger，又没有的话会检测是否有 <strong>name</strong>为 <strong>demo</strong>的Logger … 直到检测到没有 <strong>name</strong>为</strong>org<strong>的Logger ，</strong>org的父类是 “ROOT”**，这时会根据ROOT中的属性来创建 **”org”**，根据 **”org”**创建 **”example”**直到 **”WebLogAspect”**被创建</p>\n<p>系统默认的属性都会放在**”ROOT”**中，比如上面说的Level默认是DEBUG</p>\n</li>\n</ul>\n<h3 id=\"2-3-2-appender\"><a href=\"#2-3-2-appender\" class=\"headerlink\" title=\"2.3.2 appender\"></a>2.3.2 appender</h3><p>Logger会将输出日志的任务交给Appender（附加器）来完成，不同的Appender会将日志打印到不同的地方，比如控制台附加器、文件附加器、网络附加器</p>\n<p>Logback中的appender是一个接口，以下是官网扒下来的结构图</p>\n<p><img src=\"/2024/09/03/SpringBoot%E6%97%A5%E5%BF%97%E5%9F%BA%E7%A1%80/image-20240530151255937.png\" alt=\"官网扒下来的图\"></p>\n<p>除了<code>UnsynchronizedAppenderBase</code>，Appender的基本实现还有一个<code>AppenderBase</code>，这两者的区别看名字就能猜到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AppenderBase的实现，加上了同步字段synchronized</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doAppend</span><span class=\"params\">(E eventObject)</span> &#123;...&#125;</span><br><span class=\"line\"><span class=\"comment\">//`UnsynchronizedAppenderBase的实现</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doAppend</span><span class=\"params\">(E eventObject)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Logger与Appender的关联\"><a href=\"#Logger与Appender的关联\" class=\"headerlink\" title=\"Logger与Appender的关联\"></a>Logger与Appender的关联</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Logger</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">org</span>.slf4j.Logger, LocationAwareLogger, AppenderAttachable&lt;ILoggingEvent&gt;, Serializable &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> AppenderAttachableImpl&lt;ILoggingEvent&gt; aai;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//日志打印方法经过层层处理，最终会调用这个方法</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">appendLoopOnAppenders</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Appender&lt;E&gt;[] appenderArray = (Appender[])<span class=\"built_in\">this</span>.appenderList.asTypedArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> appenderArray.length;</span><br><span class=\"line\">         <span class=\"comment\">//调用每个Appender执行doAppend方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; ++i) &#123;</span><br><span class=\"line\">            appenderArray[i].doAppend(e);</span><br><span class=\"line\">            ++size;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppenderAttachableImpl</span>&lt;E&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">AppenderAttachable</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//Appender的持有，COWArrayList是logback自定义的List</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> COWArrayList&lt;Appender&lt;E&gt;&gt; appenderList = <span class=\"keyword\">new</span> <span class=\"title class_\">COWArrayList</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">Appender</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-3-信息的过滤以及处理\"><a href=\"#2-3-3-信息的过滤以及处理\" class=\"headerlink\" title=\"2.3.3 信息的过滤以及处理\"></a>2.3.3 信息的过滤以及处理</h3><h4 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h4><p>Filter是用来决定附加器是否输出日志的，与Appender的关系如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UnsynchronizedAppenderBase</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">ContextAwareBase</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Appender</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//存放Filter的属性 (有亿点点眼熟)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> FilterAttachableImpl&lt;E&gt; fai = <span class=\"keyword\">new</span> <span class=\"title class_\">FilterAttachableImpl</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个过滤器都会返回一个枚举值，枚举的值有：DENY、NEUTRAL、ACCEPT。</p>\n<p>附加器会根据过滤器的返回值来判断是否输出日志：</p>\n<ul>\n<li>DENY：不输出日志</li>\n<li>NEUTRAL：中立</li>\n<li>ACCPET：输出日志</li>\n</ul>\n<p>多个过滤器的情况下，会以链式的方式进行过滤，当过滤器的返回值为 <strong>DENY</strong>、<strong>ACCPET</strong>时，会直接决定附加器是否打印日志；当过滤器返回值为 <strong>NEUTRAL</strong>时会执行判断下一个过滤器，直达出现返回值为 <strong>DENY</strong>、<strong>ACCPET</strong>或者没有过滤器结束，最后一个过滤器的返回值为 <strong>NEUTRAL</strong>也会打印日志</p>\n<h4 id=\"encoder\"><a href=\"#encoder\" class=\"headerlink\" title=\"encoder\"></a>encoder</h4><p>Encoders are responsible for transforming an incoming event into a byte array（官方原话，负责将需要打印的event转成字节数组）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Encoder</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">ContextAware</span>, LifeCycle &#123;</span><br><span class=\"line\">    <span class=\"type\">byte</span>[] headerBytes();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] encode(E var1);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">byte</span>[] footerBytes();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通俗的来说Encoder是用来将信息格式化输出的</p>\n<h2 id=\"2-4-配置文件\"><a href=\"#2-4-配置文件\" class=\"headerlink\" title=\"2.4 配置文件\"></a>2.4 配置文件</h2><h3 id=\"2-4-1-spring-配置文件\"><a href=\"#2-4-1-spring-配置文件\" class=\"headerlink\" title=\"2.4.1 spring 配置文件\"></a>2.4.1 spring 配置文件</h3><p>先来看看Spring配置文件中能配置的属性（application的配置粒度不够细，并且不利于更换日志系统，所以项目一般不会直接在application中配置日志信息）</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">logging:</span></span><br><span class=\"line\">  <span class=\"attr\">level:</span></span><br><span class=\"line\">    <span class=\"comment\">#配置全部的调试级别</span></span><br><span class=\"line\">    <span class=\"comment\">#root: trace</span></span><br><span class=\"line\">    <span class=\"comment\">#配置具体包路径下的调试级别</span></span><br><span class=\"line\">    <span class=\"attr\">com.example.springboot03:</span> <span class=\"string\">trace</span></span><br><span class=\"line\">  <span class=\"attr\">pattern:</span></span><br><span class=\"line\">    <span class=\"comment\">#默认控制台输出格式</span></span><br><span class=\"line\">    <span class=\"attr\">console:</span> <span class=\"string\">&#x27;%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSSXXX&#125;&#125;)&#x27;</span></span><br><span class=\"line\">    <span class=\"attr\">dateformat:</span> <span class=\"string\">yyyy-MM-dd</span> <span class=\"string\">HH:mm:ss</span></span><br><span class=\"line\">  <span class=\"attr\">file:</span></span><br><span class=\"line\">    <span class=\"comment\">#设置文件名称，没有设置路径的话，默认在项目相对路径下生成 （name优先级 &gt; path优先级）</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">F:/WorkSpaceSpringBoot/my.log</span></span><br><span class=\"line\">    <span class=\"comment\">#不可以指定文件名称，必须指定物理文件夹路径，默认使用 spring.log 进行输出</span></span><br><span class=\"line\">    <span class=\"comment\">#path: F:/WorkSpaceSpringBoot/</span></span><br><span class=\"line\">  <span class=\"attr\">logback:</span></span><br><span class=\"line\">    <span class=\"attr\">rolling policy:</span></span><br><span class=\"line\">      <span class=\"comment\">#启动是否清空日志文件，默认false</span></span><br><span class=\"line\">      <span class=\"attr\">clean-history-on-start:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">      <span class=\"comment\">#保存文件的默认命名格式</span></span><br><span class=\"line\">      <span class=\"attr\">file-name-pattern:</span> <span class=\"string\">&#x27;$&#123;LOG_FILE&#125;.%d&#123;yyyy-MM-dd&#125;.%i.gz&#x27;</span></span><br><span class=\"line\">      <span class=\"comment\">#最大日志文件大小 日志文件多大归档一次(单位必须大写)</span></span><br><span class=\"line\">      <span class=\"attr\">max-file-size:</span> <span class=\"string\">2KB</span></span><br><span class=\"line\">      <span class=\"comment\"># 日志保存天数</span></span><br><span class=\"line\">      <span class=\"attr\">max-history:</span> <span class=\"number\">7</span></span><br><span class=\"line\">      <span class=\"comment\"># 日志保存总大小 超出就删除旧的文档,按时间先后删除 (0B就是没有限制)</span></span><br><span class=\"line\">      <span class=\"attr\">total-size-cap:</span> <span class=\"string\">4KB</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-2-logback配置文件-可以说是logback的核心了\"><a href=\"#2-4-2-logback配置文件-可以说是logback的核心了\" class=\"headerlink\" title=\"2.4.2 logback配置文件(可以说是logback的核心了)\"></a>2.4.2 logback配置文件(可以说是logback的核心了)</h3><p>文件名为”logback-spring.xml”</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;LOG_HOME&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/home&quot;</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--控制台日志， 控制台输出 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;STDOUT&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度,%msg：日志消息，%n是换行符--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--文件日志， 按照每天生成日志文件 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;FILE&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--日志文件输出的文件名--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">FileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/TestWeb.log.%d&#123;yyyy-MM-dd&#125;.log<span class=\"tag\">&lt;/<span class=\"name\">FileNamePattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--日志文件保留天数--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">MaxHistory</span>&gt;</span>30<span class=\"tag\">&lt;/<span class=\"name\">MaxHistory</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度，%msg：日志消息，%n是换行符--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 设置编码格式，以防中文乱码 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">charset</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;java.nio.charset.Charset&quot;</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--日志文件最大的大小--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">triggeringPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">MaxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">MaxFileSize</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">triggeringPolicy</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!--修改框架中的Logger--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;com.apache.ibatis&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;TRACE&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;java.sql.Connection&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;java.sql.Statement&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;java.sql.PreparedStatement&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 修改root会修改所有的Logger,包括框架中的日志打印 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;FILE&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://logback.qos.ch/manual/index.html\">Logback Manual</a></p>"}],"PostAsset":[{"_id":"source/_posts/SpringBoot参数校验/image-20240602190311638.png","slug":"image-20240602190311638.png","post":"cm2vyo6bj0008skusexl99vng","modified":0,"renderable":0},{"_id":"source/_posts/Spring自动装配原理/模块装配二.png","slug":"模块装配二.png","post":"cm2vyo6bk0009skus91unbx5v","modified":0,"renderable":0},{"_id":"source/_posts/Spring自动装配原理/模块装配方式一.png","slug":"模块装配方式一.png","post":"cm2vyo6bk0009skus91unbx5v","modified":0,"renderable":0},{"_id":"source/_posts/id生成/雪花算法.webp","slug":"雪花算法.webp","post":"cm2vyo6bm000eskusgntfbn1m","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/1492928105791_3.png","slug":"1492928105791_3.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/image-20240225220137926.png","slug":"image-20240225220137926.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/image-20240226191911489.png","slug":"image-20240226191911489.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/image-20240226193441574.png","slug":"image-20240226193441574.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/java-io-model-0.png","slug":"java-io-model-0.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/java-io-model-1.png","slug":"java-io-model-1.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/java-io-model-2.png","slug":"java-io-model-2.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/java-io-model-3.png","slug":"java-io-model-3.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/java-io-model-4.png","slug":"java-io-model-4.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/java-io-overview2.png","slug":"java-io-overview2.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/java-io-reactor-1.png","slug":"java-io-reactor-1.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/java-io-reactor-4.png","slug":"java-io-reactor-4.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java_IO/JavaNIOBuffer.png","slug":"JavaNIOBuffer.png","post":"cm2vyo6bn000iskusbj7mabew","modified":0,"renderable":0},{"_id":"source/_posts/java两锁之一的synchronized/image-20240513145730228.png","slug":"image-20240513145730228.png","post":"cm2vyo6bp000oskus0e1q660q","modified":0,"renderable":0},{"_id":"source/_posts/java两锁之一的synchronized/image-20240513150908609.png","slug":"image-20240513150908609.png","post":"cm2vyo6bp000oskus0e1q660q","modified":0,"renderable":0},{"_id":"source/_posts/java两锁之一的synchronized/java重量级锁.webp","slug":"java重量级锁.webp","post":"cm2vyo6bp000oskus0e1q660q","modified":0,"renderable":0},{"_id":"source/_posts/java两锁之一的synchronized/jvm_markWord.png","slug":"jvm_markWord.png","post":"cm2vyo6bp000oskus0e1q660q","modified":0,"renderable":0},{"_id":"source/_posts/jvm/82a369cjhi.jpeg","slug":"82a369cjhi.jpeg","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231116194904286.png","slug":"image-20231116194904286.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231116200128095.png","slug":"image-20231116200128095.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231116202440545.png","slug":"image-20231116202440545.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231116202718426.png","slug":"image-20231116202718426.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231116203451353.png","slug":"image-20231116203451353.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231116204902025.png","slug":"image-20231116204902025.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231117160926362.png","slug":"image-20231117160926362.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231127105115660.png","slug":"image-20231127105115660.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231201151500158.png","slug":"image-20231201151500158.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231201151606407.png","slug":"image-20231201151606407.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231201151745264.png","slug":"image-20231201151745264.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231205215113256.png","slug":"image-20231205215113256.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231205215707315.png","slug":"image-20231205215707315.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231206112755092.png","slug":"image-20231206112755092.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231214111741606.png","slug":"image-20231214111741606.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231214193447991.png","slug":"image-20231214193447991.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231214194507254.png","slug":"image-20231214194507254.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231214195613362.png","slug":"image-20231214195613362.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231214221246377.png","slug":"image-20231214221246377.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231217221608733.png","slug":"image-20231217221608733.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20231217221643907.png","slug":"image-20231217221643907.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/jvm/image-20240326163359886.png","slug":"image-20240326163359886.png","post":"cm2vyo6br000uskus8ei7291y","modified":0,"renderable":0},{"_id":"source/_posts/SpringBoot日志基础/image-20240530151255937.png","slug":"image-20240530151255937.png","post":"cm2vz0zei0000isushx4ebb8i","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cm2vyo6bj0008skusexl99vng","category_id":"cm2vyo6bh0004skushbwx17zg","_id":"cm2vyo6bn000fskusgyos7z4l"},{"post_id":"cm2vyo6bc0001skus6dl9acmp","category_id":"cm2vyo6bh0004skushbwx17zg","_id":"cm2vyo6bo000jskus6i699p2b"},{"post_id":"cm2vyo6bk0009skus91unbx5v","category_id":"cm2vyo6bh0004skushbwx17zg","_id":"cm2vyo6bp000mskus6gandoby"},{"post_id":"cm2vyo6bl000dskus4xih45xn","category_id":"cm2vyo6bh0004skushbwx17zg","_id":"cm2vyo6bq000pskusabkk7dgc"},{"post_id":"cm2vyo6bg0003skus6nt9fcxq","category_id":"cm2vyo6bl000askusel27eoii","_id":"cm2vyo6bq000sskuscwux8yfx"},{"post_id":"cm2vyo6bm000eskusgntfbn1m","category_id":"cm2vyo6bh0004skushbwx17zg","_id":"cm2vyo6br000vskus1jvt5qbr"},{"post_id":"cm2vyo6bn000iskusbj7mabew","category_id":"cm2vyo6bh0004skushbwx17zg","_id":"cm2vyo6bs000xskus9q5ggj6z"},{"post_id":"cm2vyo6bj0007skusfo93bthh","category_id":"cm2vyo6bh0004skushbwx17zg","_id":"cm2vyo6bs000zskusavone9an"},{"post_id":"cm2vyo6bo000lskuse0vr00hg","category_id":"cm2vyo6bh0004skushbwx17zg","_id":"cm2vyo6bs0011skus8auo63pm"},{"post_id":"cm2vyo6bp000oskus0e1q660q","category_id":"cm2vyo6bh0004skushbwx17zg","_id":"cm2vyo6bs0013skus87etciaa"},{"post_id":"cm2vyo6bq000rskus1cyl23un","category_id":"cm2vyo6bl000askusel27eoii","_id":"cm2vyo6bs0015skus7kf45t1d"},{"post_id":"cm2vyo6br000uskus8ei7291y","category_id":"cm2vyo6bh0004skushbwx17zg","_id":"cm2vyo6bs0016skusdst104in"},{"post_id":"cm2vyo6bw001iskusax41absa","category_id":"cm2vyo6bw001jskus0i18h5lv","_id":"cm2vyo6bx001mskus9mae6zjy"},{"post_id":"cm2vz0zei0000isushx4ebb8i","category_id":"cm2vyo6bh0004skushbwx17zg","_id":"cm2vz0zek0002isushuyy2vef"}],"PostTag":[{"post_id":"cm2vyo6bc0001skus6dl9acmp","tag_id":"cm2vyo6bi0005skus4ntc6c4v","_id":"cm2vyo6bl000cskus7u2x674z"},{"post_id":"cm2vyo6bg0003skus6nt9fcxq","tag_id":"cm2vyo6bl000bskusdcv7hvi6","_id":"cm2vyo6bo000kskus27zv8j98"},{"post_id":"cm2vyo6bj0007skusfo93bthh","tag_id":"cm2vyo6bn000hskus335d5xpp","_id":"cm2vyo6bq000qskusegm7avip"},{"post_id":"cm2vyo6bj0008skusexl99vng","tag_id":"cm2vyo6bn000hskus335d5xpp","_id":"cm2vyo6br000wskus9pun129h"},{"post_id":"cm2vyo6bk0009skus91unbx5v","tag_id":"cm2vyo6bn000hskus335d5xpp","_id":"cm2vyo6bs0010skus3xgzfufr"},{"post_id":"cm2vyo6bl000dskus4xih45xn","tag_id":"cm2vyo6bs000yskus653u3tmm","_id":"cm2vyo6bs0014skus4on51tq2"},{"post_id":"cm2vyo6bm000eskusgntfbn1m","tag_id":"cm2vyo6bs0012skushdxv7z6a","_id":"cm2vyo6bt0018skuscqgl1ykq"},{"post_id":"cm2vyo6bn000iskusbj7mabew","tag_id":"cm2vyo6bs0017skuseagzh6tk","_id":"cm2vyo6bt001askus508yhu2b"},{"post_id":"cm2vyo6bo000lskuse0vr00hg","tag_id":"cm2vyo6bt0019skusghow8y6i","_id":"cm2vyo6bt001cskus3fjn4s4o"},{"post_id":"cm2vyo6bp000oskus0e1q660q","tag_id":"cm2vyo6bt0019skusghow8y6i","_id":"cm2vyo6bt001eskusbrdz9nww"},{"post_id":"cm2vyo6bq000rskus1cyl23un","tag_id":"cm2vyo6bt001dskus7y5ygtvy","_id":"cm2vyo6bu001gskus4vd92xmb"},{"post_id":"cm2vyo6br000uskus8ei7291y","tag_id":"cm2vyo6bu001fskush852dauh","_id":"cm2vyo6bu001hskuscdzg77s9"},{"post_id":"cm2vyo6bw001iskusax41absa","tag_id":"cm2vyo6bw001kskus1qwhaoh3","_id":"cm2vyo6bw001lskusbtnqab7i"},{"post_id":"cm2vz0zei0000isushx4ebb8i","tag_id":"cm2vz137r0004isusfesu1hr4","_id":"cm2vz137s0005isus82ol7k06"},{"post_id":"cm2vz0zei0000isushx4ebb8i","tag_id":"cm2vyo6bn000hskus335d5xpp","_id":"cm2vz15yn0006isusbpyifd5d"}],"Tag":[{"name":"JUC","_id":"cm2vyo6bi0005skus4ntc6c4v"},{"name":"计算机网络","_id":"cm2vyo6bl000bskusdcv7hvi6"},{"name":"SpringBoot","_id":"cm2vyo6bn000hskus335d5xpp"},{"name":"juc","_id":"cm2vyo6bs000yskus653u3tmm"},{"name":"分布式","_id":"cm2vyo6bs0012skushdxv7z6a"},{"name":"java_IO","_id":"cm2vyo6bs0017skuseagzh6tk"},{"name":"java锁","_id":"cm2vyo6bt0019skusghow8y6i"},{"name":"cpu缓存","_id":"cm2vyo6bt001dskus7y5ygtvy"},{"name":"jvm","_id":"cm2vyo6bu001fskush852dauh"},{"name":"算法合集","_id":"cm2vyo6bw001kskus1qwhaoh3"},{"name":"SpringBoot日志","_id":"cm2vz0zek0001isusa4jmbmco"},{"name":"日志","_id":"cm2vz137r0004isusfesu1hr4"}]}}